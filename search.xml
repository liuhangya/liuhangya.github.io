<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android 架构演进理念分析</title>
    <url>/2023/08/30/android/architecture/architecture/</url>
    <content><![CDATA[<p>Android 架构演进理念分析</p>
<span id="more"></span>


<p>一、 软件的首要技术使命是“管理复杂度”，低复杂度才能降低理解成本和沟通难度，提升应对变更的灵活性，减少重复劳动，最终提高代码质量。</p>
<p>二、 架构的目的在于“将复杂度分层”，不要将复杂度会在同一层次展开，那样会形式所谓的上帝类【比如，超1000行代码的Activity】，将复杂度会层，每一层功能独立且明确，单一职责，这样才能尽可能地减少因为改动而导致的影响面，尽量<br>    不影响其他层。</p>
<p>三、 为了降低客户端领域开发的复杂度，架构也在不断地演进。从 MVC 到 MVP，再到 MVVM，目前已经发展到 MVI。</p>
<ol>
<li><p>MVC 架构 ：模型（Model）、视图（View）、控制器（Controller）</p>
<p>视图层：Android的xml布局文件和Activity&#x2F;Fragment文件被划分为View视图层。 因为xml作为视图层功能太弱，只能够实现页面的布局，不能够实现页面数据和事件的处理，需要和Activity一起才能够构成一个完整的视图层。</p>
<p>业务层：大多数的MVC架构开发的安卓项目，并没有把Controller业务层独立出来，而是将业务层也在Activity&#x2F;Fragment中实现。这导致了Activity&#x2F;Fragment的代码非常臃肿，【比如，超1000行代码的Activity】。</p>
<p>数据层：数据管理模块，这包括了数据的获取，加工、存储等。</p>
</li>
</ol>
<p>  实现代码说明：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 描述：最早的传统 MVC 架构功能实现，这里模拟一个 登录 功能，输入账号密码，点击登录按钮，底部显示登录状态文本</span><br><span class="line"> */</span><br><span class="line">class MVCActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">  private lateinit var binding: ActivityMvcBinding</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 描述：M 层，用于处理数据</span><br><span class="line">  */</span><br><span class="line">  private val model = Model()</span><br><span class="line"></span><br><span class="line">  override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    binding = ActivityMvcBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">    // 登录按钮事件</span><br><span class="line">    binding.btnLogin.setOnClickListener &#123; login(binding.etAccount.text.toString(), binding.etPassword.text.toString()) &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 描述：登录，这里将本该放在独立业务层的，放在 V 层，把 Activity 当作 C 层用，用的时候确实方便，但是当功能非常复杂时，该类会非常臃肿，复杂度在该类</span><br><span class="line">   * 直接铺开，因为高度的耦合，不利用于代码复用，难以维护，修改容易出 bug</span><br><span class="line">   */</span><br><span class="line">  private fun login(account: String, password: String) &#123;</span><br><span class="line">    // 调用 M 层的方法获取结果</span><br><span class="line">    val success = model.login(account, password)</span><br><span class="line">    // 根据结果来渲染页面</span><br><span class="line">    binding.tvLoginResult.text = if (success) &quot;登录成功！&quot; else &quot;登录失败！&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 描述：模型层，用于数据获取、加工等</span><br><span class="line"> */</span><br><span class="line">class Model &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 描述：这里模拟一下登录成功或失败</span><br><span class="line">   */</span><br><span class="line">  fun login(account: String, password: String) =</span><br><span class="line">    account.isNotEmpty() &amp;&amp; password.isNotEmpty() &amp;&amp; account == &quot;123&quot; &amp;&amp; password == &quot;123&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>MVP 架构：模型（Model）、视图（View）、业务逻辑层（Presenter）</p>
<p>视图层：Android的xml布局文件和Activity&#x2F;Fragment文件被划分为View视图层。 因为xml作为视图层功能太弱，只能够实现页面的布局，不能够实现页面数据和事件的处理，需要和Activity一起才能够构成一个完整的视图层。</p>
<p>业务层：Presenter 对象用于业务层，对逻辑进行处理，内部通过数据层来访问数据。使得界面绘制和业务逻辑分开，降低了它们的耦合，形成相互独立的界面层 V 和业务逻辑层 P。通过接口实现界面层和业务逻辑层的双向通信，<br>  界面层通过业务接口向业务逻辑层发起请求。业务逻辑层通过 View 层接口指导界面绘制。接口是一种抽象手段，它把做什么和怎么做分离，为发生多态提供了便利。<br>数据层：数据管理模块，这包括了数据的获取，加工、存储等。</p>
<p>由上述分析可知，V 层的业务逻辑处理给到了 P 层，所以 V 层更加单纯了，也没那么臃肿了，复杂度也降低了，跟 M 和 P 层的耦合度都降低了。</p>
<p>缺点：<br>2.1 因为 View 层接口的存在，迫使 Presenter 得了解该把哪个数据塞给哪个 View 层接口。这是一种耦合，Presenter 和这个具体的 View 层接口耦合，较难复用于其他业务。<br>2.2 MVP 并未向界面提供唯一 UI 状态，而是将描述一个完整界面的 UI 状态 分散在若干 View 层接口回调中。这使得界面的绘制无法内聚到一点，增加了界面绘制逻辑维护的复杂度。<br>2.3 理论上，界面和业务分层之后，各自都更加单纯，为复用提供了可能性。但不管是业务接口的复用，还是View层接口的复用都相当别扭。<br>2.4 Presenter 与界面共存亡 ，使得 MVP 无法应对横竖屏切换的场景。<br>2.5 MVP 无法优雅地实现跨界面通信，也未内建粘性通信机制，得借助第三方库实现。<br>2.6 MVP 并未内建生命周期管理机制，易造成内存泄漏、crash、资源浪费。</p>
</li>
</ol>
<p>  实现代码说明：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /**</span><br><span class="line"> * 描述：MVP 架构功能实现，这里模拟一个 登录 功能，输入账号密码，点击登录按钮，底部显示登录状态文本</span><br><span class="line"> *  1. V 层会持有 P 层实例(面向接口，不是具体实例)，P 层实现 P层相关接口，让 V 层来发起具体业务。</span><br><span class="line"> *  2. P 层会持有 V 层实例(面向接口，不是具体实例)，V 层实现 V 层相关接口，来指导 P 层处理完业务逻辑之后的页面绘制。</span><br><span class="line"> *  3. P 层也会持有 M 层实例，用于数据的获取。</span><br><span class="line"> *</span><br><span class="line"> *  总结：思想是独立业务层，页面刷新和业务发起都面向接口，便于代码复用和解耦，职责分工非常明确。但是会新增大量的接口，且代码复用时会造成很多空接口实现，增大了界面绘制的复杂度。</span><br><span class="line"> */</span><br><span class="line">class MVPActivity : AppCompatActivity(),IView&#123;</span><br><span class="line"></span><br><span class="line">  private lateinit var binding: ActivityMvpBinding</span><br><span class="line"></span><br><span class="line">  // 持有 P 层实例</span><br><span class="line">  private val presenter :IPresenter= Presenter()</span><br><span class="line"></span><br><span class="line">  override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    binding = ActivityMvpBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">    presenter.init(this)</span><br><span class="line">    // 登录按钮事件，通过 P 层发起业务</span><br><span class="line">    binding.btnLogin.setOnClickListener &#123; presenter.login(binding.etAccount.text.toString(), binding.etPassword.text.toString()) &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override fun loginSuccess() &#123;</span><br><span class="line">    // 根据接口约定来渲染页面</span><br><span class="line">    binding.tvLoginResult.text = &quot;登录成功！!&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override fun loginFail() &#123;</span><br><span class="line">    // 根据接口约定来渲染页面</span><br><span class="line">    binding.tvLoginResult.text = &quot;登录失败！！&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override fun onDestroy() &#123;</span><br><span class="line">    super.onDestroy()</span><br><span class="line">    presenter.destroy()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 描述：模型层，用于数据获取、加工等</span><br><span class="line"> */</span><br><span class="line">class Model &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 描述：这里模拟一下登录成功或失败</span><br><span class="line">   */</span><br><span class="line">  fun login(account: String, password: String) =</span><br><span class="line">    account.isNotEmpty() &amp;&amp; password.isNotEmpty() &amp;&amp; account == &quot;123&quot; &amp;&amp; password == &quot;123&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 描述：业务逻辑层，持有 M 和 V 层，通过 View 层接口指导界面绘制</span><br><span class="line">*/</span><br><span class="line">class Presenter : IPresenter &#123;</span><br><span class="line">  // 持有 V 层，不指向具体，面向接口抽象，便于解耦</span><br><span class="line">  private var view:IView? = null</span><br><span class="line">  // 持有 M 层 ，用于数据的处理</span><br><span class="line">  private val model = Model()</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 描述：初始化</span><br><span class="line">  */</span><br><span class="line">  override fun init(view:IView) &#123;</span><br><span class="line">    this.view = view</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 描述：具体业务</span><br><span class="line">  */</span><br><span class="line">  override fun login(account: String, password: String) &#123;</span><br><span class="line">    val success = model.login(account, password)</span><br><span class="line">    if (success) &#123;</span><br><span class="line">      view?.loginSuccess()</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      view?.loginFail()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 描述：销毁</span><br><span class="line">  */</span><br><span class="line">  override fun destroy() &#123;</span><br><span class="line">    this.view = null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 描述：业务逻辑层接口，让 V 层通过业务接口向业务逻辑层发起请求</span><br><span class="line"> */</span><br><span class="line">interface IPresenter &#123;</span><br><span class="line">  fun init(view:IView)</span><br><span class="line">  fun login(account: String, password: String)</span><br><span class="line">  fun destroy()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 描述：V 层接口，让 P 层通过该层接口指导界面绘制</span><br><span class="line"> */</span><br><span class="line">interface IView &#123;</span><br><span class="line">  fun loginSuccess()</span><br><span class="line">  fun loginFail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>MVVM 架构：模型（Model）、视图（View）、业务逻辑层（ViewModel）</li>
</ol>
<p>   视图层：Android的xml布局文件被划分为View视图层。</p>
<p>   业务层：ViewModel 对象用于业务层，对逻辑进行处理，内部通过数据层来访问数据。使得界面绘制和业务逻辑分开，降低了它们的耦合，形成相互独立的界面层 V 和业务逻辑层 VM。</p>
<p>   数据层：数据管理模块，这包括了数据的获取，加工、存储等。</p>
<p>   分析：<br>   3.1. V 层会持有 VM 层实例，但是 VM 的生命周期比界面更长，在能够感知界面的生命周期，在 Activity 配置发生变化被销毁重建时恢复数据，以保证不会重新触发业务逻辑，解决了 P 层的痛点。<br>   3.2. VM 层不再需要持有 V 层的引用了，而是通过 DataBinding 来跟页面进行绑定，进行双向通信，通过观察者模式，在数据更新时自动刷新界面。<br>   3.3. 界面刷新是以数据来驱动的，是响应式的，界面的刷新是持续不断去响应的，只要数据变更，就会响应刷新。而不像 P 层那样，要找到对应的 V 层接口方法去命令式地调用，进行界面刷新。<br>   3.4. 因为业务层只操纵数据，界面通过观察数据的方式实现刷新，所以更加的解耦，VM 层能更好地被复用。不同的界面可以以任何喜欢的方式组合使用业务层提供的数据。<br>   3.5. 不再需要定义各种根据业务或状态而决定的接口回调，更加的自由了。  </p>
<p>实现代码说明：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   /**</span><br><span class="line"> * 描述：MVVM 架构功能实现，这里模拟一个 登录 功能，输入账号密码，点击登录按钮，底部显示登录状态文本</span><br><span class="line"> *</span><br><span class="line"> *  1. V 层会持有 VM 层实例，但是 VM 的生命周期比界面更长，在能够感知界面的生命周期，在 Activity 配置发生变化被销毁重建时恢复数据，以保证不会重新触发业务逻辑，解决了 P 层的痛点。</span><br><span class="line"> *  2. VM 层不再需要持有 V 层的引用了，而是通过 DataBinding 来跟页面进行绑定，进行双向通信，通过观察者模式，在数据更新时自动刷新界面。</span><br><span class="line"> *  3. 界面刷新是以数据来驱动的，是响应式的，界面的刷新是持续不断去响应的，只要数据变更，就会响应刷新。而不像 P 层那样，要找到对应的 V 层接口方法去命令式地调用，进行界面刷新。</span><br><span class="line"> *  4. 因为业务层只操纵数据，界面通过观察数据的方式实现刷新，所以更加的解耦，VM 层能更好地被复用。不同的界面可以以任何喜欢的方式组合使用业务层提供的数据。</span><br><span class="line"> *</span><br><span class="line"> *  代码实现说明 ：通过Android提供的数据双向绑定库data binding 将Acitvity/xml视图层与ViewModel绑定。在xml布局文件中，通过@&#123;&#125;来表示单向绑定或者@=&#123;&#125;来表示双向绑定。</span><br><span class="line"> *  Activity接受到视图层的登录点击事件后，调用ViewModel处理登录业务逻辑，ViewModel通过双向数据绑定拿到到视图层输入的账号密码数据，调用Model处理数据，Model处理数据后，</span><br><span class="line"> *  回传给ViewModel, ViewModel的数据改变，View感知后刷新页面。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class MVVMActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">  // 持有 VM 层实例</span><br><span class="line">  private val vm by viewModels&lt;MVVMViewModel&gt;()</span><br><span class="line"></span><br><span class="line">  private lateinit var binding: ActivityMvvmBinding</span><br><span class="line"></span><br><span class="line">  override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">     binding =</span><br><span class="line">         DataBindingUtil.setContentView&lt;ActivityMvvmBinding?&gt;(this, </span><br><span class="line">         R.layout.activity_mvvm).apply &#123;</span><br><span class="line">         setVariable(BR.viewModel, vm)</span><br><span class="line">         lifecycleOwner = this@MVVMActivity</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    // 登录按钮事件，通过 VM 层发起业务</span><br><span class="line">     binding.btnLogin.setOnClickListener &#123; vm.login() &#125;</span><br><span class="line"></span><br><span class="line">    // 观察数据</span><br><span class="line">    vm.account.observe(this) &#123;</span><br><span class="line">      ToastUtils.showShortToast(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 观察数据</span><br><span class="line">    vm.password.observe(this) &#123;</span><br><span class="line">      ToastUtils.showShortToast(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 观察数据</span><br><span class="line">    vm.loginResult.observe(this) &#123;</span><br><span class="line">      ToastUtils.showShortToast(it)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 描述：模型层，用于数据获取、加工等</span><br><span class="line"> */</span><br><span class="line">class Model &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 描述：这里模拟一下登录成功或失败</span><br><span class="line">   */</span><br><span class="line">  fun login(account: String, password: String) =</span><br><span class="line">    account.isNotEmpty() &amp;&amp; password.isNotEmpty() &amp;&amp; account == &quot;123&quot; &amp;&amp; password == &quot;123&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 描述：VM 层，相当于 P 层，但是不需要通过 V 层接口来指导页面来绘制了，而是通过 DataBinding 来跟页面进行绑定，进行双向通信，通过观察者模式，在数据更新时自动刷新界面。</span><br><span class="line"> *      这使得 VM 层不再需要持有 V 层，跟 V 层解耦， V 层持有 VM 层实例，对想要观察的数据进行监听即可。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class MVVMViewModel : ViewModel() &#123;</span><br><span class="line">  // 可观察数据</span><br><span class="line">  val account = MutableLiveData(&quot;&quot;)</span><br><span class="line">  val password = MutableLiveData(&quot;&quot;)</span><br><span class="line">  val loginResult = MutableLiveData(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">  // 持有 M 层 ，用于数据的处理</span><br><span class="line">  private val model = Model()</span><br><span class="line"></span><br><span class="line">  // 登录业务方法</span><br><span class="line">  fun login() &#123;</span><br><span class="line">    val success = model.login(account.value.orEmpty(), password.value.orEmpty())</span><br><span class="line">    loginResult.value = if (success) &quot;登录成功！!&quot; else &quot;登录失败！！&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 4.MVI 架构：不关心业务层形态，而是关心业务数据变换及流动的形态。是一个单向数据流。界面是数据流的起点（生产者）也是终点（消费者），界面发出的数据叫（业务）意图，<br>   意图会用函数式编程的方式被变换为状态，最终状态通过响应式编程的方式流向界面，界面消费状态完成刷新。在这个流动的过程中，若保证了唯一可信数据源，就能实现单向数据流。</p>
<p>  MVI 架构对意图和状态的管理非常重要，过分仔细地区别会显得太乱，全部集中管理状态，会显的太臃肿，可能对界面刷新有性能影响。我们应该尽量集中管理独立的业务和状态，互相不影响。</p>
<p>  难点：什么情况下应该定义为意图，意图的维度，还有状态的维度，状态的字段到底要集中管理多少个属性，怎么定义并区分独立于其他的状态。页面状态独立消费处理，粒度不能太大，因为不能频繁刷新而影响性能，也不能太小，会导致刷新位置过于分散。</p>
<p>  以下为非传统的 MVI 实现方式分析 ：</p>
<ol>
<li><p>意图(Intent)： 当前框架中的 Intent 非传统意义上的 MVI intent， 而是简化 reduce 和 action 后，拍平的 intent， 它可以携带 param，input 至 mvi-Dispatcher， 也可以 copy 和携带 result，output 至表现层。<br>当实现 MVI 功能时，首先要分析各业务意图，进行意图的划分管理，包括入参和出参。</p>
<p>意图的管理：是通过多个不同的意图来区别业务，还是通过不同的入参来区别业务，需要斟酌。如果通过入参来区分，那么出参可能也要增加字段。</p>
</li>
<li><p>状态的定义(UIState)： 意图通过响应式编程处理并加工各种数据，并将（最终的处理结果）界面需要的状态封装成 data class ， 这里的 data 称之为 State 状态，但是这个状态不是对应一个 LiveData ，而是通过状态管理划分出来的一个数据对象。</p>
<p>状态的管理：是通过不同的 data class 来刷新页面，还是通过集中管理 data class 中包括的字段来刷新页面。</p>
<p>最终的 State 会通过 Intent ，copy 一个无副作用的对象（保证线程安全、数据可信唯一）并设置到出参字段，然后流向终点（界面）进行消费。在界面中，会通过不同的业务意图进行分支处理。</p>
</li>
<li><p>流程是这样的： 意图带入参进行业务发送，ViewModel 来处理业务（单纯的领域层，内部包括 M 层进行数据的获取等，根据不同的意图进行一定程度的业务处理，并不包括数据的存储和恢复）。本架构的 StateHolder 不在同一个 ViewModel 中，而是新建的<br>ViewModel ，放在 UI 层，用于数据的保存和恢复。这样，业务层的 ViewModel 相当的单纯，很方便被复用。StateHolder 的属性都是 ObservableField 对象，通过 DataBinding 进行页面的刷新绑定。<br>整个页面的刷新逻辑都是遵循： Intent(业务意图) - (VM 处理) - View (消费) </p>
</li>
<li><p>对于一些全局的业务VM ，可以通过 applicationViewModels 扩展函数来获取 VM ，这样该 VM 生命周期就是 Application 生命周期的，可随时进行意图的加工和发送，比如一些页面的刷新处理，一定程度上可以替代 EventBus 。</p>
</li>
</ol>
<p>   为什么不直接在 UI 层通过方法调用来处理逻辑呢？</p>
<p>   答： 第一，不符合 MVI 架构的理念，并不是意向数据流。第二，复用度低，如果 A、B、C 三个页面都有一些相同的意图业务，每个类都是直接通过类内函数来处理，则无法进行代码复用。将方法放在基类又有点违反原则了。放在 VM 中进行复用，相当的有效，跟 MVP 中<br>       放在 P 层共用是一样的道理。注意，是业务意图，如果是单纯的界面处理逻辑，完全可以通过方法进行调用。</p>
<p>   总结：Intent 就是在提示你，将原先命令式的函数调用转换成一个事件数据，用响应式编程的方式进行事件到状态的变换，并且还得保证界面状态有唯一可信数据源，这样界面的刷新就形成了一条单向数据流。<br>   总结：只要满足“响应式编程”、“单向数据流”、“唯一可信数据源”这三个原则的都可以称之为 MVI。不管使用的是 ViewModel 还是 Presenter。MVI 关心的不是具体的界面状态持有者，而是整个更新界面数据链路的流动方式和方向。</p>
<p>  本架构中的 MVI 使用：<br>    1. MVVM 中 ，原本界面发起的事件是通过 ViewModel 的一个方法调用传递的。MVI 中，是响应式编程，得把函数调用用 “数据” 的形式包装起来。本架构中，用 input 方法发送上游数据。<br>    2. 接着在 onHandle 方法中对流上的数据进行变换处理，这个阶段可以通过 flow 的各种操作进行处理，流出的是 State ，用于界面消费渲染。本架构中，最终的 State 通过 Intent copy 之后的出参来设置。<br>    3. 最终 State 的消费由 sendResult 方法发送到界面层，界面层通过 output 出口拿到对应的 Intent 中的 State 进行消费【其中， State 会被界面层专属的 StateHolder 进行保存，用于数据恢复和使用】，本架构不对<br>       领域层的 State 进行监听消费，而将 State（界面状态）和 Activity&#x2F;fragment（界面展示）放在一起，归为 UI 层 ，但是 State 是通过 StateHolder 来保存的，也是一个 ViewModel ，只是这个 ViewModel 的职责专属该 UI 层保存和<br>       恢复数据 ，而领域层 VM ，对流进行业务处理，可供同业务不同页面复用。至此，一个单向数据流消费完成。</p>
<p>实现代码说明：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /**</span><br><span class="line"> * 描述：MVI 架构功能实现，这里模拟一个 登录 功能，输入账号密码，点击登录按钮，底部显示登录状态文本</span><br><span class="line"> *</span><br><span class="line"> * 本架构中的 MVI 使用：</span><br><span class="line"> *   1. MVVM 中 ，原本界面发起的事件是通过 ViewModel 的一个方法调用传递的。MVI 中，是响应式编程，得把函数调用用 &quot;数据&quot; 的形式包装起来。本架构中，用 input 方法发送上游数据。</span><br><span class="line"> *   2. 接着在 onHandle 方法中对流上的数据进行变换处理，这个阶段可以通过 flow 的各种操作进行处理，流出的是 State ，用于界面消费渲染。本架构中，最终的 State 通过 Intent copy 之后的出参来设置。</span><br><span class="line"> *   3. 最终 State 的消费由 sendResult 方法发送到界面层，界面层通过 output 出口拿到对应的 Intent 中的 State 进行消费【其中， State 会被界面层专属的 StateHolder 进行保存，用于数据恢复和使用】，本架构不对</span><br><span class="line"> *      领域层的 State 进行监听消费，而将 State（界面状态）和 Activity/fragment（界面展示）放在一起，归为 UI 层 ，但是 State 是通过 StateHolder 来保存的，也是一个 ViewModel ，只是这个 ViewModel 的职责专属该 UI 层保存和</span><br><span class="line"> *      恢复数据 ，而领域层 VM ，对流进行业务处理，可供同业务不同页面复用。至此，一个单向数据流消费完成。</span><br><span class="line"> */</span><br><span class="line">class MVIActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 描述： State（界面状态）和 Activity/fragment（界面展示）放在一起，归为 UI 层，专属该 UI 层保存和恢复数据</span><br><span class="line">   */</span><br><span class="line">  class MVIStateHolder : StateHolder() &#123;</span><br><span class="line">    val account = State(&quot;&quot;)</span><br><span class="line">    val password = State(&quot;&quot;)</span><br><span class="line">    val loginResult = State(&quot;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 持有 VM 层实例</span><br><span class="line">  private val vm by viewModels&lt;MVIViewModel&gt;()</span><br><span class="line">  private val accountStates by viewModels&lt;MVIStateHolder&gt;()</span><br><span class="line"></span><br><span class="line">  private lateinit var binding: ActivityMviBinding</span><br><span class="line"></span><br><span class="line">  override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    binding =</span><br><span class="line">      DataBindingUtil.setContentView&lt;ActivityMviBinding&gt;(this, R.layout.activity_mvi).apply &#123;</span><br><span class="line">        // 注意：这里传进去的 states 不要跟外层定义的变量同名，不然根据就没传入，引用的还是内层的对象</span><br><span class="line">        setVariable(BR.states, accountStates)</span><br><span class="line">        lifecycleOwner = this@MVIActivity</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    binding.btnLogin.setOnClickListener &#123;</span><br><span class="line">      // 发送登录意图</span><br><span class="line">      vm.input(</span><br><span class="line">        AccountManagerIntent.LoginAccount(</span><br><span class="line">          accountStates.account.get()!!,</span><br><span class="line">          accountStates.password.get()!!</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 唯一出口，消费 Intent 中的 State</span><br><span class="line">    vm.output(this) &#123; accountManagerIntent -&gt;</span><br><span class="line">      when (accountManagerIntent) &#123;</span><br><span class="line">        is AccountManagerIntent.LoginAccount -&gt; &#123;</span><br><span class="line"></span><br><span class="line">          updateUIState(accountManagerIntent.state)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 描述： 更新页面，状态独立处理，粒度不能太大，因为不能频繁刷新而影响性能，也不能太小，会导致刷新位置过于分散</span><br><span class="line">   */</span><br><span class="line">  private fun updateUIState(state: AccountManagerState) &#123;</span><br><span class="line">    accountStates.loginResult.set(state.loginResult)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 描述：模型层，用于数据获取、加工等</span><br><span class="line"> */</span><br><span class="line">class Model &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 描述：这里模拟一下登录成功或失败</span><br><span class="line">   */</span><br><span class="line">  fun login(account: String, password: String) =</span><br><span class="line">    account.isNotEmpty() &amp;&amp; password.isNotEmpty() &amp;&amp; account == &quot;123&quot; &amp;&amp; password == &quot;123&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 描述：UI State</span><br><span class="line"> */</span><br><span class="line">data class AccountManagerState(val success: Boolean = false, val loginResult: String = &quot;没登录&quot;)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 描述： 账号管理意图，可能包括账号注册、登录、找回密码、注销等等</span><br><span class="line"> */</span><br><span class="line">sealed class AccountManagerIntent &#123;</span><br><span class="line">  // 登录业务意图</span><br><span class="line">  data class LoginAccount(</span><br><span class="line">    val account: String,</span><br><span class="line">    val password: String,</span><br><span class="line">    val state: AccountManagerState = AccountManagerState()</span><br><span class="line">  ) : AccountManagerIntent()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 描述：对流进行业务处理，可供同业务不同页面复用</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class MVIViewModel : MviDispatcherKTX&lt;AccountManagerIntent&gt;() &#123;</span><br><span class="line"></span><br><span class="line">  // 持有 M 层 ，用于数据的处理</span><br><span class="line">  private val model = Model()</span><br><span class="line"></span><br><span class="line">  override suspend fun onHandle(event: AccountManagerIntent) &#123;</span><br><span class="line">    when (event) &#123;</span><br><span class="line">      is AccountManagerIntent.LoginAccount -&gt; &#123;</span><br><span class="line">        // 业务处理，可以是复杂的 flow 处理，流出 State</span><br><span class="line">        val success = model.login(event.account, event.password)</span><br><span class="line">        // 发送 State 给 UI 层消费，通过同一个 Intent 流出</span><br><span class="line">        val state = AccountManagerState(success, if (success) &quot;登录成功！!&quot; else &quot;登录失败！！&quot;)</span><br><span class="line">        ToastUtils.showShortToast(state.loginResult)</span><br><span class="line">        sendResult(event.copy(state = state))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 初识</title>
    <url>/2023/08/30/git/git_start/</url>
    <content><![CDATA[<p>Git 初识</p>
<span id="more"></span>

<p> 查看版本： git –version</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3511431-d3768894534cd8d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p> 查看配置列表： git  config –list</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3511431-a4f6a00f1010046a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p> 配置用户名和邮箱地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;fanda&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;xxxx.com&quot;</span><br></pre></td></tr></table></figure>
<p> 单独查询某条配置：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3511431-8583ac5c498112e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p> 开始详细操作演示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3511431-f74af3a92127915e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p> 操作文件夹为:  e&#x2F;git_study&#x2F;demo</p>
<p>通过 git init 命令来初始化版本库，默认会在工作区创建一个隐藏目录 .git  ，这个 .git 就是版本仓库 ，可通过 ls -a 来查看隐藏的目录。</p>
<p>现在 demo 目录就是工作区，目前除了 .git 目录外空无一物。</p>
<p> 添加一个文件 welcome.txt 并编辑内容为 Hello.</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3511431-a7150f98d9793d16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p> 通过 git status 来查看当前工作区的状态如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3511431-082e623b298e22a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br> 明确提示，没有任何内容可提交，但是出现了未被追踪的文件，应该先通过 git add 将文件追踪。</p>
<p>添加并提交文件：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3511431-ae5922f4c94f7644.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p> 提交结果说明：</p>
<ol>
<li><p>第一行: 在名为 master 的分支上，且是该分支的第一个提交(root-commit) ，提交ID为 22d9b0e ，提交描述为 initialized. 。</p>
</li>
<li><p>第二行: 提交修改了一个文件，包含一行插入。</p>
</li>
<li><p>此次提交创建了新文件 welcome.txt 。</p>
</li>
</ol>
<p> 说明： .git 所在目录就是工作区的根目录，git 的相关操作要在工作区中操作才能正常执行，当在工作区的子目录中操作时，会递归查找 .git 目录。</p>
<p> 在工作区外操作会报如下错误：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3511431-8abcd0b566960a07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p> 可通过  git rev-parse –git-dir 命令来查看 .git 所在的目录 ：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3511431-b5243ecd4be52312.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p> 可通过 git rev-parse –show-toplevel 命令来查看工作区根目录：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3511431-037bf50fa4429e29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p> 备份仓库，可通过 git clone 命令 ：<br><img src="https://upload-images.jianshu.io/upload_images/3511431-cc08cb62f63568b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>如上，我们把 demo 备份为了名为 demo-step-1 的文件夹。</p>
<p> 注意：目录路径为 git_study ，而不是 demo ，是 demo 的上一级 。</p>
<p> 三个不同级别的配置文件：</p>
<ol>
<li><p>版本库的配置文件：就是当前工作区的 .git&#x2F;config 文件 。  命令 git config -e 可查看 , :wq 退出编辑，注意先输入冒号</p>
</li>
<li><p>全局配置文件：用户主目录下的 .gitconfig文件 。命令 git config -e –global 可查看 , :wq 退出编辑，注意先输入冒号</p>
</li>
<li><p>系统级配置文件： &#x2F;etc 目录下。命令 git config -e –system 可查看 , :q 退出编辑，注意先输入冒号，系统文件不可写</p>
</li>
</ol>
<p> 优先级：版本库级别的配置文件的优先级最高，全局配置文件次之，系统级配置文件排最后。相同的配置按优先级进行覆盖。</p>
<p>总结： 版本创建三部曲，git init 、git add 、git commit 。</p>
]]></content>
  </entry>
  <entry>
    <title>hexo命令使用</title>
    <url>/2023/08/30/hexo-use/</url>
    <content><![CDATA[<p>hexo命令使用</p>
<span id="more"></span>

<ol>
<li><p>hexo s或hexo server  : 启动服务，默认地址为<a href="http://localhost:4000/%EF%BC%8C4000%E7%AB%AF%E5%8F%A3">http://localhost:4000/，4000端口</a></p>
</li>
<li><p>hexo d或hexo deploy  : 部署站点，在本地生成.deploy_git文件夹，并将编译后的文件上传至 GitHub。</p>
</li>
<li><p>hexo new xxx pagename  : 例如： hexo new photo “my-first-blog” 上述指令执行时，Hexo 会尝试在 scaffolds 中寻找photo.md布局，若找到，则根据该布局新建文章；若未找到或指令中未指定该参数，则使用post.md新建文章。新建文章的名称在_config.yml中配置。</p>
</li>
<li><p>hexo clean   : 将 public 文件夹删除</p>
</li>
<li><p>hexo g或hexo generate  ：该命令执行后在hexo站点根目录下生成public文件夹</p>
</li>
<li><p>可以这样创建指定目录下的文件 ： hexo new page -p git&#x2F;git_start</p>
</li>
<li><p>hexo g -d ： 可以这样一步生成并部署</p>
</li>
</ol>
<p>文章布局如下： </p>
<hr>
<p>title: livedata<br>date: 2022-06-06 14:23:54<br>&#x2F;&#x2F; 标签<br>tags: jetpack android<br>&#x2F;&#x2F; 是否置顶<br>top: ture<br>toc: ture<br>&#x2F;&#x2F; 这是封面图片<br>photos: [			<br>        [“<a href="https://github.com/liuhangya/liuhangya.github.io/blob/main/gallery/index/juanjuan01.jpg?raw=true&quot;%5D">https://github.com/liuhangya/liuhangya.github.io/blob/main/gallery/index/juanjuan01.jpg?raw=true&quot;]</a><br>]</p>
<hr>
<p>这是显示在文章列表中的概要</p>
<!--more-->]]></content>
  </entry>
  <entry>
    <title>livedata</title>
    <url>/2022/06/06/hello-world/</url>
    <content><![CDATA[<p>方直项目说明文档</p>
<span id="more"></span>

<h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><h5 id="1-调用方直提供的API进行书本资源下载"><a href="#1-调用方直提供的API进行书本资源下载" class="headerlink" title="1.调用方直提供的API进行书本资源下载"></a>1.调用方直提供的API进行书本资源下载</h5><p>API信息（目前提供的是测试环境，需要定向开放才可访问，调试前需将执象调用方的外网ip提供给方直进行开通）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址（测试）：http://183.47.42.218:9222/aop/active</span><br><span class="line">请求参数示例：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;FunWay&quot;: 0,</span><br><span class="line">    &quot;FunName&quot;: &quot;GetThirdPartyBookResource&quot;,</span><br><span class="line">    &quot;Info&quot;: &quot;&#123;\&quot;BookID\&quot;:\&quot;534\&quot;,\&quot;Cooperation\&quot;:\&quot;ZElephant\&quot;,\&quot;DeviceNo\&quot;:\&quot;aff8bf9551d2d36e\&quot;,\&quot;SecretKey\&quot;:\&quot;089f79cffa8af74e1966ba2fa34cd370\&quot;&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">返回参数示例：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Data&quot;: &quot;&#123;\&quot;BookResource\&quot;:&#123;\&quot;ResourceUrl\&quot;:\&quot;https://bskcdn.kingsun.cn/prod/waterdrop/534_1652814879223.zip\&quot;,\&quot;Version\&quot;:\&quot;1.0.2\&quot;,\&quot;CreatedAt\&quot;:\&quot;2022-05-01 00:00:00\&quot;&#125;,\&quot;Device\&quot;:\&quot;Pe6049pVeoO2SrOD/pua+hfw6AYkWASZwFkZ6t6wy89v4szsd1h+gbW24Bhg0oyrxuQefTWoT5sYo7cwSO37ew==\&quot;&#125;&quot;,</span><br><span class="line">    &quot;ErrorCode&quot;: 0,</span><br><span class="line">    &quot;ErrorMsg&quot;: null,</span><br><span class="line">    &quot;RequestID&quot;: null,</span><br><span class="line">    &quot;Success&quot;: true,</span><br><span class="line">    &quot;SystemTime&quot;: &quot;/Date(1654677650875)/&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求字段说明：</p>
<table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="center">类型</th>
<th align="center">说明</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FunWay</td>
<td align="center">Int</td>
<td align="center">接口方式</td>
<td align="left">必传（固定传0）</td>
</tr>
<tr>
<td align="center">FunName</td>
<td align="center">String</td>
<td align="center">接口方法名</td>
<td align="left">必传</td>
</tr>
<tr>
<td align="center">BookID</td>
<td align="center">Int</td>
<td align="center">方直科技书本id</td>
<td align="left">必传</td>
</tr>
<tr>
<td align="center">Cooperation</td>
<td align="center">String</td>
<td align="center">合作方名</td>
<td align="left">必传</td>
</tr>
<tr>
<td align="center">DeviceNo</td>
<td align="center">String</td>
<td align="center">设备id</td>
<td align="left">必传（android高版本不建议或禁用一般应用获取IMEI等设备信息，<br/>这里暂定为使用android_Id , 获取android_id不需要授权，<br/>但是会受签名影响发生变化，对接时需进一步沟通）</td>
</tr>
<tr>
<td align="center">SecretKey</td>
<td align="center">String</td>
<td align="center">合作方秘钥</td>
<td align="left">必传（由方直分配）</td>
</tr>
</tbody></table>
<p>返回字段说明：</p>
<table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="center">类型</th>
<th align="center">说明</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ResourceUrl</td>
<td align="center">String</td>
<td align="center">书本资源下载链接</td>
<td align="left">由于跨应用共享文件目录涉及到文件读写权限获取的问题，<br/>android高版本限制了应用的文件读写范围，执象的设备是自定制系统，<br/>建议下载后将资源包存放至同步学HD app的外部存储的应用专属空间，即<br/>&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;com.elephant.synstudy.custom&#x2F;files<br/>目录下，这样可以避免存储授权操作，优化体验</td>
</tr>
<tr>
<td align="center">Version</td>
<td align="center">String</td>
<td align="center">书本资源版本号</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">Device</td>
<td align="center">String</td>
<td align="center">设备鉴权信息</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="接入说明"><a href="#接入说明" class="headerlink" title="接入说明"></a>接入说明</h4><h5 id="1-安装-同步学HD-app"><a href="#1-安装-同步学HD-app" class="headerlink" title="1.安装 同步学HD app"></a>1.安装 同步学HD app</h5><p>apk包位于Demo工程根目录下</p>
<h5 id="2-文件配置"><a href="#2-文件配置" class="headerlink" title="2.文件配置"></a>2.文件配置</h5><p>在 module 下的 build.gradle 内添加如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 该插件可选，只是为了方便实体类序列化，如果不用，自行实现 parcelable 序列化操作</span><br><span class="line">apply plugin: &#x27;kotlin-parcelize&#x27;</span><br><span class="line"></span><br><span class="line">   android &#123;     </span><br><span class="line">        // 指定 aidl 文件的放置路径</span><br><span class="line">        sourceSets&#123;</span><br><span class="line">            main &#123;</span><br><span class="line">                java.srcDirs = [&#x27;src/main/java&#x27;, &#x27;src/main/aidl&#x27;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 AndroidManifest.xml 中添加如下权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--申请服务权限，才能连接服务--&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;com.kingsun.custom.permission.ACCESS_APP_SERVICE&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-AIDL-文件处理"><a href="#3-AIDL-文件处理" class="headerlink" title="3.AIDL 文件处理"></a>3.AIDL 文件处理</h5><p>把 Demo 中的 aidl 文件夹拷贝到项目中，跟 java 项目平级，AIDL 文件和对应的实体为双方约定的服务接口及数据体。</p>
<p>注：如果服务端 APK 有相关的 AIDL 更新，客户端要同步更新，不要更改 aidl 目录下的任何文件以及包名等，避免服务不一致导致异常。</p>
<h5 id="4-使用Scheme协议完成app跳转"><a href="#4-使用Scheme协议完成app跳转" class="headerlink" title="4.使用Scheme协议完成app跳转"></a>4.使用Scheme协议完成app跳转</h5><p>代码示例（详见Demo）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val params = JsonObject()</span><br><span class="line">params.addProperty(&quot;Device&quot;,deviceId) </span><br><span class="line">params.addProperty(&quot;BookId&quot;,bookId)   </span><br><span class="line">params.addProperty(&quot;ResourcePath&quot;,resourcePath)</span><br><span class="line">params.addProperty(&quot;Version&quot;,resourceVersion)</span><br><span class="line"></span><br><span class="line">val intent = Intent()</span><br><span class="line">intent.data = Uri.parse(&quot;kingsun://com.elephant.synstudy?&quot;+ URLEncoder.encode(params.toString(),&quot;UTF-8&quot;))</span><br><span class="line">intent.action = &quot;android.intent.action.VIEW&quot;</span><br><span class="line">intent.addCategory(&quot;android.intent.category.DEFAULT&quot;)</span><br><span class="line">intent.addCategory(&quot;android.intent.category.BROWSABLE&quot;)</span><br><span class="line">intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">   startActivity(intent)</span><br><span class="line">&#125;catch (e:Exception)&#123;</span><br><span class="line">   e.printStackTrace()               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>params参数字段说明：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th align="center">类型</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Device</td>
<td align="center">String</td>
<td>设备鉴权信息</td>
<td>必传（GetThirdPartyBookResource接口返回字段）</td>
</tr>
<tr>
<td>BookId</td>
<td align="center">Int</td>
<td>书本id</td>
<td>必传（使用方直科技的书本id）</td>
</tr>
<tr>
<td>CatalogueId</td>
<td align="center">Int</td>
<td>目录id</td>
<td>可选</td>
</tr>
<tr>
<td>ResourcePath</td>
<td align="center">String</td>
<td>资源包下载到本地完整路径</td>
<td>必传</td>
</tr>
<tr>
<td>Version</td>
<td align="center">String</td>
<td>资源包版本</td>
<td>必传（GetThirdPartyBookResource接口返回字段，用于处理资源版本更新）</td>
</tr>
</tbody></table>
<h5 id="5-连接远程服务"><a href="#5-连接远程服务" class="headerlink" title="5.连接远程服务"></a>5.连接远程服务</h5><p>步骤1.  一定要先通过 bindService 绑定服务，因为不能确保打开APP的时候服务完全启动，建议循环进行绑定直到绑定成功，具体操作看 demo。</p>
<p>步骤2.  再注册监听事件，在绑定服务成功后，建议立刻注册监听事件，这样能让服务器的接口回调尽快返回。</p>
<p>步骤3.  等待 APP 服务端回调 【进入课本成功回调】，在前提下，再主动调用各种接口功能，回调的接口功能在监听事件中进行回调。</p>
<p>步骤4.  解绑服务，重置标志字段。</p>
<p>注意：</p>
<ol>
<li><p>一定要等待 APP 服务端回调 【进入课本成功回调】再调用 AIDL 接口方法 ，确保服务端完全启动并保证APP数据初始化完成 （除了监听事件的交互方法在绑定服务成功后立刻调用）</p>
</li>
<li><p>在主动关闭应用或APP 内部关闭应用回调时，主动进行解绑服务操作，重置标志，避免后续 AIDL 交互出现异常</p>
</li>
</ol>
<h5 id="6-数据交互"><a href="#6-数据交互" class="headerlink" title="6.数据交互"></a>6.数据交互</h5><ol>
<li><p>目前所有交互数据都在 BookUseInfo 实体中，所有的回调方法都会返回该对象，具体的值根据各个接口回调进行填充，在对应的回调方法中获取对应的值即可。</p>
</li>
<li><p>IAppManager 接口表示客户端主动调用的所有功能方法，IOnAppListener 接口表示服务端操作会进行的回调功能。</p>
</li>
</ol>
<p>注：Demo工程内包含完整的调用API下载资源、scheme协议跳转流程、AIDL 接口功能交互，运行Demo可看具体效果。</p>
]]></content>
      <tags>
        <tag>jetpack android</tag>
      </tags>
  </entry>
  <entry>
    <title>livedata</title>
    <url>/2022/06/06/livedata/</url>
    <content><![CDATA[<p>LiveData (可观察的数据存储器类)，使用篇…</p>
<span id="more"></span>

<h2 id="LiveData-可观察的数据存储器类-，使用篇"><a href="#LiveData-可观察的数据存储器类-，使用篇" class="headerlink" title="LiveData (可观察的数据存储器类)，使用篇"></a><strong>LiveData (可观察的数据存储器类)，使用篇</strong></h2><!-- 本地图片引用 -->
<!-- <img src="/2022/06/06/livedata/juanjuan01.jpg" class=""> -->

<p><img src="/2022/06/06/livedata/juanjuan01.jpg"></p>
<h4 id="作用：不是普通的观察类，具有生命周期感知能力，能够在-Activity、Fragment、Service-中正确的处理生命周期。"><a href="#作用：不是普通的观察类，具有生命周期感知能力，能够在-Activity、Fragment、Service-中正确的处理生命周期。" class="headerlink" title="作用：不是普通的观察类，具有生命周期感知能力，能够在 Activity、Fragment、Service 中正确的处理生命周期。"></a>作用：不是普通的观察类，具有生命周期感知能力，能够在 <code>Activity、Fragment、Service</code> 中正确的处理生命周期。</h4><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><h5 id="1-LiveData-是一个数据持有者，是数据源的包装类。"><a href="#1-LiveData-是一个数据持有者，是数据源的包装类。" class="headerlink" title="1. LiveData 是一个数据持有者，是数据源的包装类。"></a>1. <code>LiveData</code> 是一个数据持有者，是数据源的包装类。</h5><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="2-源数据使用-LiveData-进行包装之后，可以被观察，当数据有更新时，观察者可感知。"><a href="#2-源数据使用-LiveData-进行包装之后，可以被观察，当数据有更新时，观察者可感知。" class="headerlink" title="2. 源数据使用 LiveData 进行包装之后，可以被观察，当数据有更新时，观察者可感知。"></a>2. 源数据使用 <code>LiveData</code> 进行包装之后，可以被观察，当数据有更新时，观察者可感知。</h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h5 id="3-观察者感知或被通知到的时机是跟生命周期相关的，只发生在-Activity-Fragment-活跃生命周期状态，如果一个观察者处于-Paused-或-Destroyed-状态，它将不会收到通知。"><a href="#3-观察者感知或被通知到的时机是跟生命周期相关的，只发生在-Activity-Fragment-活跃生命周期状态，如果一个观察者处于-Paused-或-Destroyed-状态，它将不会收到通知。" class="headerlink" title="3. 观察者感知或被通知到的时机是跟生命周期相关的，只发生在 Activity/Fragment 活跃生命周期状态，如果一个观察者处于 Paused 或 Destroyed 状态，它将不会收到通知。"></a>3. 观察者感知或被通知到的时机是跟生命周期相关的，只发生在 <code>Activity/Fragment</code> 活跃生命周期状态，如果一个观察者处于 <code>Paused</code> 或 <code>Destroyed</code> 状态，它将不会收到通知。</h5><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><h5 id="1-不会发生内存泄漏且无须手动解除观察，LiveData-会在相应生命周期自动移除。"><a href="#1-不会发生内存泄漏且无须手动解除观察，LiveData-会在相应生命周期自动移除。" class="headerlink" title="1. 不会发生内存泄漏且无须手动解除观察，LiveData 会在相应生命周期自动移除。"></a>1. 不会发生内存泄漏且无须手动解除观察，<code>LiveData</code> 会在相应生命周期自动移除。</h5><h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5><h5 id="2-不会因-Activity-停止而导致崩溃，当生命周期处于非活跃状态，不会接收任何-LiveData-事件。"><a href="#2-不会因-Activity-停止而导致崩溃，当生命周期处于非活跃状态，不会接收任何-LiveData-事件。" class="headerlink" title="2. 不会因 Activity 停止而导致崩溃，当生命周期处于非活跃状态，不会接收任何 LiveData 事件。"></a>2. 不会因 <code>Activity</code> 停止而导致崩溃，当生命周期处于非活跃状态，不会接收任何 <code>LiveData</code> 事件。</h5><h5 id="-3"><a href="#-3" class="headerlink" title=""></a></h5><h5 id="3-数据始终保持最新状态且避免重复刷新界面，数据更新时若-Activity-为非活跃状态，那么会在变为活跃时接收最新数据。例如，在后台的-Activity-会在返回前台时立即接收最新的数据，而不是在每次数据变化时刷新界面。"><a href="#3-数据始终保持最新状态且避免重复刷新界面，数据更新时若-Activity-为非活跃状态，那么会在变为活跃时接收最新数据。例如，在后台的-Activity-会在返回前台时立即接收最新的数据，而不是在每次数据变化时刷新界面。" class="headerlink" title="3. 数据始终保持最新状态且避免重复刷新界面，数据更新时若 Activity 为非活跃状态，那么会在变为活跃时接收最新数据。例如，在后台的 Activity 会在返回前台时立即接收最新的数据，而不是在每次数据变化时刷新界面。"></a>3. 数据始终保持最新状态且避免重复刷新界面，数据更新时若 <code>Activity</code> 为非活跃状态，那么会在变为活跃时接收最新数据。例如，在后台的 <code>Activity</code> 会在返回前台时立即接收最新的数据，而不是在每次数据变化时刷新界面。</h5><h3 id="LiveData-的基础使用"><a href="#LiveData-的基础使用" class="headerlink" title="LiveData 的基础使用"></a>LiveData 的基础使用</h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><h5 id="1-创建-LiveData-实例，通过泛型指定源数据类型。"><a href="#1-创建-LiveData-实例，通过泛型指定源数据类型。" class="headerlink" title="1. 创建 LiveData 实例，通过泛型指定源数据类型。"></a>1. 创建 <code>LiveData</code> 实例，通过泛型指定源数据类型。</h5><h5 id="-4"><a href="#-4" class="headerlink" title=""></a></h5><h5 id="2-创建-Observer-实例，实现-onChanged-方法，用于接收源数据变化并刷新-UI。"><a href="#2-创建-Observer-实例，实现-onChanged-方法，用于接收源数据变化并刷新-UI。" class="headerlink" title="2. 创建 Observer 实例，实现 onChanged() 方法，用于接收源数据变化并刷新 UI。"></a>2. 创建 <code>Observer</code> 实例，实现 <code>onChanged()</code> 方法，用于接收源数据变化并刷新 UI。</h5><h5 id="-5"><a href="#-5" class="headerlink" title=""></a></h5><h5 id="3-LiveData-实例使用-observe-方法添加观察者，并传入-LifecycleOwner，就是-Activity-本身。"><a href="#3-LiveData-实例使用-observe-方法添加观察者，并传入-LifecycleOwner，就是-Activity-本身。" class="headerlink" title="3. LiveData 实例使用 observe() 方法添加观察者，并传入 LifecycleOwner，就是 Activity 本身。"></a>3. <code>LiveData</code> 实例使用 <code>observe()</code> 方法添加观察者，并传入 <code>LifecycleOwner</code>，就是 <code>Activity</code> 本身。</h5><h5 id="-6"><a href="#-6" class="headerlink" title=""></a></h5><h5 id="4-LiveData-实例使用-setValue-postValue-更新源数据-（工作线程要使用-postValue-）"><a href="#4-LiveData-实例使用-setValue-postValue-更新源数据-（工作线程要使用-postValue-）" class="headerlink" title="4. LiveData 实例使用 setValue()/postValue() 更新源数据 （工作线程要使用 postValue()）"></a>4. <code>LiveData</code> 实例使用 <code>setValue()/postValue()</code> 更新源数据 （工作线程要使用 <code>postValue()</code>）</h5><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LiveDataTestActivity extends AppCompatActivity&#123;</span><br><span class="line"></span><br><span class="line">   private MutableLiveData&lt;String&gt; mLiveData;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">       super.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_lifecycle_test);</span><br><span class="line"></span><br><span class="line">       //liveData基本使用</span><br><span class="line">       mLiveData = new MutableLiveData&lt;&gt;();</span><br><span class="line">       mLiveData.observe(this, new Observer&lt;String&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onChanged(String s) &#123;</span><br><span class="line">               Log.i(TAG, &quot;onChanged: &quot;+s);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       Log.i(TAG, &quot;onCreate: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onCreate&quot;);//activity是非活跃状态，不会回调onChanged。变为活跃时，value被onStart中的value覆盖</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   protected void onStart() &#123;</span><br><span class="line">       super.onStart();</span><br><span class="line">       Log.i(TAG, &quot;onStart: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onStart&quot;);//活跃状态，会回调onChanged。并且value会覆盖onCreate、onStop中设置的value</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   protected void onResume() &#123;</span><br><span class="line">       super.onResume();</span><br><span class="line">       Log.i(TAG, &quot;onResume: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onResume&quot;);//活跃状态，回调onChanged</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   protected void onPause() &#123;</span><br><span class="line">       super.onPause();</span><br><span class="line">       Log.i(TAG, &quot;onPause: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onPause&quot;);//活跃状态，回调onChanged</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   protected void onStop() &#123;</span><br><span class="line">       super.onStop();</span><br><span class="line">       Log.i(TAG, &quot;onStop: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onStop&quot;);//非活跃状态，不会回调onChanged。后面变为活跃时，value被onStart中的value覆盖</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   protected void onDestroy() &#123;</span><br><span class="line">       super.onDestroy();</span><br><span class="line">       Log.i(TAG, &quot;onDestroy: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onDestroy&quot;);//非活跃状态，且此时Observer已被移除，不会回调onChanged</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="注意：除了使用-observe-方法添加观察者，也可以使用-observeForever-Observer-方法来注册未关联-LifecycleOwner-的观察者。在这种情况下，观察者会被视为始终处于活跃状态。"><a href="#注意：除了使用-observe-方法添加观察者，也可以使用-observeForever-Observer-方法来注册未关联-LifecycleOwner-的观察者。在这种情况下，观察者会被视为始终处于活跃状态。" class="headerlink" title="注意：除了使用 observe() 方法添加观察者，也可以使用 observeForever(Observer) 方法来注册未关联 LifecycleOwner 的观察者。在这种情况下，观察者会被视为始终处于活跃状态。"></a>注意：除了使用 <code>observe()</code> 方法添加观察者，也可以使用 <code>observeForever(Observer)</code> 方法来注册未关联 <code>LifecycleOwner</code> 的观察者。在这种情况下，观察者会被视为始终处于活跃状态。</h5><h3 id="LiveData-的进阶使用"><a href="#LiveData-的进阶使用" class="headerlink" title="LiveData 的进阶使用"></a>LiveData 的进阶使用</h3><h4 id="1-Transformations-map-，如果想要在-LiveData-对象分发给观察者之前对其中存储的值进行更改，可以使用该方法。"><a href="#1-Transformations-map-，如果想要在-LiveData-对象分发给观察者之前对其中存储的值进行更改，可以使用该方法。" class="headerlink" title="1. Transformations.map()，如果想要在 LiveData 对象分发给观察者之前对其中存储的值进行更改，可以使用该方法。"></a>1. <code>Transformations.map()</code>，如果想要在 <code>LiveData</code> 对象分发给观察者之前对其中存储的值进行更改，可以使用该方法。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  //Integer类型的liveData</span><br><span class="line">  MutableLiveData&lt;Integer&gt; liveData = new MutableLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  //转换成String类型的transformedLiveData</span><br><span class="line">  LiveData&lt;String&gt; transformedLiveData  = Transformations.map(liveData1, new Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public String apply(Integer input) &#123;</span><br><span class="line">          String s = input + &quot; + Transformations.map&quot;;</span><br><span class="line">          Log.i(TAG, &quot;apply: &quot; + s);</span><br><span class="line">          return s;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">transformedLiveData .observe(this, new Observer&lt;String&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onChanged(String s) &#123;</span><br><span class="line">          Log.i(TAG, &quot;onChanged1: &quot;+s);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  liveData.setValue(100);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-Transformations-switchMap-，如果想要手动控制监听其中一个的数据变化，并能根据需要随时切换监听，这时可以使用-Transformations-switchMap-，它和-Transformations-map-使用方式类似，只不过switchMap-必须返回一个-LiveData-对象。如果要返回-必须返回一个LiveData-对象-就用-switchMap-，不需要就用-map-，效果差不多。"><a href="#2-Transformations-switchMap-，如果想要手动控制监听其中一个的数据变化，并能根据需要随时切换监听，这时可以使用-Transformations-switchMap-，它和-Transformations-map-使用方式类似，只不过switchMap-必须返回一个-LiveData-对象。如果要返回-必须返回一个LiveData-对象-就用-switchMap-，不需要就用-map-，效果差不多。" class="headerlink" title="2. Transformations.switchMap() ，如果想要手动控制监听其中一个的数据变化，并能根据需要随时切换监听，这时可以使用 Transformations.switchMap() ，它和 Transformations.map() 使用方式类似，只不过switchMap() 必须返回一个 LiveData 对象。如果要返回 必须返回一个LiveData 对象 就用 switchMap ，不需要就用 map ，效果差不多。"></a>2. <code>Transformations.switchMap()</code> ，如果想要手动控制监听其中一个的数据变化，并能根据需要随时切换监听，这时可以使用 <code>Transformations.switchMap()</code> ，它和 <code>Transformations.map()</code> 使用方式类似，只不过<code>switchMap()</code> 必须返回一个 <code>LiveData</code> 对象。如果要返回 <code>必须返回一个LiveData</code> 对象 就用 <code>switchMap</code> ，不需要就用 <code>map</code> ，效果差不多。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    private static final String TAG = &quot;MainActivity&quot;;</span><br><span class="line">    MutableLiveData&lt;String&gt; mutableLiveData1;</span><br><span class="line">    MutableLiveData&lt;String&gt; mutableLiveData2;</span><br><span class="line">    MutableLiveData&lt;Boolean&gt; liveDataSwitch;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mutableLiveData1 = new MutableLiveData&lt;&gt;();</span><br><span class="line">        mutableLiveData2 = new MutableLiveData&lt;&gt;();</span><br><span class="line">        liveDataSwitch = new MutableLiveData&lt;Boolean&gt;();//1</span><br><span class="line"></span><br><span class="line">        LiveData transformedLiveData= Transformations.switchMap(liveDataSwitch, new Function&lt;Boolean, LiveData&lt;String&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public LiveData&lt;String&gt; apply(Boolean input) &#123;</span><br><span class="line">                if (input) &#123;</span><br><span class="line">                    return mutableLiveData1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return mutableLiveData2;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        transformedLiveData.observe(this, new Observer&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onChanged(@Nullable final String s) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onChanged:&quot; + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        liveDataSwitch.postValue(false);//2</span><br><span class="line">        mutableLiveData1.postValue(&quot;kotlin&quot;);</span><br><span class="line">        mutableLiveData2.postValue(&quot;java&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="通过-liveDataSwitch-对象控制是监听-mutableLiveData1-的数据还是-mutableLiveData2-的数据。"><a href="#通过-liveDataSwitch-对象控制是监听-mutableLiveData1-的数据还是-mutableLiveData2-的数据。" class="headerlink" title="通过 liveDataSwitch 对象控制是监听 mutableLiveData1 的数据还是 mutableLiveData2 的数据。"></a>通过 <code>liveDataSwitch</code> 对象控制是监听 <code>mutableLiveData1</code> 的数据还是 <code>mutableLiveData2</code> 的数据。</h5><h4 id="3-合并多个-LiveData-数据源，MediatorLiveData-继承自-mutableLiveData-，它可以将多个-LiveData-数据源集合起来，可以达到一个组件监听多个-LiveData-数据变化的目的。"><a href="#3-合并多个-LiveData-数据源，MediatorLiveData-继承自-mutableLiveData-，它可以将多个-LiveData-数据源集合起来，可以达到一个组件监听多个-LiveData-数据变化的目的。" class="headerlink" title="3. 合并多个 LiveData 数据源，MediatorLiveData 继承自 mutableLiveData ，它可以将多个 LiveData 数据源集合起来，可以达到一个组件监听多个 LiveData 数据变化的目的。"></a>3. 合并多个 <code>LiveData</code> 数据源，<code>MediatorLiveData</code> 继承自 <code>mutableLiveData</code> ，它可以将多个 <code>LiveData</code> 数据源集合起来，可以达到一个组件监听多个 <code>LiveData</code> 数据变化的目的。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val mutableLiveData1 = MutableLiveData&lt;String&gt;()</span><br><span class="line">val mutableLiveData2 = MutableLiveData&lt;String&gt;()</span><br><span class="line">val liveDataMerger = MediatorLiveData&lt;String&gt;()</span><br><span class="line">liveDataMerger.addSource(mutableLiveData1, object : Observer&lt;String&gt; &#123;</span><br><span class="line">    override fun onChanged( o: String) &#123;</span><br><span class="line">        LogUtils.d(TAG, &quot;onChanged1:$o&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">liveDataMerger.addSource(mutableLiveData2, object : Observer&lt;String&gt; &#123;</span><br><span class="line">    override fun onChanged( o: String) &#123;</span><br><span class="line">        LogUtils.d(TAG, &quot;onChanged2:$o&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">liveDataMerger.observe(this, object : Observer&lt;String&gt; &#123;</span><br><span class="line">    override fun onChanged( o: String) &#123;</span><br><span class="line">        // 这里的触发场景，通常是监听的 Livedata源达到某个条件，再更新 liveDataMerger 的值进行回调的</span><br><span class="line">        LogUtils.d(TAG, &quot;onChanged3:$o&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">mutableLiveData1.postValue(&quot;mutableLiveData1文本&quot;)</span><br><span class="line">mutableLiveData2.postValue(&quot;mutableLiveData2文本&quot;)</span><br></pre></td></tr></table></figure>

<h5 id="其他使用场景：比如有一个列表界面，每一个-item-都可以点赞，每个-item-的赞都是一个数据源，我们可以监听点赞的数量，在达到某个条件处理逻辑。"><a href="#其他使用场景：比如有一个列表界面，每一个-item-都可以点赞，每个-item-的赞都是一个数据源，我们可以监听点赞的数量，在达到某个条件处理逻辑。" class="headerlink" title="其他使用场景：比如有一个列表界面，每一个 item 都可以点赞，每个 item 的赞都是一个数据源，我们可以监听点赞的数量，在达到某个条件处理逻辑。"></a>其他使用场景：比如有一个列表界面，每一个 <code>item</code> 都可以点赞，每个 item 的赞都是一个数据源，我们可以监听点赞的数量，在达到某个条件处理逻辑。</h5><h4 id="4-使用全局-Livedata-在多个视图监听状态"><a href="#4-使用全局-Livedata-在多个视图监听状态" class="headerlink" title="4. 使用全局 Livedata 在多个视图监听状态"></a>4. 使用全局 <code>Livedata</code> 在多个视图监听状态</h4><h4 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h4><h5 id="1-自定义-LiveData，重写-onActive-、onInactive-方法。"><a href="#1-自定义-LiveData，重写-onActive-、onInactive-方法。" class="headerlink" title="1. 自定义 LiveData，重写 onActive()、onInactive() 方法。"></a>1. 自定义 <code>LiveData</code>，重写 <code>onActive()、onInactive()</code> 方法。</h5><h5 id="2-实现为单例模式，实现多个-Activity、Fragment-之间共享数据。"><a href="#2-实现为单例模式，实现多个-Activity、Fragment-之间共享数据。" class="headerlink" title="2. 实现为单例模式，实现多个 Activity、Fragment 之间共享数据。"></a>2. 实现为单例模式，实现多个 <code>Activity、Fragment</code> 之间共享数据。</h5><h5 id="官方示例如下："><a href="#官方示例如下：" class="headerlink" title="官方示例如下："></a>官方示例如下：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class StockLiveData extends LiveData&lt;BigDecimal&gt; &#123;</span><br><span class="line">        private static StockLiveData sInstance; //单实例</span><br><span class="line">        private StockManager stockManager;</span><br><span class="line"></span><br><span class="line">        private SimplePriceListener listener = new SimplePriceListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onPriceChanged(BigDecimal price) &#123;</span><br><span class="line">                setValue(price);//监听到股价变化 使用setValue(price) 告知所有活跃观察者</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">	//获取单例</span><br><span class="line">        @MainThread</span><br><span class="line">        public static StockLiveData get(String symbol) &#123;</span><br><span class="line">            if (sInstance == null) &#123;</span><br><span class="line">                sInstance = new StockLiveData(symbol);</span><br><span class="line">            &#125;</span><br><span class="line">            return sInstance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private StockLiveData(String symbol) &#123;</span><br><span class="line">            stockManager = new StockManager(symbol);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     	//活跃的观察者（LifecycleOwner）数量从 0 变为 1 时调用</span><br><span class="line">        @Override</span><br><span class="line">        protected void onActive() &#123;</span><br><span class="line">            stockManager.requestPriceUpdates(listener);//开始观察股价更新</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     	//活跃的观察者（LifecycleOwner）数量从 1 变为 0 时调用。这不代表没有观察者了，可能是全都不活跃了。可以使用hasObservers()检查是否有观察者。</span><br><span class="line">        @Override</span><br><span class="line">        protected void onInactive() &#123;</span><br><span class="line">            stockManager.removeUpdates(listener);//移除股价更新的观察</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyFragment extends Fragment &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onViewCreated(view, savedInstanceState);</span><br><span class="line">        //获取StockLiveData单实例，添加观察者，更新UI</span><br><span class="line">        StockLiveData.get(symbol).observe(getViewLifecycleOwner(), price -&gt; &#123;</span><br><span class="line">            // Update the UI.</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="其他示例，比如有一个登录验证码倒计时界面，在倒计时，需要在其他的页面也要同步这个倒计时状态，可以这样写："><a href="#其他示例，比如有一个登录验证码倒计时界面，在倒计时，需要在其他的页面也要同步这个倒计时状态，可以这样写：" class="headerlink" title="其他示例，比如有一个登录验证码倒计时界面，在倒计时，需要在其他的页面也要同步这个倒计时状态，可以这样写："></a>其他示例，比如有一个登录验证码倒计时界面，在倒计时，需要在其他的页面也要同步这个倒计时状态，可以这样写：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class GlobalLivedata : LiveData&lt;String&gt;() &#123;</span><br><span class="line">    val coundManager = CountDownManager()</span><br><span class="line">    val listener = object : OnDataChangeListener &#123;</span><br><span class="line">        override fun change(data: String) &#123;</span><br><span class="line">           postValue(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onActive() &#123;</span><br><span class="line">        super.onActive()</span><br><span class="line">        coundManager.setListener(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onInactive() &#123;</span><br><span class="line">        super.onInactive()</span><br><span class="line">        coundManager.removeListener(listener)</span><br><span class="line">    &#125;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        private lateinit var globalData: GlobalLivedata</span><br><span class="line">        fun getInstance(): GlobalLivedata &#123;</span><br><span class="line">            globalData = if (::globalData.isInitialized) globalData else GlobalLivedata()</span><br><span class="line">            return globalData</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>jetpack android</tag>
      </tags>
  </entry>
</search>
