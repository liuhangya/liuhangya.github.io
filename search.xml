<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git 标签</title>
      <link href="/2023/09/21/git/git_tag/"/>
      <url>/2023/09/21/git/git_tag/</url>
      
        <content type="html"><![CDATA[<p>Git 标签</p><span id="more"></span><p>标签即 <code>tag</code> ，是人为的对提交进行命名，可以更方便更直观地表达某个提交的意义。例如：用标签名称为 <code>V2.0.0</code> 来表示软件的发布版本对应的某个提交。</p><p>接下来，将对一个名为 <code>Hello World</code> 的示例版本库进行研究，详情的介绍 <code>tag</code> 的创建、删除和共享，这个版本库不需要从头建立，直接从 Github （<a href="https://github.com/ossxp-com/hello-world.git%EF%BC%89%E4%B8%8A%E5%85%8B%E9%9A%86%E3%80%82">https://github.com/ossxp-com/hello-world.git）上克隆。</a></p><ol><li>先在本地创建一个镜像，用作本地用户的共享版本库：</li></ol><p><img src="/2023/09/21/git/git_tag/tag1.png" alt="tag1.png"></p><p>现在，本地建立了一个裸版本库 <code>/git_study/repos/hello-world.git</code> 。</p><ol start="2"><li>分别在用户 <code>user3</code> 和 <code>user4</code> 各自的工作区中克隆这个裸版本库，操作方式跟之前一样：</li></ol><p><img src="/2023/09/21/git/git_tag/tag2.png" alt="tag2.png"></p><p>准备工作已经完成了，下面将详情介绍 <code>tag</code> 的相关用法。</p><p>**一、显示 tag **</p><ol><li>不带任何参数执行 <code>git tag</code> 命令，可查看当前版本库的 <code>tag</code> 列表：</li></ol><p><img src="/2023/09/21/git/git_tag/tag3.png" alt="tag3.png"></p><ol start="2"><li>创建 <code>tag</code> 的时候可以添加说明，要在显示 <code>tag</code> 的时候同时显示这个说明，要使用 <code>-n&#123;num&#125;</code> 参数 ，表示显示最多 <code>num</code> 行描述说明：</li></ol><p><img src="/2023/09/21/git/git_tag/tag4.png" alt="tag4.png"></p><p>上图输出显示了一行的 <code>tag</code> 说明 。</p><ol start="3"><li>还可以使用通配符对输出进行过滤，只显示匹配通配符规则的 <code>tag</code> ：</li></ol><p><img src="/2023/09/21/git/git_tag/tag5.png" alt="tag5.png"></p><p>上图输出表示只显示 <code>v1</code> 版本的 <code>tag</code> ，注意不是 <code>-1</code> 是 <code>-l</code> (是字母) 。</p><p><strong>二、命令 <code>git log</code> 查看日志时，加上 <code>--decorate</code> 参数可以看到提交对应的 <code>tag</code> 以及其他引用（<code>Git</code> 版本较高时，默认就会显示，不用加上该参数）：</strong></p><p><img src="/2023/09/21/git/git_tag/tag6.png" alt="tag6.png"></p><p><strong>三、 使用命令 <code>git describe</code></strong></p><p>该命令将显示一个易记的名称，如果当前提交恰好打上了 <code>tag</code> ，则显示这个 <code>tag</code> 名称，如果当前提交没有对应的 <code>tag</code> ，但是在其祖先提交上有创建 <code>tag</code> ，则使用 <code>&#123;tag&#125;-&#123;num&#125;-g&#123;commit&#125;</code> 的格式显示。 <code>&#123;tag&#125;</code> 表示距离当前提交最近的 <code>tag</code> 名称，<code>&#123;num&#125;</code> 是该 <code>tag</code> 的提交和当前提交之间的距离（即 <code>tag</code> 提交之后的第几次提交），<code>&#123;commit&#125;</code> 就是当前提交的精简提交 <code>ID</code> 。</p><p><img src="/2023/09/21/git/git_tag/tag7.png" alt="tag7.png"></p><p>上图显示当前提交是最近的 <code>tag（jx/v1.0）</code> 之后的第 2 次提交，提交 <code>ID</code> 为 <code>d901dd8</code> 。</p><p><strong>四、创建 <code>tag</code></strong> </p><p>使用 <code>git tag</code> 命令创建 <code>tag</code> ，有以下几种创建方式：</p><ul><li><p><code>git tag &#123;tagname&#125; &#123;commit&#125;</code> ：创建轻量级 <code>tag</code></p></li><li><p><code>git tag -m &#123;msg&#125; &#123;tagname&#125; &#123;commit&#125;</code>  ：创建带说明的 <code>tag</code></p></li></ul><p>其实还有带签名的 <code>tag</code> ，这里就不介绍了。创建 <code>tag</code> 时，需要输入 <code>tag</code> 名称和一个可选的提交 <code>ID</code> ，如果不提供，则基于 <code>HEAD</code> 创建 <code>tag</code> 。</p><ol><li>创建轻量级 <code>tag</code></li></ol><p>这种 <code>tag</code> 最简单，无须输入任何说明信息，来演示一下：</p><p>先创建一个空提交，接着在这个提交上创建轻量级 <code>tag</code> ，名称为 <code>mytag</code> ，再查看一下本地 <code>tag</code> 列表：</p><p><img src="/2023/09/21/git/git_tag/tag8.png" alt="tag8.png"></p><p><strong>实现方式： 当创建了 <code>mytag</code> 后，会在版本库的 <code>.git/refs/tags</code> 目录下创建一个新文件，这个文件保存的是一个提交 <code>ID</code> ，该提交 <code>ID</code> 对应的内容就是打上标签的那个提交的内容，所以可以用 <code>tag</code> 名称替代指定的提交 <code>ID</code> 。</strong></p><p><img src="/2023/09/21/git/git_tag/tag9.png" alt="tag9.png"></p><p><img src="/2023/09/21/git/git_tag/tag10.png" alt="tag10.png"></p><p><strong>轻量级 <code>tag</code> 的缺点：创建过程没有记录，因此无法知道是谁创建的 <code>tag</code> ，以及何时创建的 <code>tag</code> 。强烈建议创建带说明的 <code>tag</code> ，不要以用这种偷懒的方式来创建 <code>tag</code> 。另外，<code>git describe</code> 命令默认不使用轻量级 <code>tag</code> 来生成版本描述字符串，除非加上 <code>--tags</code> 参数。</strong></p><p><img src="/2023/09/21/git/git_tag/tag11.png" alt="tag11.png"></p><p>上图可知，如果不加上 <code>--tags</code> 参数，默认还是以之前 <code>jx/v1.0</code> 这个标签为基准。</p><ol start="2"><li>创建带说明的 <code>tag</code></li></ol><p>还是先创建一个空提交，然后通过 <code>-m</code> 参数来创建带说明的 <code>tag</code> ，再查看一下本地 <code>tag</code> 列表：</p><p><img src="/2023/09/21/git/git_tag/tag12.png" alt="tag12.png"></p><p><img src="/2023/09/21/git/git_tag/tag13.png" alt="tag13.png"></p><p><strong>实现方式： 当创建了 <code>mytag2</code> 后，会在版本库的 <code>.git/refs/tags</code> 目录下创建一个新文件，这个文件保存的是一个<em>对象哈希值</em> ，该哈希值指向的不再是一个提交，而是一个 <code>tag</code> 对象，该对象内容也不是我们熟系的提交对象的内容，而是包含了创建 <code>tag</code> 时的说明，以及对应的提交 <code>ID</code> 等信息，通过其记录的提交 <code>ID</code> 才能查到具体的提交信息。</strong></p><p><img src="/2023/09/21/git/git_tag/tag14.png" alt="tag14.png"></p><p><img src="/2023/09/21/git/git_tag/tag15.png" alt="tag15.png"></p><p>至此，<code>Git</code> 对象库的四类对象都涉及到了，分别是 <code>commit</code> 对象、<code>tree</code> 对象、<code>blob</code> 对象和 <code>tag</code> 对象。</p><p>虽然 <code>mytag2</code> 本身是一个 <code>tag</code> 对象，但在很多 <code>git</code> 命令中，可以直接将其看作一个提交，就跟轻量级 <code>tag</code> 一样，当作提交 <code>ID</code> 来使用。</p><p><strong>注意：通过 <code>git rev-parse mytag2</code> 这种方式得到的 <code>ID</code> 是 <code>tag</code> <em>对象ID</em> ，并不是提交对象的 <code>ID</code> ，需要根据对象 <code>ID</code> 来查看具体提交的 <code>ID</code> 。</strong></p><p><img src="/2023/09/21/git/git_tag/tag16.png" alt="tag16.png"></p><p>上图所示，第一种方式获取的是对象 <code>ID</code> ,下面四种方式都可以获得 <code>mytag2</code> 对象所指向的提交对象的 <code>ID</code> 。</p><p><strong>五、删除 <code>tag</code></strong> </p><p>如果 <code>tag</code> 创建在错误的提交上，或者对 <code>tag</code> 的命名不满意，可以使用 <code>git tag -d &#123;tagname&#125;</code> 来删除指定的 <code>tag</code> ，下面将删除 <code>mytag</code> 本地标签 。</p><p><img src="/2023/09/21/git/git_tag/tag17.png" alt="tag17.png"></p><p><code>tag</code> 没有类似 <code>reflog</code> 的变更机制，删除之后不易恢复，要慎用。在删除 <code>tag</code> 的命令输出中，会显示该 <code>tag</code> 所对应的提交 <code>ID</code> ，发现删错了，赶紧补救还来得及。</p><p><code>Git</code> 并没有提供对 <code>tag</code> 进行重命名的命令，如果对 <code>tag</code> 命名不满意，可以删除旧的再重新用新的名称创建。</p><p>根据上图输出中的提交 <code>ID</code> ，将 <code>tag</code> 进行恢复：<code>git tag mytag 3205ed1</code> 。</p><p><strong>注意：不要随意更改 <code>tag</code> ，因为 <code>tag</code> 从概念上讲是对历史提交的一个标记，不应该随意变动。另一个原因是 <code>tag</code> 已经被人同步，如果修改了 <code>tag</code> ，已经同步该 <code>tag</code> 的用户并不会自动更新，这会导致一个相同名称的 <code>tag</code> 在不同用户的版本库中的指向不同。</strong></p><p><strong>六、共享 <code>tag</code> 到远程版本库</strong></p><ol><li>查看一下用户 <code>user3</code> 当前的状态，发现有两个新的提交（两个提交都打上了 <code>tag</code> ），再执行 <code>git push</code> 命令进行推送，最后通过 <code>git ls-remote origin my*</code> 查看远程以 <code>my</code> 开头的引用信息（<code>tag</code> 也算是引用的一种），发现本地创建的 <code>tag</code> 并没有一起推送到远程。需要在 <code>git push</code> 命令中显式将 <code>tag</code> 推送到远程：</li></ol><p><img src="/2023/09/21/git/git_tag/tag18.png" alt="tag18.png"></p><p><img src="/2023/09/21/git/git_tag/tag19.png" alt="tag19.png"></p><p>上图可知：可以推送指定单个 <code>tag</code> ( <code>git push origin mytag</code> ) 。也可以通过通配符来批量推送（ <code>git push origin refs/tags/*</code> ），通过 <code>git ls-remote origin my*</code> 命令可以看到远程版本库已经同步本地的 <code>tag</code> 了。</p><p>总结：创建的 <code>tag</code> 默认不会跟随分支的推送而推送，从而避免了不同用户本地创建的 <code>tag</code> 都自动推送导致的 <code>tag</code> 杂乱，而且不同用户相同的 <code>tag</code> 名称还会互相覆盖。</p><ol start="2"><li>其他用户如果执行 <code>git fetch</code> 或 <code>git pull</code> 操作，能自动将 <code>tag</code> 进行同步吗？演示一下：</li></ol><p>用户 <code>user4</code> 执行 <code>git pull</code> 之后，再查看一下本地的 <code>tag</code> 列表：</p><p><img src="/2023/09/21/git/git_tag/tag20.png" alt="tag20.png"></p><p><img src="/2023/09/21/git/git_tag/tag21.png" alt="tag21.png"></p><p>其实从 <code>git pull</code> 操作的输出中已经可以看到，在获取远程共享版本库的提交的同时，也获取到了新的 <code>tag</code>  。</p><ol start="3"><li><code>tag</code> 能够自动同步吗？来演示一下：</li></ol><ul><li><code>tag</code> 是可以被强制更新的，通过添加 <code>-f</code> 参数。用户 <code>user4</code> 强制更新 <code>mytag2</code> ，修改其描述说明和指向的提交 <code>ID</code> ：</li></ul><p><img src="/2023/09/21/git/git_tag/tag22.png" alt="tag22.png"></p><ul><li>再显式地对这个 <code>tag</code> 进行推送，要加上 <code>-f</code> 参数来强制推送才行：</li></ul><p><img src="/2023/09/21/git/git_tag/tag23.png" alt="tag23.png"></p><ul><li>切换到用户 <code>user3</code> ，执行 <code>git pull</code> 操作 ，发现没有获取到新的 <code>tag</code> (默认不会自动同步已经存在的 <code>tag</code> )，必须显式地执行拉回操作。要在 <code>git pull</code> 的参数中使用引用表达式(用冒号分隔的引用名称或通配符)。下图的命令表示用远程共享版本库的引用 <code>refs/tag/mytag2</code> 覆盖本地版本库的同名引用 (冒号左侧是本地，右侧是远程)。</li></ul><p><img src="/2023/09/21/git/git_tag/tag24.png" alt="tag24.png"></p><p><strong>总结：</strong></p><ol><li><p><code>tag</code> 要进行推送共享，必须进行显式推送。执行 <code>fetch</code> 或 <code>pull</code> 操作只能自动从远程版本库获取<strong>新</strong>的 <code>tag</code> ，并在本地版本库中创建。</p></li><li><p>只会将获取的远程分支所包含的 <code>tag</code> 同步到本地，而不会将远程版本库的其他分支中的 <code>tag</code> 获取到本地。</p></li><li><p>如果本地已有同名的 <code>tag</code> ，默认不会自动同步，即使两者的指向不同。</p></li><li><p><code>tag</code> 被推送共享之后，最好不要再去修改。</p></li></ol><p><strong>七、删除远程版本库的 <code>tag</code></strong></p><p>删除本地的 <code>tag</code> 非常简单，使用 <code>git tag -d &#123;tagname&#125;</code> 就行了，如何删除已经推送到远程版本库的 <code>tag</code> 呢？方法也很简单，直接在本地版本库执行命令如下命令就行：<code>git push &#123;remote-url&#125; : &#123;tagname&#125;</code></p><p>该命令的最后一个参数实际上是一个引用表达式，引用表达式一般的格式为：<code>&#123;ref&#125;:&#123;ref&#125;</code> 。该推送命令使用的引用表达式冒号前的引用被省略了，表示将一个空值推送到远程版本库对应的引用中，也就是删除远程版本库中相关的引用。该命令不仅可以用于删除 <code>tag</code> ，也可以用来删除远程版本库的分支（下一节再讲）。</p><p>将远程版本库中的标签 <code>mytag2</code> 进行删除：</p><p><img src="/2023/09/21/git/git_tag/tag25.png" alt="tag25.png"></p><p>可以看到，远程的 <code>mytag2</code> 的确被删除了，但是本地的 mytag2 还是在的，因为我们并没有执行 <code>git tag -d mytag2</code> 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>团队协作_冲突解决</title>
      <link href="/2023/09/20/git/local_teamwork2/"/>
      <url>/2023/09/20/git/local_teamwork2/</url>
      
        <content type="html"><![CDATA[<p>团队协作_冲突解决</p><span id="more"></span><p>在上一节，通过执行 <code>git pull</code> 成功合并后再推送来解决非快进式推送的问题。但在真实的项目环境中，不总是会一帆风顺的，只要有合并就可能出现冲突，这一节重点介绍冲突解决方式。</p><p>上节已经说过： <code>git pull = git fetch + git merge</code></p><ul><li><p><code>git fetch</code> ：可暂时理解为将远程的版本库的对象（提交、里程碑、分支等）复制到本地。在本地版本库有专门的远程仓库映射引用，如：<code>.git\refs\remotes\origin\master</code> 。</p></li><li><p><code>git merge</code> ：会被隐式地执行，将其他版本库的提交和本地版本库的提交进行合并。该命令还可以对本版本库的其他分支进行显示的合并操作。默认情况下，<strong>合并后的结果会自动提交</strong>，如果提供 <code>--no-commit</code> 选项，则合并后的结果会放入暂存区，用户可以对合并结果进行检查、更改，然后手动提交。</p></li></ul><p>合并操作并非总会成功，因为合并的不同提交可能同时修改了同一文件相同区域的内容，这会导致冲突。冲突会造成合并操作的中断，冲突的文件会被标识，用户可以对标识为冲突的文件进行冲突解决操作，然后更新暂存区，再提交，最终完成合并操作。</p><h3 id="场景一、成功自动合并"><a href="#场景一、成功自动合并" class="headerlink" title="场景一、成功自动合并"></a>场景一、成功自动合并</h3><p>大多数情况下，<code>Git</code> 都能非常智能地进行自动合并，下面演示一下成功自动合并的三种情况。</p><p><strong>情况一：修改不同的文件</strong></p><p>还是用上一节的例子进行演示，为了确保版本库状态的一致性，分别在 <code>user1</code> 和 <code>user2</code> 的本地版本库中执行下面的操作：</p><p><code>git fetch</code><br><code>git reset --hard origin/master</code></p><p>现在两个用户的本地版本都为远程版本库的最新版本，状态一致。都有 <code>team</code> 目录和 <code>user1.txt</code> 和 <code>user2.txt</code> 文件。</p><ol><li>用户 <code>user1</code> 修改 <code>user1.txt</code> 文件，提交并推送到远程。</li></ol><p><img src="/2023/09/20/git/local_teamwork2/local19.png" alt="local19.png"></p><ol start="2"><li>用户 <code>user2</code> 修改 <code>user2.txt</code> 文件，提交并推送（推送会失败，遇到非快进式推送的错误）。</li></ol><p><img src="/2023/09/20/git/local_teamwork2/local20.png" alt="local20.png"></p><ol start="3"><li>用户 <code>user2</code> 执行 <code>git fetch</code> 操作，获取提交并更新到本地用于跟踪远程版本库 <code>master</code> 分支的本地引用 <code>origin/master</code> 中。再执行 <code>git merge</code> 操作，成功自动合并，最后推送合并后的本地版本库到远程版本库。</li></ol><p><img src="/2023/09/20/git/local_teamwork2/local21.png" alt="local21.png"></p><ol start="4"><li>查看提交关系图。</li></ol><p><img src="/2023/09/20/git/local_teamwork2/local22.png" alt="local22.png"></p><p><strong>情况二：修改相同文件的不同区域</strong></p><p>当用户 <code>user1</code> 和 <code>user2</code> 在本地提交中修改相同的文件，但修改的是文件的不同位置时，仍可成功自动合并，具体操作如下：</p><ol><li><p>为了确保版本库状态的一致性，分别在 <code>user1</code> 和 <code>user2</code> 的本地版本库中执行 <code>git pull</code> 操作。</p></li><li><p>用户 <code>user1</code> 修改 <code>README</code> 文件，在第一行插入内容，更改后内容如下：</p><p> User1 hacked.<br> Hello.</p></li><li><p>用户 <code>user1</code> 本地提交并推送：</p></li></ol><p><img src="/2023/09/20/git/local_teamwork2/local23.png" alt="local23.png"></p><ol start="4"><li><p>用户 <code>user2</code> 也在自己的工作区中修改 <code>README</code> 文件，在文件的最后插入内容，更改后的文件内容如下：</p><p> Hello.<br> User2 hacked.</p></li><li><p>用户 <code>user2</code> 对修改进行本地提交，并执行 <code>git fetch</code> 操作：</p></li></ol><p><img src="/2023/09/20/git/local_teamwork2/local24.png" alt="local24.png"></p><ol start="6"><li>用户 <code>user2</code> 进行合并操作，完成自动合并并进行推送。这里合并的时候写的是 <code>refs/remotes/origin/master</code> ，其简写就是： <code>origin/master</code></li></ol><p><img src="/2023/09/20/git/local_teamwork2/local25.png" alt="local25.png"></p><ol start="7"><li>追溯一下 <code>README</code> 文件每一行的来源，可以看到 <code>user1</code> 和 <code>user2</code> 更改的位置：</li></ol><p><img src="/2023/09/20/git/local_teamwork2/local26.png" alt="local26.png"></p><p><strong>情况三：同时更改文件名和文件内容</strong></p><p>如果用户将文件移动到其他目录（或修改文件名），另外一个用户使用旧的文件进行了修改，<code>Git</code> 还是可以成功自动合并，具体操作如下：</p><ol><li><p>为了确保版本库状态的一致性，分别在 <code>user1</code> 和 <code>user2</code> 的本地版本库中执行 <code>git pull</code> 操作。</p></li><li><p>用户 <code>user1</code> 将 <code>README</code> 移动到 <code>doc</code> 目录下，进行本地提交并推送：</p></li></ol><p><img src="/2023/09/20/git/local_teamwork2/local27.png" alt="local27.png"></p><ol start="3"><li>用户 <code>user2</code> 在本地修改 <code>REAMD</code> 文件，在文件的最后插入内容，并本地提交。</li></ol><p><img src="/2023/09/20/git/local_teamwork2/local28.png" alt="local28.png"></p><ol><li>用户 <code>user2</code> 执行<code> git fetch</code> 操作，并执行 <code>git merge</code> 合并操作，最后进行推送。</li></ol><p><img src="/2023/09/20/git/local_teamwork2/local29.png" alt="local29.png"></p><ol start="5"><li>查看日志，并使用 <code>-m</code> 参数查看合并操作所做出的修改。</li></ol><p><img src="/2023/09/20/git/local_teamwork2/local30.png" alt="local30.png"></p><p>可以看到，上面的提交是 <code>user1</code> 的，进行了文件的移动。下面的提交是 <code>user2</code> 的，<code> doc/README | 2 +-</code> 表示这个文件从第二行开始，添加了一行并删除了一行 。原来的第三行内容是：<code>User2 hacked.</code> ，而现在的第三行内容是：<code>User2 hacked.User2 hacked again. </code>。Git&#96; 理解为删除了原来的行，新增了一行。</p><h3 id="场景二、自动合并失败，手动冲突解决"><a href="#场景二、自动合并失败，手动冲突解决" class="headerlink" title="场景二、自动合并失败，手动冲突解决"></a>场景二、自动合并失败，手动冲突解决</h3><p>如果不同用户修改了同一文件的同一区域，则在合并时会遇到冲突而中断，因为 <code>Git</code> 无法替用户做出决定（是要 <code>user1</code> 的提交内容还是 <code>user2</code> 的提交内容 ，还是两者提交的所有内容），会把决定权交给用户，用户再根据 <code>Git</code> 标识出的冲突位置来进行手动处理。</p><p>演示这个场景很简单，两个用户都修改 <code>doc/READE</code> 文件，都在第二行 <code>Hello</code>. 的后面加上自己的名字，具体操作过程如下：</p><ol><li><p>老规则，为了确保版本库状态的一致性，分别在 <code>user1</code> 和 <code>user2</code> 的本地版本库中执行 <code>git pull</code> 操作。</p></li><li><p>用户 <code>user1</code> 在第二行 <code>Hello.</code> 的后面加上自己的名字，内容如下：</p><p> User1 hacked.<br> Hello. user1.<br> User2 hacked.User2 hacked again.</p></li><li><p>用户 <code>user1</code> 进行本地提交并推送：</p><p>git add -u<br>git commit -m “say hello to user1.”<br>git push</p></li><li><p>用户 <code>user2</code> 在第二行<code> Hello.</code> 的后面加上自己的名字，内容如下：</p><p> User1 hacked.<br> Hello. user2.<br> User2 hacked.User2 hacked again.</p></li><li><p>用户 <code>user2</code> 对修改进行本地提交：</p><p> git add -u<br> git commit -m “say hello to user2.”</p></li><li><p>用户 <code>user2</code> 执行 <code>git pull</code> 操作（相当于<code>git fetch</code> 和 <code>git merge</code>）：</p></li></ol><p><img src="/2023/09/20/git/local_teamwork2/local31.png" alt="local31.png"></p><p>自动合并失败了，需要手动修复冲突然后再对结果进行提交。</p><ol start="7"><li>通过 <code>git status</code> 命令，可以从状态输出中看到文件 <code>doc/README.txt</code> 处于冲突状态，这个文件在两个不同的提交中都做了修改：</li></ol><p><img src="/2023/09/20/git/local_teamwork2/local32.png" alt="local32.png"></p><p>输出提示可以使用 <code>git merge --abort</code>  终止合并操作，或者手动修复冲突然后再对结果进行 <code>commit</code> 。</p><p>实际上，合并过程是通过 <code>.git</code> 目录下的几个文件进行记录的，当合并成功时，文件会自动被删除，现在合并失败，所以本地还存在这些文件：</p><ul><li><p><code>.git/MERGE_HEAD</code> ：记录所合并的提交 ID（就是合并成功后的新提交节点）。</p></li><li><p><code>.git/MERGE_MSG</code> ：记录合并失败的信息。</p></li><li><p><code>.git/MERGE_MODE</code>：标识合并状态。</p></li></ul><p><img src="/2023/09/20/git/local_teamwork2/local33.png" alt="local33.png"></p><p>而且暂存区中还会记录冲突文件的多个不同版本，可以使用 <code>git ls-files -s</code> 命令查看：</p><p><img src="/2023/09/20/git/local_teamwork2/local34.png" alt="local34.png"></p><p>输出中的每一行有四个字段，第一个是文件的属性，第二个是哈希值，第三个是暂存区编号，当合并冲突发生时，会用到 0 以上的暂存区编号。</p><ul><li><p>编号 1 的暂存区用于保存冲突文件修改之前的副本，也就是冲突双方共同的祖先版本。</p></li><li><p>编号 2 的暂存区用于保存当前冲突文件修改的副本。</p></li><li><p>编号 3 的暂存区用于保存合并分支的修改的副本。</p></li></ul><p>可通过 <code>:n:&#123;filename&#125;</code> 语法来访问对应副本的内容，也可以用我们之前学过的 <code>git cat-file -p &#123;commit&#125;</code> 来查看副本的内容：</p><p><img src="/2023/09/20/git/local_teamwork2/local35.png" alt="local35.png"></p><p>通过 <code>:n:&#123;filename&#125;</code> 的方式是这样的：<code>git show :1:doc/README</code> 。对暂存区中冲突文件的上述三个副本无须了解太多，这三个副本实际上是提供给冲突解决工具，用于实现三向文件合并的。</p><p>工作区的版本则可能同时包含了成功的合并及冲突的合并，其中冲突的合并会用特殊的标记（&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;&gt;&gt;&gt;&gt;）进行标识。当前冲突的文件内容如下：</p><p><img src="/2023/09/20/git/local_teamwork2/local36.png" alt="local36.png"></p><p>特殊标记 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> 和 <code>=======</code> 之间的内容是当前分支所更改的内容 。 <code>========</code> 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 之间的内容是所合并的分支修改的内容。</p><p><strong>冲突解决的本质：就是通过编辑操作，将冲突标识符所标识的冲突内容替换为合适的内容，并去掉冲突标识符。编辑完毕后执行 add add 命令将文件添加到暂存区（编号0），然后再提交，就完成了冲突解决。</strong></p><p>现在，工作区处于合并冲突状态，是无法再执行提交操作的。此时有两个选择：放弃合并操作或者解决冲突。放弃合并很简单，可以使用 <code>git merge --abort</code>  终止合并或执行 <code>git reset</code> 将暂存区重置即可。下面重点介绍如何进行冲突解决，也有两个方法：一个是对少量冲突非常适合的手工编辑操作，另一个是使用图形化冲突解决工具。</p><p><strong>冲突解决方式一：手工编辑完成冲突解决</strong></p><p>很简单，直接将 <code>README</code> 文件的标识符去掉，并修改为想要的提交内容，再进行提交。</p><p>修改后的文件内容如下：</p><pre><code>User1 hacked.Hello. user1. and user2.User2 hacked.User2 hacked again.</code></pre><p>添加到暂存区并提交：</p><p><code>git add -u </code><br><code>git commit -m &quot;Merge completed:say hello to all users.&quot;</code></p><p>查看最近三次的提交日志，会看到最新的提交就是一个合并提交。提交完成后，会看到 <code>.git</code> 目录下与合并相关的文件 <code>.git/MERGE_HEAD</code>、<code>.git/MERGE_MSG</code>、<code>.git/MERGE_MODE</code> 文件都自动删除了，而且暂存区中的三个副本也都清除了（实际在对编辑完的冲突文件执行 <code>git add</code> 后就已经被清除了）。</p><p><img src="/2023/09/20/git/local_teamwork2/local37.png" alt="local37.png"></p><p><strong>冲突解决方式二：图形工具完成冲突解决</strong></p><ol><li>由于已经手动完成了冲突解决，只能先回滚提交，再执行合并重新进入冲突状态。</li></ol><p><img src="/2023/09/20/git/local_teamwork2/local38.png" alt="local38.png"></p><ol start="2"><li><p>再次合并操作，进入冲突状态：<code>git merge origin/master</code></p></li><li><p>开始使用图形工具，根据不同的冲突解决软件来做具体操作，最终结果跟手动处理的一致。</p></li><li><p>最后进行 <code>git push</code> 操作。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>团队协作_快进式推送</title>
      <link href="/2023/09/18/git/local_teamwork/"/>
      <url>/2023/09/18/git/local_teamwork/</url>
      
        <content type="html"><![CDATA[<p>团队协作_快进式推送</p><span id="more"></span><p><code>Git</code> 作为版本控制系统，其主要功能就是团队协作，成员之间必然就存在着数据交换，而数据交换需要协议，<code>Git</code> 支持的协议包括：<code>SSH、GIT、HTTP、HTTPS</code> 等。</p><p>在本篇，我们将模拟一个公共版本库（想象为远程服务器），多个不同的用户工作环境（想象为在不同的主机上，由不同的用户进行操作）。</p><p>下面正式演示一个共享版本库的搭建以及两个用户 <code>user1</code> 和 <code>user2</code> 在各自的工作区是如何工作并进行数据交换的，具体过程如下：</p><ol><li><code>在 E:\git_study\repos/</code> 中创建一个共享的版本库 <code>shared.git</code>，以裸版本库方式创建：</li></ol><p><img src="/2023/09/18/git/local_teamwork/local1.png" alt="local1.png"></p><ol start="2"><li>用户 <code>user1</code> 克隆版本库到上一级目录的 <code>user1/workspace</code> 目录中 ：</li></ol><p><img src="/2023/09/18/git/local_teamwork/local2.png" alt="local2.png"></p><p>这里通过本地协议 <code>file://</code> 的方式来克隆，克隆一个刚初始化完成的裸版本库会显示警告，警告正在克隆的版本库是一个空的版本库。</p><p>注意：本地协议 <code>file://</code> 后面的路径为<strong>绝对路径</strong>，不能用相对路径，否则会报错。</p><ol start="3"><li>设置 <code>user.name</code> 和 <code>user.email</code> 配置变量</li></ol><p>配置的是版本库级别的，所以不要加上 <code>--global</code> 或 <code>--system</code> 参数，和全局设置区分开来，所有用户共用全局配置，就无法模拟了。</p><p><img src="/2023/09/18/git/local_teamwork/local3.png" alt="local3.png"></p><p><img src="/2023/09/18/git/local_teamwork/local4.png" alt="local4.png"></p><ol start="4"><li>用户 <code>user1</code> 创建初始数据并提交，这里新建了文件 <code>README</code> 并输入内容 <code>Hello.</code> 。</li></ol><p><img src="/2023/09/18/git/local_teamwork/local5.png" alt="local5.png"></p><p><img src="/2023/09/18/git/local_teamwork/local6.png" alt="local6.png"></p><ol start="5"><li>用户 <code>user1</code> 将本地版本库的提交推送到远程版本库：</li></ol><p><img src="/2023/09/18/git/local_teamwork/local7.png" alt="local7.png"></p><p>上述命令中使用了别名 <code>origin</code> ，其实际指向的就是 <code>file:///e/git_study/repos/shared.git</code> 这个远程版本库，可通过配置文件查看：</p><p><img src="/2023/09/18/git/local_teamwork/local4.png" alt="local4.png"></p><ol start="6"><li>用户 <code>user2</code> 也克隆远程版本库并设置 <code>name</code> 和 <code>email</code> ：</li></ol><p><img src="/2023/09/18/git/local_teamwork/local8.png" alt="local8.png"></p><p>可以看到，用户 <code>user2</code> 的本地版本库和用户 <code>user1</code> 有同样的提交。证明 <code>user1</code> 已成功推送到远程， <code>user2</code> 也成功从远程获取到数据。</p><h4 id="现在，两个用户的工作区是相同的，如果两人各自在本地版本库中进行独立的提交，然后再分别向远程版本库推送，会怎样？是互相覆盖还是提交失败呢？我们来模拟一下这个场景吧。"><a href="#现在，两个用户的工作区是相同的，如果两人各自在本地版本库中进行独立的提交，然后再分别向远程版本库推送，会怎样？是互相覆盖还是提交失败呢？我们来模拟一下这个场景吧。" class="headerlink" title="现在，两个用户的工作区是相同的，如果两人各自在本地版本库中进行独立的提交，然后再分别向远程版本库推送，会怎样？是互相覆盖还是提交失败呢？我们来模拟一下这个场景吧。"></a>现在，两个用户的工作区是相同的，如果两人各自在本地版本库中进行独立的提交，然后再分别向远程版本库推送，会怎样？是互相覆盖还是提交失败呢？我们来模拟一下这个场景吧。</h4><ol><li>用户 <code>user1</code> 先在本地提交，然后推送到远程版本库：</li></ol><p>创建对应目录和文件 <code>team/user1.txt</code> ，在 <code>user1.txt</code> 中输入文本，进行提交和推送，如下图：</p><p><img src="/2023/09/18/git/local_teamwork/local9.png" alt="local9.png"></p><p><img src="/2023/09/18/git/local_teamwork/local10.png" alt="local10.png"></p><p>可以看到，用户 <code>user1</code> 成功推送到远程版本库，也就是说远程版本库比用户 <code>user2</code> 领先一个提交，如果 <code>user2</code> 仍基于旧数据而对本地进行改动，然后向远程版本库推送，会有什么结果呢？</p><ol start="2"><li>用户 <code>user2</code> 创建对应目录和文件 <code>team/user2.txt</code> ，在 <code>user2.txt</code> 中输入文本，进行提交：</li></ol><p><img src="/2023/09/18/git/local_teamwork/local11.png" alt="local11.png"></p><ol start="3"><li>用户 <code>user2</code> 进行推送：</li></ol><p><img src="/2023/09/18/git/local_teamwork/local12.png" alt="local12.png"></p><p><strong>推送失败。一般情况下，推送只允许 “快进式” 推送，就是要推送的本地版本库的提交是建立在远程版本库相应分支的现有提交基础上的，即远程版本库相应分支的最新提交是本地版本库最新提交的祖先提交。</strong>由于用户 <code>user1</code> 推送了一个提交，所以用户 <code>user2</code> 的推送是非快进式的。</p><p><strong><code>Git</code> 是如何判断此次推送是否快进式的呢？</strong></p><p>判断方式类似以下操作：用 <code>git rev-list HEAD</code> 命令显示本地版本库的最新提交及其历史提交，然后用 <code>git ls-remote origin</code> 命令显示远程版本库的引用对应的哈希值，最后判断远程的哈希值是否本地版本库的祖先提交。</p><p><img src="/2023/09/18/git/local_teamwork/local13.png" alt="local13.png"></p><p>由图可知，<code>998627b</code> 并不是祖先提交，于是产生警告并终止了推送。</p><p>解决这个问题的方案有多个，可以强制推送，但是用户 <code>user1</code> 的推送会被覆盖，这种方式会形成竞争而不是协作，是不合适的，就不介绍这种解决方式了。</p><p>非快进式强制推送如果被滥用，就会成为项目的灾难，为了避免强制推送的问题，可以对版本库进行配置来禁止用户进行非快进式强制推送。将远程版本库的配置变量 <code>receive.denyNonFastForwards</code> 设置为 <code>true</code> 可以禁止任何用户进行非快进式推送操作：</p><p><img src="/2023/09/18/git/local_teamwork/local18.png" alt="local18.png"></p><p><strong>总结：合理的工作协同要避免非快进式推送，向服务器推送时发现错误，不应该使用更改历史的操作（变基、修补提交），而是采用不会改变历史提交的反转提交等操作。由于他人先推送了新的提交导致遇到非快进式推送警告时，应该先执行 <code>git pull</code> 获取服务器端最新的提交并和本地提交进行合并，合并成功后再向服务器进行提交推送。</strong></p><ol start="4"><li>执行 <code>git pull</code> ，该命令会包含两个动作：获取远程版本库的提交(<code>git fetch</code>) ，以及将获取到的远程版本库提交与本地提交进行合并(<code>git merge</code>)。</li></ol><p><img src="/2023/09/18/git/local_teamwork/local14.png" alt="local14.png"></p><ol start="5"><li>合并之后，看看版本库的提交关系图：</li></ol><p><img src="/2023/09/18/git/local_teamwork/local15.png" alt="local15.png"></p><p>远程服务器中的最新提交 <code>998627b</code> 成为了当前提交 <code>a943da7</code> 的父提交了，那么现在推送就是快进式的了，就不会有任何问题。</p><ol start="6"><li>执行 <code>git push</code> 命令进行推送：</li></ol><p><img src="/2023/09/18/git/local_teamwork/local16.png" alt="local16.png"></p><ol start="7"><li>查看一下远程版本库的提交历史：</li></ol><p><img src="/2023/09/18/git/local_teamwork/local17.png" alt="local17.png"></p><p>可以看到，增加了用户 <code>user2</code> 的提交并增加了一个合并的提交。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 克隆</title>
      <link href="/2023/09/12/git/git_clone/"/>
      <url>/2023/09/12/git/git_clone/</url>
      
        <content type="html"><![CDATA[<p>Git 克隆</p><span id="more"></span><p>之前讲过，<code>Git</code> 版本库在工作区根目录下的 <code>.git</code> 目录，如果不小心删除了工作区，版本库也会一并被删除，一个项目仅在一个工作区进行维护太危险了。为了更好地避免这个问题，将学习使用 <code>git clone</code> 命令建立版本库克隆，以及使用 <code>git push</code> 和 <code>git Pull</code> 命令实现克隆版本之间的数据同步。</p><p><strong>命令 <code>git clone</code> 的三种用法：</strong></p><ol><li><p><code>git clone &#123;repository&#125; &#123;directory&#125;</code></p><p> 将 <code>repository</code> 指向的版本库克隆到 <code>directory</code> 目录，会将整个工作区都检出，包括 <code>.git</code> 目录。</p></li><li><p><code>git clone --bare  &#123;repository&#125; &#123;directory.git&#125;</code></p><p> 只检出版本库 ，不包含工作区，称为裸版本库，目录名通常以 <code>.git</code> 为后缀。</p></li><li><p><code>git clone --mirror &#123;repository&#125; &#123;directory.git&#125;</code></p><p> 跟第二种用法一样。但是，会对上游版本库进行注册，可通过 <code>git fetch</code> 命令和上游版本库进行持续同步。</p></li></ol><p><strong>命令 <code>git push / pull</code> 的用法：</strong><code>git push/pull &#123;remote-repos&#125; &#123;refspec&#125;</code></p><p>其中花括号的含义是参数可以省略，<code>remote-repos</code> 是远程版本库的地址或名称，<code>refspec</code> 是引用表达式。</p><p><strong>用法一演示：</strong></p><ol><li>执行克隆命令，把 <code>demo</code> 目录克隆到 <code>demo-backup</code> 目录：</li></ol><p><img src="/2023/09/12/git/git_clone/clone1.png" alt="clone1.png"></p><ol><li>进入 <code>demo</code> 版本库，生成一些测试提交，使用 <code>--allow-empty</code> 参数允许生成空提交。</li></ol><p><img src="/2023/09/12/git/git_clone/clone2.png" alt="clone2.png"></p><ol><li>进行同步处理，在 <code>demo-backup</code> 中进行 <code>git pull</code> ：</li></ol><p><img src="/2023/09/12/git/git_clone/clone3.png" alt="clone3.png"></p><p>可以看到，<code>demo</code> 版本库中的提交已经被拉回到 <code>demo-backup</code> 版本库了。我们只是执行了 <code>git pull</code> 命令，就能同步 <code>demo</code> 中的提交，这是为什么呢？答案就在 <code>git clone</code> 命令，该命令会在克隆出来的版本库中对源版本库（上游版本库）进行注册，所以在 <code>demo-backup</code> 版本库中执行拉回操作，无须设置源版本库。</p><p>可以通过如下命令查看源版本库的注册信息：</p><p><img src="/2023/09/12/git/git_clone/clone4.png" alt="clone4.png"></p><p>实际上，注册源版本库的奥秘就在 <code>Git</code> 的配置文件中 ：</p><p><img src="/2023/09/12/git/git_clone/clone5.png" alt="clone5.png"></p><p>关于配置文件中的 <code>remote</code> 和 <code>branch</code> ，在后面章节再进行详细的讲解。</p><p>很显然，在 <code>demo</code> 的配置文件中是没有 <code>remote</code> 和 <code>branch</code> 的配置项的，所以 <code>demo</code> 不能直接通过 <code>git pull</code> 来同步 <code>demo-backup</code> 中的提交，要指定路径 ：<code>git pull ../demo-backup</code> 。具体操作就不演示了。</p><p><strong>用法二演示（使用 –bare 参数）：</strong></p><ol><li>从 <code>demo</code> 版本库克隆裸版本库到 <code>repos/demo.git</code> 目录中，克隆出来的只有版本库目录，不包含工作区，如下：</li></ol><p><img src="/2023/09/12/git/git_clone/clone6.png" alt="clone6.png"></p><ol><li>查看一下该裸版本库的配置文件 ：</li></ol><p><img src="/2023/09/12/git/git_clone/clone7.png" alt="clone7.png"></p><p>单独查看某个配置项，可以这样： <code>git config core.bare</code></p><ol><li>进入 <code>demo</code> 版本库，生成一些测试提交：</li></ol><p><img src="/2023/09/12/git/git_clone/clone8.png" alt="clone8.png"></p><ol><li>直接在 <code>demo</code> 版本库向 <code>demo.git</code> 推送，无须在 <code>demo.git</code> 进行 <code>git pull</code> 操作（实际上也无法执行 <code>git pull</code> 操作，因为没有工作区）：</li></ol><p><img src="/2023/09/12/git/git_clone/clone9.png" alt="clone9.png"></p><p><img src="/2023/09/12/git/git_clone/clone10.png" alt="clone10.png"></p><p>推送成功(第一次推送时)要加上 <code>--set-upstream</code> 或 <code>-u</code> 参数，将本地分支和远程分支进行关联，后续就不需要再指定远程分支了，直接 <code>git push</code> 即可。裸版本库会实时同步，不需要任何操作。</p><p><strong>创建裸版本库的另一种方式(<code>git init --bare</code>)：</strong></p><p><code>git init</code> 初始化版本库时，默认是带工作区的，如果加上 <code>--bare</code> 参数，则以裸版本库的方式初始化版本库：<code>git init --bare ../demo-init.git</code></p><p><img src="/2023/09/12/git/git_clone/clone11.png" alt="clone11.png"></p><p><img src="/2023/09/12/git/git_clone/clone12.png" alt="clone12.png"></p><p>根据目录内容和 <code>core.bare</code> 配置的值可以确定，就是裸版本库，没有任何提交内容。</p><p>现在，将 <code>demo</code> 的提交内容推送到 <code>demo-init.git</code> ，操作如下：</p><p><img src="/2023/09/12/git/git_clone/clone13.png" alt="clone13.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>改变历史</title>
      <link href="/2023/09/04/git/git_change_history/"/>
      <url>/2023/09/04/git/git_change_history/</url>
      
        <content type="html"><![CDATA[<p>改变历史</p><span id="more"></span><p>从现在开始，会通过 <code>sourcetree</code> 软件（可视化 <code>Git</code> 客户端工具）来更好地分析 Git 命令，其中的图谱更是非常的直观地显示了整个提交历史链。</p><p>先查看一下当前的工作区状态：</p><p><img src="/2023/09/04/git/git_change_history/git_change_history1.png" alt="git_change_history1.png"></p><p>由于在上一节，我们使用了归档命令 <code>git archive -o latest.zip Head</code> ，所以这里有一个 <code>latest.zip</code> 未被 <code>Git</code> 追踪。为了让工作区变干净，我们对这个文件进行忽略处理 ： <code>.gitignore</code> 文件中添加一行 <code>*.zip</code> 。</p><p><img src="/2023/09/04/git/git_change_history/git_change_history2.png" alt="git_change_history2.png"></p><p><strong>场景一：刚提交就后悔了，可能是提交说明写错了或者有文件忘记提交或者有的修改不应该被提交等等，总之就是这一次提交我后悔了，想回退，但是又不想让这一次错误的提交记录出现在历史提交中，那么就可以使用 <code> git commit --amend</code> 命令了。</strong></p><p>开始演示这种单步的后悔场景：</p><ol><li>创建新文件 <code>a.txt</code> 并进行提交。</li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history3.png" alt="git_change_history3.png"></p><p><img src="/2023/09/04/git/git_change_history/git_change_history4.png" alt="git_change_history4.png"></p><ol start="2"><li>删除之前创建的 <code>a.txt</code> 文件，再进行提交。</li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history5.png" alt="git_change_history5.png"></p><ol start="3"><li>后悔了，因为上次的提交说明写错了。</li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history6.png" alt="git_change_history6.png"></p><p><strong>总结：这种单步的后悔，主要是通过提交时的 <code>--amend</code> 参数实现，提交的记录会把上次的提交记录覆盖掉了，这正是我们想要的结果。其实原理很简单，内部使用的就是 <code>reset </code> 命令，帮你撤回到上一次提交，只不过 <code>Git</code> 提供了一个更好用更简洁的修补提交命令而已。</strong></p><p><strong>场景二：本地进行了多次的小修改提交，当想要将代码 <code>push</code> 到远程时，不想把本地实验性的小提交都作为提交历史被合并到版本库历史提交链。这时候，就需要多步后悔的操作了。使用 reset 命令，先回退到之前的某个版本，然后再进行提交。</strong></p><p>开始演示这种多步的后悔场景：</p><ol><li>先查看一下当前的提交历史：</li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history7.png" alt="git_change_history7.png"></p><ol start="2"><li>现在把最新的三个提交，合并成一个提交：</li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history8.png" alt="git_change_history8.png"></p><p><img src="/2023/09/04/git/git_change_history/git_change_history9.png" alt="git_change_history9.png"></p><ol start="3"><li>再查看提交历史：</li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history10.png" alt="git_change_history10.png"></p><p>原理很简单，通过 <code>reset</code> 回退到指定版本，但是不覆盖工作区和暂存区的内容，再进行内容的提交即可。</p><p><strong>三、对提交历史节点进行丢弃、合并、变基操作。</strong></p><p>接下来的演示比较复杂，涉及到多个新命令的使用，我会提前解释一下新命令的用法，然后再结合我们的项目进行演示巩固。</p><p>为了演示接下来的操作，将再进行 <code>6</code> 次提交，每次提交创建一个文件，文件名为 <code>A、B、C、D、E、F</code> ，最新的提交为 <code>F</code>，为了方便查看，会给对应的提交打上 <code>tag</code> ：</p><p><img src="/2023/09/04/git/git_change_history/git_change_history11.png" alt="git_change_history11.png"></p><p><img src="/2023/09/04/git/git_change_history/git_change_history12.png" alt="git_change_history12.png"></p><p>上图只展示了 <code>A</code> 的提交，后面几个提交的操作是一样的。接着，对最新的 <code>6</code> 个提交打上 <code>tag</code> ，方便对提交进行标识：</p><p><img src="/2023/09/04/git/git_change_history/git_change_history13.png" alt="git_change_history13.png"></p><p><img src="/2023/09/04/git/git_change_history/git_change_history14.png" alt="git_change_history14.png"></p><p>现在，所有的准备工作都已经完成了。多个 <code>6</code> 个 打上 <code>tag</code> 的提交，相应的文件也多了 <code>6</code> 个。</p><p>接下来会通过几种不同的方式来实现两种场景。</p><h3 id="实现场景一：-丢弃-D-提交-，即变为-A-B-C-E-F"><a href="#实现场景一：-丢弃-D-提交-，即变为-A-B-C-E-F" class="headerlink" title="实现场景一： 丢弃 D 提交 ，即变为 A-B-C-E-F"></a>实现场景一： 丢弃 D 提交 ，即变为 A-B-C-E-F</h3><p><strong>第一种实现方式：通过 <code>git cherry-pick</code> 命令，配合 <code>checkout</code> 命令实现。</strong></p><p><code>git cherry-pick</code> 命令用于选择一个或多个提交，并将它们应用到当前分支，相当于把这些提交“拣选”过来。会依次应用指定的提交，并创建相应的新提交。该命令需要指定要选择的提交的哈希值或引用。</p><p>命令语法：<code>git cherry-pick &lt;commit1&gt; &lt;commit2&gt; ...</code></p><p>注意：<code>git cherry-pick</code> 可能会引发冲突，特别是当选择的提交与当前分支上的其他更改产生冲突时。在这种情况下，你需要手动解决冲突后执行 <code>git cherry-pick --continue</code> 命令来完成操作。</p><p>具体步骤如下：</p><ol><li><p>将 <code>HEAD</code> 头指针指向提交 <code>C</code> （通过标签 <code>C</code> 来指代具体的提交 <code>ID</code> ）：<code>git checkout C</code></p></li><li><p>通过 <code>cherry-pick</code> 命令，顺序选择 <code>E、F</code> 提交在当前 <code>HEAD</code> 上重放（内容一致，但是提交 <code>ID</code> 会变，是个新提交）：</p></li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history15.png" alt="git_change_history15.png"></p><ol start="3"><li>通过下图日志可以看出来，提交 <code>ID</code> 变了，但是提交内容不变。<code>AuthorDate</code> 是提交的原始更改时间，而 <code>CommitDate</code> 是进行 <code>cherry-pick</code> 的提交时间。</li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history16.png" alt="git_change_history16.png"></p><ol start="4"><li>最后，需要将头指针切换回 <code>master</code> ，并且将 <code>master</code> 分支重置到最新的提交 ID （<code>557585c</code>）上，这里通过 <code>reflog</code> 的语法，即 <code>HEAD@&#123;1&#125;</code> 表示 <code>master</code> 分支最新提交，不清楚 <code>HEAD@&#123;1&#125;</code> 指代哪个提交，可以通过 <code>git reflog</code>  来查看：</li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history17.png" alt="git_change_history17.png"></p><p><img src="/2023/09/04/git/git_change_history/git_change_history18.png" alt="git_change_history18.png"></p><p><img src="/2023/09/04/git/git_change_history/git_change_history19.png" alt="git_change_history19.png"></p><p><img src="/2023/09/04/git/git_change_history/git_change_history20.png" alt="git_change_history20.png"></p><p>通过图谱可清晰看到，之前提交的 <code>D、E、F</code> 提交在分叉提交上，而在 <code>master</code> 分支上重新提交了 <code>E、F</code>，全新的提交 <code>ID</code> 。</p><p><strong>注意：E 和 F 是全新的提交，没有 tag ，之前的 tag 还在原来的提交上，甚至可以通过原来的 tag 来重置状态。</strong></p><p>阶段性总结：上述操作说明了分支不是固定的，每个分叉提交都可以做为分支来使用，图谱中的红色分叉原本就是 <code>master</code> 分支，现在 <code>master</code> 分支变为蓝色分叉了，主要还是看分支引用记录的提交 <code>ID</code> 。</p><p><strong>第二种实现方式： 通过 <code>git rebase</code> 命令实现。</strong></p><p>命令语法： <code>git rebase --onto [newbase] [since] [till]</code> </p><p>作用：对提交执行变基操作，可以实现将指定范围的提交 “嫁接” 到另一个提交之上。</p><p>变基的详细过程：</p><ol><li><p>首先会执行 <code>git checkout</code> 切换到 <code>till</code>。如果 <code>till</code> 指向的不是一个分支（如 <code>master</code>），则变基操作是在 <code>detached HEAD</code>（分离头指针）状态进行的，当变基结束后，需要对 <code>master</code> 分支执行重置以实现变基结果在分支中生效。(场景一实现效果的最后一步操作)</p></li><li><p>将 <code>since .. till</code> 所标识的提交范围写到一个临时文件中。<code>since .. till</code> 指的是 <code>since</code> 到 <code>till</code> 之间的历史记录，包含 <code>till</code> ，但是不包含 <code>since</code> ，即前面是开区间，后面是闭区间。</p></li><li><p>将当前分支强制重置到 <code>newbase</code> ，相当于执行 ：<code>git reset --hard newbase</code> 。</p></li><li><p>从保存在临时文件中的提交列表中，将提交逐一按顺序重新提交到重置之后的分支上。如果遇到提交已经在分支中包含，则跳过该提交。</p></li><li><p>如果在提交中遇到冲突，则变基过程暂停。用户解决冲突后执行 <code>git rebase --continue</code> 继续变基操作。或者执行 <code>git rebase --skip</code> 跳过此提交。或者执行 <code>git rebase --abort</code> 就此终止变基操作回到变基前的分支上。</p></li></ol><p>具体步骤如下：</p><ol><li>首先，通过原来的 tag 重置回到提交 F 上，即回到准备场景的时机：</li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history21.png" alt="git_change_history21.png"></p><p><img src="/2023/09/04/git/git_change_history/git_change_history31.png" alt="git_change_history31.png"></p><ol start="2"><li>执行变基操作：<code>git rebase --onto C D F</code></li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history32.png" alt="git_change_history32.png"></p><p><code>C</code> 就是语法中的 <code>newbase</code> ，<code>D</code> 是 <code>since</code> , <code>F</code> 是 <code>till</code> 。<code>A、B、C</code> 是分支中已经存在的提交，所以会跳过这些提交，<code>E、F</code> 在 <code>C</code> 的提交基础上重新提交了，生成了两个新的提交（内容是原来的 <code>E、F</code>，但是提交 <code>ID</code> 变化了，属于新提交）。类似批量执行了 <code>cherry-pick</code> 。现在 <code>HEAD</code> 指向最新的提交，并不指向 <code>master</code> ， <code>master</code> 记录的还是原来的 <code>tag</code> 是 <code>F</code> 的提交。</p><ol start="3"><li>将 <code>master</code> 分支指向变基后的新提交上。<br>  <code>git checkout master</code> ：把分离头指针状态变回 master 引用。<br>  <code>git reset --hard HEAD@&#123;1&#125;</code> ：把 master 记录的提交 ID 重置为变基后的新提交。</li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history20.png" alt="git_change_history20.png"></p><p><strong>明确一下：现在的 <code>master</code> 分支是 <code>A-B-C-E-F</code> 。这里的 <code>E</code> 和 <code>F</code> 不是原来的 <code>E</code> 和 <code>F</code> ，只是提交内容是一致的。上述图谱中的红色的打上标签的 <code>E</code> 和 <code>F</code> 才是原来的提交(并不是直接拿掉 <code>D</code> 提交，其他的都保持一样的提交)。</strong></p><p><strong>第三种实现方式： 通过 <code>git rebase -i</code> 交互式命令实现。</strong></p><p>交互式变基操作：会将 <code>since .. till</code> 的提交全部列在一个文件中，然后自动打开一个编辑器来编辑这个文件。可以通过修改文件的内容设定变基操作，实现删除提交、将多个提交压缩为一个提交、更改提交顺序以及更改历史提交的提交说明等。</p><p>下图为变基时打开的文件（<code>git rebase -i C</code>）：</p><p><img src="/2023/09/04/git/git_change_history/git_change_history36.png" alt="git_change_history36.png"></p><p>从该文件可以看出：</p><ul><li>会先列出 <code>since</code> 到 <code>till</code> 的提交，不包含 <code>since</code> ,所以只列出了 <code>D、E、F</code> 。</li><li>每个提交前面会有一个动作命令，现在是 <code>pick</code> ，即应用此提交。</li></ul><p>简单分析一下每个动作命令的含义：</p><p><strong>pick</strong> : 简写为 <code>p</code> ，表示应用此提交。</p><p><strong>reword</strong> ：简写为 <code>r</code> ，表示应用此提交，但是会暂停 <code>rebase</code> 的进程，并提供了一个修改提交信息的机会。对于修改历史提交的提交说明非常方便。</p><p><strong>edit</strong> ：简写为 <code>e</code>，表示应用此提交，但是会暂停 <code>rebase</code> 的进程，可以编辑提交内容。提交后，还需要执行 <code>git rebase continue</code> 命令继续变基操作。用户在变基暂停状态下可以执行多次提交，从而实现把一个提交分解为多个提交。</p><p><strong>squash</strong> ：简写为 <code>s</code> ，该提交会与前面的提交合并为一个提交。</p><p><strong>fixup</strong> ：简写为 <code>f</code> ，该提交会与前面的提交合并为一个提交，但是当前提交说明会被丢弃。</p><p><strong>drop</strong> ：简写为 <code>d</code> ，丢弃当前提交。</p><p>开始具体实现步骤：</p><ol><li>首先，通过原来的 <code>tag</code> 重置回到提交 <code>F</code> 上，即回到准备场景的时机：</li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history21.png" alt="git_change_history21.png"></p><p><img src="/2023/09/04/git/git_change_history/git_change_history31.png" alt="git_change_history31.png"></p><ol start="2"><li>执行交互式变基操作：<code>git rebase -i C</code></li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history36.png" alt="git_change_history36.png"></p><p>按 <code>i</code> 进入编辑模式，然后把 D 那行删除掉就行了，如下显示：</p><p><img src="/2023/09/04/git/git_change_history/git_change_history37.png" alt="git_change_history37.png"></p><p>按下 <code>esc</code> 退出编辑模式。再通过 <code>:wq</code> ，保存并退出，就完成了，效果跟其他实现方式一致。</p><h3 id="实现场景二：-将-C-和-D-合并，变成一个提交，即-A-B-CD-E-F"><a href="#实现场景二：-将-C-和-D-合并，变成一个提交，即-A-B-CD-E-F" class="headerlink" title="实现场景二： 将 C 和 D 合并，变成一个提交，即 A-B-CD-E-F"></a>实现场景二： 将 C 和 D 合并，变成一个提交，即 A-B-CD-E-F</h3><p><strong>第一种实现方式：通过 <code>git cherry-pick</code> 命令，配合 <code>checkout</code> 命令实现。</strong></p><p>具体步骤如下：</p><ol><li>首先，通过原来的 tag 重置回到提交 F 上，即回到准备场景的时机：</li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history21.png" alt="git_change_history21.png"></p><ol start="2"><li>将 <code>HEAD</code> 指针指向 <code>D</code> 提交，然后回退两次，将指针指向 <code>B</code> 提交，以便待会将 <code>C</code> 和 <code>D</code> 合并：<br><code>git checkout  D</code><br><code>git reset --soft HEAD^^</code></li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history22.png" alt="git_change_history22.png"></p><p>注意看： <code>master</code> 记录的还是最新的提交。但是 <code>HEAD</code> 指向了 <code>B</code> 。回顾之前我们讲述 <code>reset</code> 命令时，<code>reset</code> 会改变 <code>master</code> 记录的提交 <code>ID</code> ，其实跟这里的表现并没有冲突。因为当时的 <code>HEAD</code> 默认指向的是 <code>master</code> ，即 <code>HEAD</code> 就是 <code>master</code> ，所以 <code>master</code> 记得的提交 <code>ID</code> 才会跟着变化 。而在这里的 <code>HEAD</code> 是处于分离头指针状态，指向的是 <code>D</code> ，那么回退到 <code>B</code> 时， <code>HEAD</code> 指向的是 <code>B</code> ，但是 <code>master</code> 并不会有任何改变。</p><p>如图所示，红色是当前 <code>HEAD</code> 及历史提交，当前 <code>HEAD</code> 指向提交 <code>B</code>。因为是 通过 <code>--soft</code> 模式从 <code>D</code> 回退到 <code>B</code> 的，所以当前的工作区和暂存区的内容为 <code>C</code> 和 <code>D</code> 的提交内容（可以理解为 <code>C</code> 和 <code>D</code> 的内容从提交中撤回了）。</p><ol><li>将当前的 <code>C</code> 和 <code>D</code> 的内容进行提交，通过 <code>-C</code> 参数，重新使用之前提交过的 <code>C</code> 的提交信息进行提交，这次提交是新的提交，会生成新的提交 <code>ID</code> ，只是提交描述为之前 <code>C</code> 的描述 ：<code>git commit -C C</code></li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history23.png" alt="git_change_history23.png"></p><ol start="4"><li>上一步已经将 <code>C</code> 和 <code>D</code> 的提交内容合并了(通过一个新的提交来体现)。现在，我们通过 <code>cherry-pick</code> 命令，将 <code>E 、F</code> 在当前 <code>HEAD</code> 上进行重放即可：</li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history24.png" alt="git_change_history24.png"></p><p><img src="/2023/09/04/git/git_change_history/git_change_history25.png" alt="git_change_history25.png"></p><ol start="5"><li>我们先检出 <code>master</code> ，看看现在是怎样：<code>git checkout master</code></li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history26.png" alt="git_change_history26.png"></p><p><img src="/2023/09/04/git/git_change_history/git_change_history27.png" alt="git_change_history27.png"></p><p>对比上一次的图谱，<code>master</code> 从红色的 <code>F</code> 变成了蓝色的 <code>F</code> ，现在指向的最新的提交是之前的 <code>95a86cf</code> ，而不是我们想要的 <code>HEAD@&#123;1&#125;</code> 这个提交。</p><ol start="6"><li>最后，我们将当前 <code>HEAD</code> 的指向变为 <code>HEAD@&#123;1&#125;</code> :</li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history28.png" alt="git_change_history28.png"></p><p><img src="/2023/09/04/git/git_change_history/git_change_history29.png" alt="git_change_history29.png"></p><p><img src="/2023/09/04/git/git_change_history/git_change_history30.png" alt="git_change_history30.png"></p><p>目的达成，现在变成 <code>5</code> 个提交了，第三个提交虽然描述为 <code>create C.txt</code> ，实际内容是 <code>create C.txt</code> 和 <code>create D.txt</code> 的融合。</p><p><strong>第二种实现方式： 通过 <code>git rebase</code> 命令实现。</strong></p><ol><li>前面的 3 步都跟实现方式一（通过 <code>cherry-pick</code> 方式实现）是一样的 ，现在开始不一样的第 4 步：</li></ol><ul><li>先记录现在最新的提交，这个提交将作为 <code>newbase</code> (新的基点)，我们通过 <code>tag</code> 的方式来更好地记录这个提交 <code>ID</code> 。</li></ul><p><img src="/2023/09/04/git/git_change_history/git_change_history34.png" alt="git_change_history34.png"></p><ul><li>开始执行变基操作：<code>git rebase --onto newbase D master</code></li></ul><p><img src="/2023/09/04/git/git_change_history/git_change_history30.png" alt="git_change_history30.png"></p><p>上述图谱显示已经没有 <code>newbase</code> 标签了，之前为了方便打了 <code>newbase</code> 标识，现在没用了，已经删除了：<code>git tag -d newbase</code></p><p>仔细观察： 当前的 <code>HEAD</code> 已经回到 <code>master</code>，而且 <code>master</code> 记录的最新的提交也是新的提交，而不在原来的 <code>F</code> 上了。这是因为我们这一次没有用参数 <code>F</code> ，而是用的 <code>master</code> 分支引用，使得变基操作自动处理了引用问题，无需手动将 <code>master</code> 分支指向变基后的新提交上(少了第一种实现方式的 5 和 6 步骤)。 </p><p>再次确认是否引用自动处理了：</p><p><img src="/2023/09/04/git/git_change_history/git_change_history35.png" alt="git_change_history35.png"></p><p><strong>第三种实现方式： 通过 <code>git rebase -i</code> 交互式命令实现。</strong></p><ol><li>首先，通过原来的 tag 重置回到提交 F 上，即回到准备场景的时机：</li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history21.png" alt="git_change_history21.png"></p><p><img src="/2023/09/04/git/git_change_history/git_change_history31.png" alt="git_change_history31.png"></p><ol start="2"><li>执行交互式变基操作：<code>git rebase -i B</code></li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history38.png" alt="git_change_history38.png"></p><p>修改第二行，将 <code>pick</code> 修改为 <code>s</code> （<code>squash</code>的简写）:</p><p><img src="/2023/09/04/git/git_change_history/git_change_history39.png" alt="git_change_history39.png"></p><p>保存退出之后 ，会自动开始变基操作，在执行到 <code>s</code> 命令设定的提交时，会进入提交前的日志编辑状态，如下图：</p><p><img src="/2023/09/04/git/git_change_history/git_change_history40.png" alt="git_change_history40.png"></p><p>输出说明已经很清晰了，C 和 D 的提交说明显示在一起，接下来准备执行的动作命令为 E 和 F，我们不修改提交说明，直接保存退出就完成了，效果跟其他实现方式一致。</p><p><img src="/2023/09/04/git/git_change_history/git_change_history30.png" alt="git_change_history30.png"></p><hr><h3 id="接下来，开始一个新的话题"><a href="#接下来，开始一个新的话题" class="headerlink" title="接下来，开始一个新的话题"></a>接下来，开始一个新的话题</h3><p><strong>一、丢弃历史</strong></p><p>使用场景：一些非常早的历史提交不希望或者没有必要再继续保留，对历史记录进行精简之后再与他人共享。或者不希望太多的历史版本而导致磁盘空间占用。</p><p>现在，我们对学习的版本库进行精简，先看一下当前的提交历史：</p><p><img src="/2023/09/04/git/git_change_history/git_change_history41.png" alt="git_change_history41.png"></p><p>我们希望把 <code>tag A</code> 之前的历史提交全部清除掉，可以这样操作：<br>基于 <code>tag A</code> 对应的提交构造一个根提交（即没有父提交的提交），然后再将 <code>master</code> 分支在 <code>tag A</code> 之后的提交变基到新的根提交上。</p><p>对于根提交的构造，可以使用 <code>git commit-tree</code> 命令实现，具体操作如下：</p><ol><li>查看一下 <code>tag A</code> 指向的目录树</li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history42.png" alt="git_change_history42.png"></p><ol start="2"><li>使用 <code>git commit-tree</code> 命令直接从该目录树创建提交，可用 <code>A^&#123;tree&#125;</code> 指向该目录树：</li></ol><p><img src="/2023/09/04/git/git_change_history/git_change_history43.png" alt="git_change_history43.png"></p><p>上图可知，确实为根提交，因为这个提交没有 <code>parent</code> 。</p><ol start="3"><li>根提交 <code>ID</code> 是 <code>520a0b9a</code> ，开始执行变基：</li></ol><p><code>git rebase --onto 520a0b9a  A master</code></p><p>现在应该熟练了吧，将 <code>A</code> 到<code> master</code> 最新的提交列表（不包含 <code>A</code>）， 在新的基点 <code>520a0b9a</code> 上进行重放。</p><p><img src="/2023/09/04/git/git_change_history/git_change_history44.png" alt="git_change_history44.png"></p><p>可以看到，历史记录精简了。</p><p><strong>二、反转提交</strong></p><p>使用场景：命令 <code>git revert</code> ，用于反转提交，该命令可以指定反转一个或多次提交的更改。</p><p>注意：是反转指定提交引入的修改，而不是删除该提交，这意味着之前的提交还存在，在历史记录中还保留着。</p><p>举例：我添加了一个文件 <code>A</code> 并进行提交 ，然后通过 <code>git revert</code> 命令进行一个反转提交，这个提交将删除文件 <code>A</code> ，即对指定的提交内容进行反转。最终会有两个提交记录，一个是添加文件 <code>A</code> 的提交，另一个是移除文件 <code>A</code> 的提交。</p><p>接下来，我们在当前练习项目中进行演示：</p><p>我们知道，现在最新的提交是 <code>F</code> ，创建了 <code>F.txt</code> 文件。现在对这个提交进行撤回，不是 <code>reset</code> 回到上一次提交，而是反转再提交一次：<code>git revert HEAD </code></p><p>执行命令之后，会在编辑状态下暂停，显示如下：</p><p><img src="/2023/09/04/git/git_change_history/git_change_history45.png" alt="git_change_history45.png"></p><p>可以在编辑器中修改提交说明，保存退出即可。</p><p>再查看一下提交历史看看：</p><p><img src="/2023/09/04/git/git_change_history/git_change_history46.png" alt="git_change_history46.png"></p><p>可以看到，增加了一个提交，当前的 <code>F.txt</code> 已经不存在了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 基本操作</title>
      <link href="/2023/08/31/git/git_base/"/>
      <url>/2023/08/31/git/git_base/</url>
      
        <content type="html"><![CDATA[<p>Git 基本操作</p><span id="more"></span><p>首先，简单介绍一下 <code>git tag</code> 命令，该命令可理解为 “打标签或里程碑”，本质上和 <code>branch</code>、<code>stash</code> 引用一样，也是一个引用，记录着提交 <code>ID</code> (或者创建 <code>Tag</code> 对象)，下面我们来操作一下：</p><ol><li>打上标签，标签名为 <code>old_practice</code>，并添加描述说明：</li></ol><p><img src="/2023/08/31/git/git_base/base1.png"></p><ol start="2"><li>查看标签记录的最新的提交 <code>ID</code>：</li></ol><p><img src="/2023/08/31/git/git_base/base2.png"></p><ol start="3"><li>查看该最新 <code>ID</code> 所记录的内容：</li></ol><p><img src="/2023/08/31/git/git_base/base3.png"></p><p>打标签之后，可以执行 <code>git describe</code> 命令，将最新提交显示为一个容易记的名称，显示的时候会选取离提交最近的 <code>tag</code> 为 ‘’基础版本号’’再附加距离 <code>tag</code> 的数字，以及该提交的哈希值缩写。因为当前的提交就是 <code>tag</code> 所在的提交，所以只会显示出 <code>tag</code> 名称 ：</p><p><img src="/2023/08/31/git/git_base/base4.png"></p><p>现在版本库的状态为暂存区和工作区都包含了修改，如下：</p><p><img src="/2023/08/31/git/git_base/base5.png"></p><p>接下来，我们进行各种操作来演示：</p><ol><li>先保存进度：</li></ol><p><img src="/2023/08/31/git/git_base/base6.png"></p><ol start="2"><li>再用 <code>git stash apply </code> 恢复进度，因为这个进度记录要多次使用，先不移除：</li></ol><p><img src="/2023/08/31/git/git_base/base7.png"></p><p>当前工作区的文件有：</p><p><img src="/2023/08/31/git/git_base/base8.png"></p><ol start="3"><li>直接在工作区删除这些文件</li></ol><p><img src="/2023/08/31/git/git_base/base9.png"></p><p><img src="/2023/08/31/git/git_base/base10.png"></p><p>可以看到本地文件已经删除掉了，但是暂存区和版本库中的文件仍然存在。</p><p><strong>阶段性总结：直接在工作区删除，对暂存区和版本库没任何影响。</strong></p><ol start="4"><li>查看状态看看：</li></ol><p><img src="/2023/08/31/git/git_base/base11.png"></p><p>输出表示，本地删除想要反映到暂存区，应该使用 <code>git rm</code> 命令，对不想删除的文件，可执行 <code>git restore</code> 让文件在工作区中恢复。</p><p>也就是说，需要将删除的工作的文件先 <code>git rm</code> 到暂存区再提交，才算真正的删除，那么我们操作一下：</p><p><img src="/2023/08/31/git/git_base/base12.png"></p><p><img src="/2023/08/31/git/git_base/base13.png"></p><p>现在，在最新的提交中，文件已经被删除了，但是在历史提交中还是存在的，可以通过历史提交来恢复相应的文件，所以完全不用担心。</p><ol start="5"><li>我们查一下上一次提交的文件列表：</li></ol><p><img src="/2023/08/31/git/git_base/base14.png"></p><p>可以通过文件路径，直接查看历史版本中的文件内容：</p><p><img src="/2023/08/31/git/git_base/base15.png"></p><p>我们之前将本地删除的文件反映到暂存区时，用  <code>git rm </code> 并通过空格写了一大堆文件名。其实是可以简化操作的，通过 <code>git add</code> 再加上 <code>-u</code> 参数就可以，其含义是将本地改动(更改和删除)的文件标记到暂存区。</p><p>下面我们用这种方式演示一下，首先要恢复到之前的状态才行：</p><ol><li>先回退到上一次提交的版本，即丢掉最新的提交：</li></ol><p><img src="/2023/08/31/git/git_base/base16.png"></p><ol start="2"><li>恢复之前保存的进度，<code>-q</code> 参数表示命令进入安静模式：</li></ol><p><img src="/2023/08/31/git/git_base/base17.png"></p><p>对比之前的输出：</p><p><img src="/2023/08/31/git/git_base/base18.png"></p><ol start="3"><li>再次删除工作区本地的文件：</li></ol><p><img src="/2023/08/31/git/git_base/base19.png"></p><ol start="4"><li>执行 <code>git add -u</code> 命令可以将(被版本库追踪的)本地文件的变更(修改、删除)全部记录到暂存区中 。【 git add 默认只记录修改，不包括新添加的文件和删除的文件】 ：</li></ol><p><img src="/2023/08/31/git/git_base/base20.png"></p><p>可以看到，工作区删除的文件已经被标记为下次提交时删除了【D】，之前我们看到的都是修改 【M】。</p><ol start="5"><li>最后，进行提交：</li></ol><p><img src="/2023/08/31/git/git_base/base21.png"></p><p><img src="/2023/08/31/git/git_base/base22.png"></p><p>可以看到，本地和版本库中的文件都不存在了。</p><p>一、恢复文件 ：</p><p>下面我们演示一下恢复已经被删除的指定文件，比如指定恢复被删除掉的 Welcome.txt 文件，我们都知道，当前最新的提交中，文件已经不存在，只能从历史提交中提取文件：</p><p><img src="/2023/08/31/git/git_base/base23.png"></p><p><code>HEAD~1</code> ，相当于 <code>HEAD^</code>，指上一次提交，<code>HEAD~2</code> ，相当于 <code>HEAD^^</code> ，指上上一次提交。执行 <code>git add </code> 加上 <code>-A</code> 参数，可以将工作区中所有修改、删除和新增的文件都添加到暂存区：</p><p><img src="/2023/08/31/git/git_base/base24.png"></p><p>最后，我们进行提交：</p><p><img src="/2023/08/31/git/git_base/base25.png"></p><p>二、移动文件：</p><p><img src="/2023/08/31/git/git_base/base26.png"></p><p>这里使用 <code>git mv</code> 命令完成操作，将 <code>Welcome.txt</code> 重命名为 <code>README</code> ，再进行提交。改名之后提交的输出能看到改名前后两个文件的相似度，这里因为文件没修改，所以相似度为 <code>100%</code> 。</p><p>其实可以不使用 <code>git mv </code> 命令，而使用我们之前学过的 <code>git rm</code> 和 <code>git add </code> 两条命令也能实现。</p><ol><li>首先，恢复到上一个版本：</li></ol><p><img src="/2023/08/31/git/git_base/base27.png"></p><p><img src="/2023/08/31/git/git_base/base28.png"></p><p>可以看到，<code>welcome.txt</code> 文件回来了。</p><ol start="2"><li>这次不用  <code>git mv</code> 命令，而是用 <code>mv</code> 直接更改本地文件：</li></ol><p><img src="/2023/08/31/git/git_base/base29.png"></p><p>输出表示 ， <code>welcome.txt</code> 被删除了【D】，有一个没被追踪的 <code>README</code> 【??】。</p><ol start="3"><li>在 <code>README</code> 文件增加一行，如下：</li></ol><p><img src="/2023/08/31/git/git_base/base30.png"></p><ol start="4"><li>使用 <code>git add -A</code> 命令，相当于对修改文件执行 <code>git add</code> ，对删除文件执行 <code>git rm</code> ，对本地新增文件执行 <code>git add</code> ：</li></ol><p><img src="/2023/08/31/git/git_base/base31.png"></p><ol start="5"><li>最后，进行提交：</li></ol><p><img src="/2023/08/31/git/git_base/base32.png"></p><p>这里通过 <code>rm</code> 命令本地移动文件的方式，使用 <code>add -A</code> 命令之后，查看状态时，并不是 <code>renamed</code> 而是新增和删除文件。</p><p>三、文件忽略</p><p>我们之前打了一个标签叫做 “ old_practice” ，现在再次执行 <code>git describe</code> 看一下版本号：</p><p><img src="/2023/08/31/git/git_base/base33.png"></p><p>也就是说：当前工作区的版本是 “tag” 后的第三个版本，提交 ID 是 <code>3dffaeb</code> 。【注意：要忽略ID前面的g】</p><p>当我们不想所有的文件都被 <code>Git</code> 追踪，想让指定的文件忽略(Git 当它们不存在，不进行版本控制)时。那么，可以在这个目录下，创建一个名为为  <code>.gitignore</code> 的文件 【注意，前边有个点】，把那些要忽略的文件写在其中，文件名可以使用通配符，比如：</p><p><img src="/2023/08/31/git/git_base/base34.png"></p><p>先新建一个文件，用于测试效果，先不忽略这个文件，看看状态：</p><p><img src="/2023/08/31/git/git_base/base35.png"></p><p>可以看到 <code>.gitignore 和 ignore_teset.txt</code> 文件都显示没被追踪，需要 <code>add</code> 操作。现在，我们在 <code>.gitgnore</code> 中添加一行 <code>ignore_test.txt</code> ，再查看一下状态：</p><p><img src="/2023/08/31/git/git_base/base36.png"></p><p>发现 <code>ignore_teset.txt</code> 被忽略了，无论对这个文件做什么操作，Git 都不管了。</p><p>实际上，可以把自身添加到忽略文件当中，如下：</p><p><img src="/2023/08/31/git/git_base/base37.png"></p><p><img src="/2023/08/31/git/git_base/base38.png"></p><p>工作区非常干净。<code>.gitignore</code> 通常是要添加到版本库中的，这样别人 <code>clone</code> 项目之后，也能够正常忽略指定的文件，即文件忽略在他人的工作区中同样生效。因为 <code>.gitignore</code> 文件是共享式的。</p><p>查看状态的时候，可以加上 <code>--ignored</code> 来显示被忽略的文件：</p><p><img src="/2023/08/31/git/git_base/base39.png"></p><p>如果不想共享，想本地独享忽略呢？有两种实现方式。</p><p>第一种：针对具体版本库的 “独享式” 忽略。即通过在版本库的 <code>.git</code> 目录下的文件 <code>.git/info/exclude</code> 来设置文件忽略。</p><p>第二种：全局的 “独享式”忽略。即通过 <code>Git</code> 的配置变量 <code>core.excludesfile</code>  指定一个忽略文件，其设置的忽略对<strong>所有本地版本库均有效</strong>。</p><p><strong>总结：具体使用哪一种忽略方式，取决于实际的场景。如果文件忽略对于所有使用此版本库工作的人都有用，就在版本库中创建一个  <code>.gitignore</code> 文件来建立忽略。否则，如果工作区创建的是一个实验性的目录或文件，本不应该让他人知道，那么使用本地忽略。</strong></p><p>最后，我们简单讲一下 <code>Git</code> 忽略语法：</p><ol><li>文件中的空行或以 <code>#</code> 开始的行会被忽略(相当于代码编辑中的注释)。</li><li>可以使用通配符，例如： <code>*</code> 代表任意多字符，<code>?</code> 代表一个字符，[abc] 代表可选字符范围等。</li><li>如果名称的最前面是一个路径分隔符 <code>/</code> ，表明要忽略的文件在此目录下，而非子目录的文件。</li><li>如果名称的最后面是一个路径分隔符 <code>/</code> ，表明要忽略的是整个目录。</li><li>名称最前面添加一个 <code>!</code> ，表示不忽略。</li></ol><p>下面的文件忽略示例，包含了上述要点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是注释行 -- 被忽略</span><br><span class="line">*.a# 忽略所有以 .a 为扩展名的文件</span><br><span class="line">!lib.a# 但是 lib.a 文件或目录不要忽略，即使前面设置了对 *.a 的忽略</span><br><span class="line">/TODO# 只忽略此目录下的 TODO 文件，其他目录或当前目录的子目录中的 TTODO 文件不忽略</span><br><span class="line">build/# 忽略所有 build/ 目录下的文件</span><br><span class="line">doc/*.txt# 忽略文件如 doc/notes.txt ，但是文件如 doc/server/arch.txt 不被忽略【没写到指定目录级别不会被忽略】</span><br></pre></td></tr></table></figure><p><strong>总结：文件 <code>.gitignore</code> 的作用范围是其所处的目录及其子目录，而且只对未被追踪的文件有效，如果文件已经加入版本库了，忽略对其无效。</strong></p><p>四、文件归档</p><p><code>Git</code> 提供了一个归档命令 <code>git archive</code> ，可以对任意提交对应的目录树建立归档，示例如下：</p><p><img src="/2023/08/31/git/git_base/base40.png"></p><p>基于最新提交建立归档文件 <code>latest.zip</code> 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 恢复进度</title>
      <link href="/2023/08/31/git/git_stash/"/>
      <url>/2023/08/31/git/git_stash/</url>
      
        <content type="html"><![CDATA[<p>Git 恢复进度</p><span id="more"></span><p>我们之前使用 <code>git stash</code> 命令，将当时的修改进行了保存，保存的内容为： <strong>新增了 <code>a/b/c/hello.txt</code> 文件，并添加了一行 <code>Bye Bye.</code> ，<code>welcome.txt</code> 文件新增了一行 <code>Bye Bye.</code></strong></p><p>实际上，恢复进度也是用这个命令。我们先看一下当前的分支状态和日志信息：</p><p><img src="/2023/08/31/git/git_stash/stash1.png"></p><p>现在，我们处于 master 分支上，，查看保存的进度命令如下：<code>git stash list</code></p><p><img src="/2023/08/31/git/git_stash/stash2.png"></p><p>可使用 <code>git stash pop</code> 从最近保存的进度进行恢复 ：</p><p><img src="/2023/08/31/git/git_stash/stash3.png"></p><p>可以看到，之前保存的内容全都恢复了，列表中的该保存记录被销毁了。仔细查看一下输出：<code>hello.txt</code> 文件已经 <code>add</code> 了 ，等待 <code>commit</code> ，<code>welcome.txt</code> 文件修改了，还没被 <code>add</code> ， <code>stash@&#123;0&#125;</code> 这个进度记录被 <code>drop</code>（删除）了。</p><p>再查看一下工作区的状态：</p><p><img src="/2023/08/31/git/git_stash/stash4.png"></p><p>发现跟恢复进度时的输出是一致的。</p><p>现在，我们根据之前学过的各种命令，进行各种操作：</p><ol><li>把当前暂存区的内容进行提交，即只提交 <code>a/b/c/hello.txt</code> ，不提交 <code>welcome.txt</code> ：</li></ol><p><img src="/2023/08/31/git/git_stash/stash5.png"></p><p><img src="/2023/08/31/git/git_stash/stash6.png"></p><p>可以看到<code> hello.txt</code> 文件被提交了，<code>welcome.txt</code> 文件并没有。</p><ol start="2"><li>现在后悔了，想回到之前的状态，想要撤回这个提交：</li></ol><p>可用命令 <code>git reset --soft HEAD^</code> ，注意要加上 <code>--soft</code> ，只是将分支提交记录回退到上一次提交。如果用默认的 <code>--mixed</code> ，会覆盖掉暂存区的。</p><p><img src="/2023/08/31/git/git_stash/stash7.png"></p><p>可以看到，之前提交的内容回来了，提交记录也是之前的。</p><ol start="3"><li>如果想把 <code>welcome.txt</code> 进行提交，而把 <code>hello.txt</code> 撤出暂存区，可以这样操作：</li></ol><p><img src="/2023/08/31/git/git_stash/stash8.png"></p><p><img src="/2023/08/31/git/git_stash/stash9.png"></p><p>这是 <code>reset</code> 的另一种用法，该用法不会改变引用，也不会改变工作区，而是用指定提交状态下（这里是 <code>HEAD</code>）的文件替换掉暂存区中的文件。会回到 <code>git add</code> 命令之前的状态。</p><ol start="4"><li>突然又不想提交 <code>welcome.txt</code> 文件，想从暂存区撤出（<code>git reset</code> 等价于 <code>git reset --mixed HEAD</code>） ：</li></ol><p><img src="/2023/08/31/git/git_stash/stash10.png"></p><ol start="5"><li>现在，想把工作区所有修改全部清除掉，包括 <code>welcome.txt</code> 的改动和目录 <code>a</code> 以及下面的子目录和文件，可以使用 <code>git checkout .</code> 命令：</li></ol><p><img src="/2023/08/31/git/git_stash/stash11.png"></p><p>现在工作区还有一个多余的目录 a ，<code>git clean -nd</code> 命令可以查看哪些文件和目录可以被删除，以免造成误删除：</p><p><img src="/2023/08/31/git/git_stash/stash12.png"></p><p>发现 a 目录是可以被正常删除的，这时候再强制删除多余的目录和文件：</p><p><img src="/2023/08/31/git/git_stash/stash13.png"></p><p><img src="/2023/08/31/git/git_stash/stash14.png"></p><p>此时，工作区变得非常干净了。</p><p>最后，我们再详细讲解一下 <code>git stash</code> 的用法：</p><p><code>git stash </code> 用于保存和恢复工作进度，这个命令非常有用。</p><ul><li><p>命令： <code>git stash</code><br>  作用：保存当前的工作进度，会分别对暂存区和工作区的状态进行保存。</p></li><li><p>命令：<code>git stash list</code><br>  作用：显示进度列表。很明显可以对工作进度进行多次保存操作，并且在恢复的时候可以进行选择。</p></li><li><p>命令： <code>git stash pop [ &lt;stash&gt; ]</code><br>  作用：如果不使用任何参数，默认恢复最新保存的工作进度，并将恢复的工作进度从存储列表中移除。如果加上 <code>stash</code> 参数(来自 <code>git stash list</code> 显示的列表)，则从指定 <code>stash</code> 中恢复，恢复之后也将该进度从存储列表中移除。</p></li><li><p>命令：  <code>git stash [ save ] [ -k ] [&lt;message&gt;]</code><br>作用：通过  save 可以在保存进度的时候指定存储说明，格式如下：<code>git stash save &quot;this is a message&quot;</code>，如果再加上 <code>-k</code> 参数，则保存进度之后不会将暂存区重置，默认会将暂存区和工作区强制重置。</p></li><li><p>命令： <code>git stash apply [ &lt;stash&gt; ]</code><br>  作用：跟 <code>git stash pop [ &lt;stash&gt; ]</code> 功能一样，但是恢复之后，该进度不会从存储列表中移除。</p></li><li><p>命令： <code>git stash drop [&lt;stash&gt;]</code><br>  作用：删除存储记录，默认删除最新保存的记录，可指定记录进行删除。</p></li><li><p>命令：<code>git stash clear</code><br>  作用：清空所有的存储记录。</p></li><li><p>命令：<code>git stash branch &lt;branch-name&gt; &lt;stash&gt;</code><br>  作用：基于存储记录来创建分支。（分支功能后面再讲）</p></li></ul><p>简单探秘一下 <code>git stash</code> 的机制，通过示例演示一下：</p><p>当前，我们没有存储任何进度，列表为空：</p><p><img src="/2023/08/31/git/git_stash/stash15.png"></p><p>在 <code>welcome.txt</code> 文件中添加一行 <code>Bye-Bye.</code> ，并创建 <code>hack-1.txt</code> 文件（文件内添加一行 <code>hello.</code>）：</p><p><img src="/2023/08/31/git/git_stash/stash16.png"></p><p>可以看到，暂存区中添加了新创建的 <code>hack-1.txt</code> ，修改过的<code> welcome.txt</code> 并没添加到暂存区，现在我们将当前的进度保存：</p><p><img src="/2023/08/31/git/git_stash/stash17.png"></p><p><img src="/2023/08/31/git/git_stash/stash18.png"></p><p>结果是：工作区恢复到了修改前的状态（实际使用了 <code>git reset --hard HEAD</code> 命令），文件 <code>welcome.txt</code> 的修改不见了，新增的文件 <code>hack-1.txt</code> 也不见了。</p><p>接下来，我们再做一个修改，新创建 <code>hack-2.txt</code> 文件，并添加一行文本为 <code>fix.</code> ，并尝试保存进度：</p><p><img src="/2023/08/31/git/git_stash/stash19.png"></p><p>很遗憾，保存失败，说没有任何变更内容需要保存。可见，本地没有被版本控制系统跟踪的文件并不能保存进度，只能先 <code>add</code> 再保存：</p><p><img src="/2023/08/31/git/git_stash/stash20.png"></p><p>现在有两个保存记录了，如下：</p><p><img src="/2023/08/31/git/git_stash/stash21.png"></p><p>在保存进度时，最好提供说明，这样可以更好地通过进度列表找到保存的进度。每个进度的标识都是 <code>stash@&#123;&lt;n&gt;&#125;</code> 格式，像极了前面介绍的 <code>reflog</code> 的格式。实际上， <code>git stash</code> 命令就是用前面介绍的引用和引用变更日志 <code>reflog</code> 实现的：</p><p><img src="/2023/08/31/git/git_stash/stash22.png"></p><p>可以看到，在 <code>.git/refs/</code> 和 <code>.git/logs/refs</code> 目录下，都存在 <code>stash</code> 文件。</p><p>跟分支引用一样， <code>refs/stash</code> 保存的就是 <code>statsh list </code> 中最新的提交ID ，还能看到该提交的相关记录：</p><p><img src="/2023/08/31/git/git_stash/stash23.png"></p><p><strong>简单总结一下：<code>git stash</code> 保存进度，实际上会将进度保存在引用 <code>refs/stash</code> 所指向的提交中。多次的进度保存，会指向最新的保存提交ID，而 <code>refs/stash</code> 引用的变化由 <code>logs/refs/stash</code> 记录下来。</strong></p><p>那么，引用(<code>refs/stash</code>) 是怎么同时保存暂存区进度和工作区中的进度呢？我们查看一下 <code>refs/stash</code> 的提交历史 【把 <code>stash</code> 看作分支对待】：</p><p><img src="/2023/08/31/git/git_stash/stash24.png"></p><p>提交说明中的 <code>WIP ，表示 Work In Progress</code> 工作区进度，而 <code>index on master ，包含 index 字眼</code>，表示暂存区进度。而且最新的提交是一个合并提交。</p><p>下面，我们来研究一下第一次的进度保存：</p><p><img src="/2023/08/31/git/git_stash/stash25.png"></p><p><img src="/2023/08/31/git/git_stash/stash26.png"></p><p>上面显示的三个提交对应着三棵不同的树。我们先把不同的状态区分出来，用 ‘原基线’ 代表进度保存时版本库的状态，即提交ID <code>4448fe8705</code> ；用 ‘原暂存区’ 代表进度保存时暂存区的状态，即提交ID <code>16ab29038</code> ；用 ‘原工作区’ 代表进度保存时工作区的状态，即提交ID <code>d0f05c922</code> ；</p><p>现在，开始对比各种差异：</p><p>^ 用法讲解： ^2 表示中的 2 表示是第几个父提交，比如上面的 <code>stash@&#123;1&#125;</code> 表示最新的提交 ID ， <code>stash@&#123;1&#125;^2</code> ，表示其中的第二个父提交，也就是 <code>16ab29038</code>，那么  <code>stash@&#123;1&#125;^2^</code> 就表示 <code>16ab29038</code> 的父提交，也就是 <code>4448fe8705</code></p><ol><li>原基线和原暂存区的差异比较：</li></ol><p><img src="/2023/08/31/git/git_stash/stash27.png"></p><p>刚好是第一次保存时，暂存区添加了新文件 <code>hack-1.txt</code> 并在里面添加了一行 <code>hello.</code> ;(不记得可以往前面的内容再看一下)</p><ol start="2"><li>原暂存区和原工作区的差异比较：</li></ol><p><img src="/2023/08/31/git/git_stash/stash28.png"></p><p>刚好是第一次保存时，工作区的 <code> welcome.txt</code> 中添加了一行 <code>Nice to meet you.</code> ;(不记得可以往前面的内容再看一下)</p><ol start="3"><li>原基线和原工作区的差异比较：</li></ol><p><img src="/2023/08/31/git/git_stash/stash29.png"></p><p>刚好是 1 和 2 的差异汇总 。</p><p>最后，我们用 <code>stash@&#123;1&#125;</code> 来恢复进度，再清空所有保存的进度：</p><p><img src="/2023/08/31/git/git_stash/stash30.png"></p><p><img src="/2023/08/31/git/git_stash/stash31.png"></p><p>清空之后，会发现 <code>stash</code> 相关的引用和 <code>reflog</code> 的 <code>stash</code> 文件都不见了，对不找对应的文件了：</p><p><img src="/2023/08/31/git/git_stash/stash32.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 检出</title>
      <link href="/2023/08/31/git/git_checkout/"/>
      <url>/2023/08/31/git/git_checkout/</url>
      
        <content type="html"><![CDATA[<p>Git 检出</p><span id="more"></span><p>在上一节，我们使用 <code>reset</code> 命令修改了引用分支的游标位置，让分支引用(比如：<code>master</code> 分支) 指向不同的提交 <code>ID</code> ，达到切换不同历史版本内容。我们默认操作的就是 <code>master</code> 分支，因为 <code>.git/HEAD</code> 指向的引用就是 <code>refs/heads/master</code> 。怎么改变 <code>HEAD</code> 的指向呢？改变之后又有什么影响呢？下面通过 <code>checkout</code> 命令的使用来仔细分析一下。</p><p><code>HEAD</code> 的理解 ： 是头指针，当有提交时， <code>HEAD</code> 指向的提交将会作为新提交的父级提交（变成老二了，老大是新的提交） 。</p><p>首先，看一下目前 <code> HEAD</code> 指向是什么：</p><p><img src="/2023/08/31/git/git_checkout/checkout1.png"></p><p>可以看出，目前指向了分支 master ，可以通过如下命令查看目前所在分支信息：</p><p><img src="/2023/08/31/git/git_checkout/checkout2.png"></p><p>再看一下我们现有的提交记录：</p><p><img src="/2023/08/31/git/git_checkout/checkout3.png"></p><p>现在我们检出 befeee4 这个提交，看看会怎样：</p><p><img src="/2023/08/31/git/git_checkout/checkout4.png"></p><p>输出了一大段内容，大概意思如下：</p><blockquote><p>您正处于 “分离头指针” 状态，您可以检查、测试和提交而不影响任何分支。如果想保留此状态下的修改和提交，使用 <code>-c</code> 参数调用 <code>switch</code> 命令来创建新的跟踪分支。如 ：<code> git switch -c &lt;new-branch-name&gt;</code> ，您现在处于 <code>befeee4</code> ，提交说明为 <code>check staged -- nice to  meet you.</code></p></blockquote><p>查看一下此时的 <code>HEAD</code> 保存的内容：</p><p><img src="/2023/08/31/git/git_checkout/checkout5.png"></p><p>可以看到，保存的是一个具体的提交 <code>ID</code> ，而不是保存（分支）引用。</p><p>阶段性总结： “分离头指针” 状态指的就是 <code>HEAD</code> 头指针指向了一个提交 ID，而不是一个引用（分支）。</p><p>通过 <code>reflog</code> 查看日志时，也可以看到 <code>HEAD</code>  头指针更改了：由指向 <code>master</code> 分支变成了指向一个提交 <code>ID</code> 。</p><p><img src="/2023/08/31/git/git_checkout/checkout6.png"></p><p><strong>注意区分是 <code>master</code> 分支的变更还是 <code>HEAD</code> 头指针的变迁记录</strong></p><p>我们查一下当前的 <code>HEAD</code> 和 <code>master</code> 对应的提交 <code>ID</code> ，会发现它们的指向并不一样：</p><p><img src="/2023/08/31/git/git_checkout/checkout7.png"></p><p>可以看到，<code>master</code> 分支的指向并没有改变，仍旧指向原有的提交 <code>ID</code> ，这也说明了 <code>checkout</code> 命令和 <code>reset</code> 命令不同。</p><p>接下来，我们进行一些操作，分析一下输出结果 ：</p><ol><li>创建一个新文件（detached-commit.txt）并添加到暂存区中，查看一下状态：</li></ol><p><img src="/2023/08/31/git/git_checkout/checkout8.png"></p><pre><code>输出表明：当前处于 “分离头状态”，其实截图红框已经显示当前不处于任何分支中，而处于某个提交 `ID` 。</code></pre><ol start="2"><li>进行提交：</li></ol><p><img src="/2023/08/31/git/git_checkout/checkout9.png"></p><pre><code>输出表明：提交成功了，此时头指针指向了新的提交 `08b3f7e` 。</code></pre><ol start="3"><li>再次查看当前的 <code>HEAD</code> 内容：</li></ol><p><img src="/2023/08/31/git/git_checkout/checkout10.png"></p><pre><code>输出表明：仍然指向一个具体的 `ID` ，但是这个 ID 变成了最新的提交 `ID` 了，它的父 ID 是原来的 `befeee4`。在 `befeee4` 出现了分叉，分别指向 `08b3f7e` 和 `master` 分支原先的提交，因为 `08b3f7e` 本来就是 `master` 的历史提交。</code></pre><ol start="4"><li>查看一下提交日志，会发现：</li></ol><p><img src="/2023/08/31/git/git_checkout/checkout11.png"></p><pre><code>输出表明：新的提交确实是建立在之前的提交基础上的。</code></pre><ol start="5"><li>切换回到 <code>master</code> 分支 ：</li></ol><p><img src="/2023/08/31/git/git_checkout/checkout13.png"></p><pre><code>输出表明：已经切换到了 `master` 分支，但是在分离头状态有一个提交，最好通过 `branch` 命令给这个提交创建一个新分支。</code></pre><ol start="6"><li>再次查看当前的 <code>HEAD</code> 内容：</li></ol><p><img src="/2023/08/31/git/git_checkout/checkout14.png"></p><pre><code>输出表明：变回 `master` 引用 ，而不是具体提交 `ID` 了。</code></pre><ol start="7"><li>查询一下当前的提交历史：</li></ol><p><img src="/2023/08/31/git/git_checkout/checkout15.png"></p><pre><code>输出表明：完全是之前 master 的提交历史了，之前在分离头状态的提交查不到了，新增的文件也不见了。</code></pre><p>我们之前在分离头状态的提交还存在于版本库的对象库中吗？</p><p>我们验证一下：</p><p><img src="/2023/08/31/git/git_checkout/checkout16.png"></p><p>可以看到这个提交仍在版本库中。<br><strong>注意：由于这个提交没有被任何分支跟踪，因此并不能保证这个提交会永久存在。实际上当 reflog 中含有该提交的日志过期后，这个提交随时都会从版本库中移除</strong>。</p><p>因为没有给提交 <code>ID</code> （<code>08b3f7e</code>）创建分支来跟踪，所以不能通过分支引用来访问，而且随时可能被清除（实际项目中要新建分支来追踪），非常不方便。</p><p>如果这个提交是 <code>master</code> 分支所需要的，怎么办呢？</p><p>答：不能用 <code>reset</code> 命令，那样会丢掉 <code>master</code> 分支原来的提交，相当于现在历史链条中存在了分叉路，只能使用 <code>merge</code> 命令进行合并操作。</p><p>方案确认了，开始进行具体的合并操作：</p><p><img src="/2023/08/31/git/git_checkout/checkout17.png"></p><p>先确认了当前处于哪个分支，接着进行 <code>merge</code> 操作，然后查看了文件列表和提交日志。日志表明出现了分叉，<code>31ab701</code> 在<code> master</code> 分支，<code>08b3f7e</code> 在分离头状态下提交的，最终在合并在新的提交 ID <code>4448fe87</code> 中 。</p><p>如果仔细查看一下最新提交，会发现这个提交有两个父提交，这就是合并的奥秘：</p><p><img src="/2023/08/31/git/git_checkout/checkout18.png"></p><p>最后，我们再深入了解一下 <code>git checkout</code> 命令：</p><ol><li><p><code>git checkout &lt;branch&gt;</code></p><p>这种用法会改变 <code>HEAD</code> 头指针，通过切换分支来对提交进行跟踪，主要作用就是切换分支。</p></li><li><p><code>git checkout [-m] [-b|--orphan &lt;new_branch&gt;] [start_point]</code></p><p> 这种用法主要是创建并切换到新的分支，新的分支从 <code>start_point</code> 指定的提交开始创建(默认从最新提交开始)。新分支和 <code>master</code> 分支没有什么不一样的，都是 <code>refs/heads</code> 命名空间下的引用。</p></li><li><p><code>git checkout branch</code> </p><p> 检出 <code>branch</code> 分支 ，更新 <code>HEAD</code> 指向 <code>branch</code> 分支，以及用 <code>branch</code> 指向的树更新暂存区和工作区。</p></li><li><p><code>git checkout -- filename</code> </p><p> 用暂存区中的 <code>filename</code> 文件覆盖工作区中的 <code>filename</code> 文件 。相当于取消自上次执行 <code>git add filename</code> 以来的本地修改。</p></li><li><p><code>git checkout branch -- filename</code></p><p><code>HEAD</code> 的指向不变，用 <code>branch</code> 所指向的分支的提交中的 <code>filename</code> 文件替换暂存区和工作中相应的文件，会直接覆盖掉。</p></li><li><p><code>git checkout .</code> </p><p> 这条命令比较危险，会直接取消本地的所有修改，相当于用暂存区的所有文件直接覆盖本地文件，不给用户任何确认的机会！</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 重置</title>
      <link href="/2023/08/31/git/git_reset/"/>
      <url>/2023/08/31/git/git_reset/</url>
      
        <content type="html"><![CDATA[<p>Git 重置</p><span id="more"></span><p>首先，我们看一下版本库提交历史记录：</p><p><img src="/2023/08/31/git/git_reset/reset1.png"></p><p>通过 <code>--oneline</code> 可以显示更短小的提交 <code>ID</code> 。</p><p>如果我们改变了分支文件中记录的提交 <code>ID</code> ，是不是就可以实现任意提交历史的内容切换呢？是的 ，接下来通过研究 <code>git reset</code> 命令来改变分支引用文件的提交 <code>ID</code>，实现分支内容的重置。</p><p>那么，开始操作吧，先看看现在分支中指向的提交 <code>ID</code> 是什么：</p><p><img src="/2023/08/31/git/git_reset/reset2.png"></p><p>正是我们第二次提交的 <code>ID</code> 。</p><p>接下来我们创建一个文件，再进行一次提交，看看 <code>master</code> 分支会不会自动指向最新的提交 <code>ID</code> ：</p><p><img src="/2023/08/31/git/git_reset/reset3.png"></p><p>果然指向了最新的提交 <code>ID</code> 。</p><p><strong><code>master</code> 就像一个游标，可上下浮动，最上方就是指向最新的提交 ID ，向下就可以指向历史提交了，而改变这个游标位置的命令就是 reset 命令</strong>。</p><p><code>reset</code> 命令会有一些参数，接下来会细讲。</p><p>我们可以通过 <code>reset</code> 回到上一次的提交记录，如下：</p><p><img src="/2023/08/31/git/git_reset/reset4.png"></p><p>输出表明，确实回到上一次提交了，最新的提交记录和文件都不见了。</p><p>其实我们可以通过提交 <code>ID</code> 来重置到任意提交记录，我们重置到初始的提交记录试试：</p><p><img src="/2023/08/31/git/git_reset/reset5.png"></p><p>重置成功了， <code>welcome.txt</code> 文件内容只有 <code> Hello.</code>  了 。</p><p>注意：重置后，历史记录也被丢弃了，通过 <code>git log</code> 命令查询到的历史记录只能从当前的记录到以前的记录，比如现在我们查询到的历史记录只有一条了。</p><p>那我们怎么重置到最近的提交记录呢？</p><p>答：还有一个挽救机制，通过 <code>.git/logs</code> 目录下的日志文件，该日志文件记录了分支的各种变更。**</p><p>我们通过 <code>tail</code> 命令查看一下最后5行的文件内容：</p><p><img src="/2023/08/31/git/git_reset/reset6.png"></p><p>最新的变更是追加到后面的，这个日志文件很明确地显示了提交 <code>ID</code> 的变动以及变动原因，是 <code>commit</code> 还是 <code>reset</code> 还可能是其他的原因。</p><p>通过 <code>git reflog</code> 命令也可以对这个文件进行操作，使用 <code>show</code> 子命令可以显示文件内容：</p><p><img src="/2023/08/31/git/git_reset/reset7.png"></p><p>与通过 <code>tail</code> 直接查询文件内容不同，最新的改变是显示到最前面的，而且只显示每次操作后的最终的提交 <code>ID</code> ，还有一个容易记忆的 <code>&lt;refname&gt;@&#123;n&#125;</code> 表达式代表指向的提交 <code>ID</code> ，这里的 <code>refname</code> 代表的引用名，这里是 <code>master</code> 。 <code>master@&#123;2&#125;</code> 代表 <code>31ab701</code></p><p>现在，我们回到最新的提交：</p><p><img src="/2023/08/31/git/git_reset/reset8.png"></p><p>工作区中新增的文件回来了，提交历史也回来了。如果此时我们通过 <code>reflog</code> 查看，就会看到恢复 <code>master</code> 的操作也记录在日志中了：</p><p><img src="/2023/08/31/git/git_reset/reset9.png"></p><p>reset 命令是常用的命令之一，同时也是最危险最容易误用的命令，常用用法如下：</p><p> <code>git reset [ --soft | --mixed | --hard ] [commit]</code></p><ol><li><p>使用参数 <code>--soft</code> ，如： git reset –soft [commit] ，会有如下改动：</p><p><strong>替换引用，指向目标记录ID 。不改变暂存区和工作区。</strong></p></li><li><p>使用参数 <code>--mixed</code> 或不使用参数（默认就是 <code>--mixed</code>），如： <code>git reset --mixed [commit]</code> ，会有如下改动：</p><p><strong>替换引用，指向目标记录ID 。替换暂存区，暂存区的内容和引用指向的目录树内容一致。但不改变工作区。</strong></p></li><li><p>使用参数 <code>--hard</code>  ，如： <code>git reset --hard [commit]</code> ，会有如下改动：</p><p><strong>替换引用，指向目标记录ID 。替换暂存区，暂存区的内容和引用指向的目录树内容一致。并且替换工作区，工作区和暂存区和引用指向的目录树内容一致。</strong></p></li></ol><p>最后，我们再看一下 <code>reset</code> 命令的不同用法：</p><ul><li><p>命令： <code>git reset</code> ，相当于 <code>git reset HEAD</code> ，相当于 <code>git reset --mixed HEAD</code> </p><p>仅用 <code>HEAD</code> 指向的目录树重置暂存区、工作区不受影响，相当于之前用 <code>git add</code> 命令添加到暂存区的内容撤出暂存区。引用的提交 <code>ID</code> 不变。</p></li><li><p>命令：<code>git reset -- filename</code> ，相当于 <code>git reset HEAD --filename</code> </p><p>仅将文件 <code>filename</code> 的改动撤出暂存区，其他文件不变。相当于命令 <code>git add filename</code> 的反向操作 。</p></li><li><p>命令：<code>git reset HEAD^</code> ，相当于 <code>git reset --mixed HEAD^</code> 。</p><p>工作区不改变，但是暂存区会回退到上一次提交之前，引用也会回退到上一次 。</p></li><li><p>命令：<code>git reset --hard HEAD^ </code></p><p>工作区、暂存区和引用全都回退到上一次提交的状态，最新的提交内容全部丢掉 。</p></li></ul><p><strong>其他知识：<code>.git/COMMIT_EDITMSG</code>  文件保存了目前最新的提交描述说明，当前提交说明如下：</strong></p><p><img src="/2023/08/31/git/git_reset/reset10.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 对象</title>
      <link href="/2023/08/31/git/git_object/"/>
      <url>/2023/08/31/git/git_object/</url>
      
        <content type="html"><![CDATA[<p>Git 对象</p><span id="more"></span><p>我们先查看一下当前最新的提交日志(<code>-1</code> 表明最新一条，<code>--pretty=raw</code> 表示详细输出 )：</p><p><img src="/2023/08/31/git/git_object/object1.png"></p><p>一个提交包含三个哈希值：</p><ul><li><p>commit ： 表示这是本次提交的唯一标识。</p></li><li><p>tree ： 表示这是本次提交所对应的目录树。</p></li><li><p>parent ： 表示本地提交的父提交（上一次提交）。</p></li></ul><p>可以通过 <code>git cat-file -t</code> 命令查看 <code>ID</code> 的类型 ：</p><p><img src="/2023/08/31/git/git_object/object2.png"></p><p>在引用对象 <code>ID</code> 时，可以不写全 40 位，只要开头几位不冲突即可。</p><p>可以通过 <code>git cat-file -p</code> 命令 查看 <code>ID</code> 的内容 ：</p><p><img src="/2023/08/31/git/git_object/object3.png"></p><p>接着，我们查看当前 <code>tree ID</code> 的内容 ：</p><p><img src="/2023/08/31/git/git_object/object4.png"></p><p>根据 <code>tree ID</code> 的内容可知道具体保存的内容的 <code>ID</code> ，我们查看这个内容 <code>ID</code>（应该是一个类似指针一样的，指向具体保存的内容）：</p><p><img src="/2023/08/31/git/git_object/object5.png"></p><p>里面的内容就是我们第二次提交的 <code>welcome.txt</code> 文件保存的内容。（每次提交涉及到的文件的最新内容都会被保存在当前提交中，用于文件恢复和对比等操作）</p><p>我们再查一下最初提交的内容（在这里刚好是 <code>perent ID</code> 的内容）：</p><p><img src="/2023/08/31/git/git_object/object6.png"></p><p>很清楚，我们第一次提交的 <code>welcome.txt</code> 文件内容就是 <code>Hello.</code></p><p>这些文件内容都保存在 <code>.git/objects</code> 目录下，<code>ID</code> 前两位做为目录名，后 38 位作为文件名。</p><p><img src="/2023/08/31/git/git_object/object7.png"></p><p>阶段性总结：文件树中记录了当前提交的各个文件的修改信息，通过 <code>ID</code> 找到 <code>.git/objects</code> 下对应的文件内容。</p><p>在上一节，我们通过 <code>git stash</code> 来保存了我们修改的内容，工作区中干净的，用【精简并显示分支】的形式查看状态看看：</p><p><img src="/2023/08/31/git/git_object/object8.png"></p><p>也可以通过<code> git branch</code> 命令来查看当前工作的分支，星号表示这个分支是当前分支，目录暂无其他分支（分支内容后面再介绍）。</p><p><img src="/2023/08/31/git/git_object/object9.png"></p><p>输出表明，我们现处于 <code>master</code> 分支中，这是什么意思呢？暂时先不管，我们运行以下三个命令来看下结果是什么：</p><p><img src="/2023/08/31/git/git_object/object10.png"></p><p>输出表明，在当前版本库中，<code>HEAD</code> 、<code>master</code> 和 <code>refs/heads/master</code> 具有相同的指向。</p><p><img src="/2023/08/31/git/git_object/object11.png"></p><p>通过上述命令，我们知道了 <code>HEAD</code> 和 <code>master</code>  的文件路径，<code>logs</code> 目录下的文件暂不研究。</p><p>那么 <code>HEAD</code> 和 <code>master</code> 保存的内容是什么呢？</p><p><img src="/2023/08/31/git/git_object/object12.png"></p><p>总结：</p><ol><li><p><code>HEAD</code> 保存的其实是指向的一个引用，这个引用就是当前的分支，现在指向的分支是  <code>.git/refs/heads/master</code> ，分支名叫 <code>master</code> ，所以 <code>git log -1 refs/heads/master</code> 和 <code>git log -1 master</code> 是等价的，后者只是简写而已。后续如果有不同的分支，每个分支会生成一个文件保存在这个目录下。</p></li><li><p>分支文件保存的内容是当前分支最新的提交 <code>ID</code> ，根据该 <code>ID</code> 可以查到最新的提交记录，而根据记录的 <code>parent ID</code> 可以知道上一次提交记录，这样就能追踪到完整的提交历史记录链，真的是相当巧妙！</p></li></ol><p>如下是一个更接近于真实的版本库结构图：</p><p><img src="/2023/08/31/git/git_object/object13.png"></p><p>其实 Git 还有一个命令可以用于显示对应的提交 ID ，如下：</p><p><img src="/2023/08/31/git/git_object/object14.png"></p><p> Git 中提供了很多方法可以方便地访问库中的对象：</p><p><img src="/2023/08/31/git/git_object/object15.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 暂存区</title>
      <link href="/2023/08/31/git/git_staged/"/>
      <url>/2023/08/31/git/git_staged/</url>
      
        <content type="html"><![CDATA[<p>Git 暂存区</p><span id="more"></span><p>可以用 <code>git log</code> 查看提交日志，加上 <code>--stat</code> 参数可以看到每次提交的文件变更统计 。</p><p><img src="/2023/08/31/git/git_staged/stash1.png"></p><p>在 <code>welcome.txt</code> 中添加一行 <code>Nice to meet you.</code> 。然后通过 <code>git diff</code> 来对比修改后的文件和中间状态的文件的差别。</p><p><img src="/2023/08/31/git/git_staged/stash2.png"></p><p>现在提交试试：</p><p><img src="/2023/08/31/git/git_staged/stash3.png"></p><p>输出表示：提交失败，没有需要提交的文件。</p><p>假设提交成功，会有新的提交记录，通过日志【精简显示】 ： <code>git log --pretty=oneline</code> 可知，只有之前提交的一条记录，证明没提交成功 。</p><p><img src="/2023/08/31/git/git_staged/stash4.png"></p><p>通过 <code>git status</code> 查看状态，发现输出和使用 <code>git commit</code> 命令是一样的：</p><p><img src="/2023/08/31/git/git_staged/stash5.png"></p><p>查看状态【精简显示】： <code>git status -s</code> 可知，<code> welcome.txt</code> 文件被修改了。</p><p><img src="/2023/08/31/git/git_staged/stash6.png"></p><p>我们再仔细查看一下上述 <code>git status</code> 命令的输出内容：需要对修改的 <code>welcome.txt</code> 文件执行 <code>git add</code> 操作，将修改的文件添加到 “提交任务”中，才能提交！</p><p>那么，按照要求来：</p><p><img src="/2023/08/31/git/git_staged/stash7.png"></p><p>接着再 <code>git diff</code> 对比一下，发现没有任何输出：</p><p><img src="/2023/08/31/git/git_staged/stash8.png"></p><p>注意：我们并没有提交代码，只是将这个文件标记为了等待提交状态。</p><p> <strong>为什么没有任何输出呢？？？</strong></p><p><strong>答：因为 <code>git diff</code> 默认对比的是本地文件【工作区】和中间状态【暂存区】的差异，我们已经通过 <code>git add</code> 更新了暂存区文件了，因此两者文件一致了，就没有任何差异了。</strong></p><p>如果我们通过与 <code>HEAD</code>（当前版本库的头指针）或 <code>master</code> 分支（当前工作分支）进行比较，就会发现有差异，毕竟还没提交嘛：</p><p><img src="/2023/08/31/git/git_staged/stash9.png"></p><p>我们再通过 <code>git status</code> 查看一下状态：</p><p><img src="/2023/08/31/git/git_staged/stash10.png"></p><p>输出明确表示了，文件可以被 <code>commit</code> 了，而且还可以通过 <code>restore</code> 命令从暂存区中撤回。</p><p>如果查看状态【精简显示】： <code>git status -s</code> ，是这样显示的：</p><p><img src="/2023/08/31/git/git_staged/stash11.png"></p><p>跟之前没加入暂存区的状态比较一下：</p><p><img src="/2023/08/31/git/git_staged/stash12.png"></p><p>我们发现有如下几点是不一样的 ：</p><ol><li><p>颜色输出是不一样，没加入暂存区的时候是红色的，加入之后是绿色的。</p></li><li><p><code>M</code> 的位置不一样，没加入之前，前面还有一个空格，加入之后是在首列，没有空格。</p></li></ol><p>继续来操作，在 <code>welcome.txt</code> 中再加入一行：</p><p><img src="/2023/08/31/git/git_staged/stash13.png"></p><p> 查看一下状态 <code>git status</code> :</p><p><img src="/2023/08/31/git/git_staged/stash14.png"></p><p> 再查看一下精简状态 <code>git status -s</code> :</p><p><img src="/2023/08/31/git/git_staged/stash15.png"></p><p>怎么理解同一个文件即有红色的输出，也有绿色的输出呢？</p><p>可以这样理解：工作区中的文件跟暂存区中的对比，工作区的文件有修改（红色输出），暂存区中的文件跟版本库中的文件对比也有修改（绿色输出）。</p><p>现在 <code>welcome.txt</code> 有三个不同的版本，一个在工作区，一个在等待提交的暂存区，一个是版本库中最新的版本，我们可以通过 <code>git diff</code> 命令再加上不同的参数来查看不同状态下的差异：</p><ol><li>不带任何参数，对比的是工作区与暂存区的差异：</li></ol><p><img src="/2023/08/31/git/git_staged/stash16.png"></p><p>输出说明 ： 工作区比暂存区多了一行 <code>Bye Bye.</code></p><ol start="2"><li>加上 HEAD ，对比的是工作区跟版本库当前工作分支：</li></ol><p><img src="/2023/08/31/git/git_staged/stash17.png"></p><p>输出说明 ： 工作区的比版本库当前工作分支多了两行 </p><pre><code>  Nice to meet you.  Bye Bye.</code></pre><ol start="3"><li>加上 <code>--cached</code> 或 <code>--staged</code> ，对比的是暂存区和版本库当前工作分支：</li></ol><p><img src="/2023/08/31/git/git_staged/stash18.png"></p><p>输出说明 ： 暂存区的比版本库当前工作分支多了一行 <code>Nice to meet you.</code></p><p>最后，我们进行提交，将暂存区的内容提交到版本库中，工作区的修改是不会被提交的，因为现在只将改动 <code>Nice to  meet you</code> 提交到了暂存区，<code>Bye Bye</code> 还是在工作区中的，并不会被提交。</p><p><img src="/2023/08/31/git/git_staged/stash19.png"></p><p>显示提交成功，根据描述，有一个文件改动了，插入了一行，正是 <code>Nice to  meet you</code> 这一行。</p><p>查看一下【精简日志】看看：</p><p><img src="/2023/08/31/git/git_staged/stash20.png"></p><p>查看精简【精简状态】看看：</p><p><img src="/2023/08/31/git/git_staged/stash21.png"></p><p>只看到一个没有提交到暂存区的提示了。因为<code> Bye Bye.</code> 这一行内容还在工作区中，并没提交到暂存区。</p><p>对比一下差异看看：</p><p><img src="/2023/08/31/git/git_staged/stash22.png"></p><p>跟我们分析的一模一样的。</p><p>下图展示简化后的工作区、版本库的暂存区和版本库之间的关系：</p><p><img src="/2023/08/31/git/git_staged/stash37.png"></p><p> 休息一下，继续操作：</p><ol><li>通过 <code>checkout</code> 命令，撤销工作区中 <code>welcome.txt</code> 文件的修改 ：</li></ol><p><img src="/2023/08/31/git/git_staged/stash23.png"></p><p>可以看到工作区非常干净，没有任何改动了。上述操作其实是用暂存区中的 <code>filename</code> 文件覆盖掉工作区中的 <code>filename</code> 文件 。那么还没 <code>add</code> 的修改肯定就没了。</p><ol start="2"><li>查看一下 <code>.git/index</code> 文件，特别注意一下时间：</li></ol><p><img src="/2023/08/31/git/git_staged/stash24.png"></p><ol start="3"><li>现在更改一下时间戳，但是不改变它的内容，再次查看时间：</li></ol><p><img src="/2023/08/31/git/git_staged/stash25.png"></p><p> 上述操作表明：工作区扫描改动的时候，是根据 <code>.git/index</code> 文件中记录的时间、长度等信息判断工作区文件是否改变的。如果改变了，说明文件的内容可能也被改变了，再打开文件读取文件内容，与更改前的原始文件相比较，判断文件内容是否更改，同时该文件的新的时间戳会被记录到 <code>index</code> 文件中，这样扫描会更高效。</p><p><code> .git/index</code> 文件：是一个包含文件索引的目录树，记录了文件名和文件的状态信息，文件的内容并没有存储在其中，而是保存在 <code>.git/objects</code> 目录中，文件索引建立了文件和对象库中对象实体之间的对应。</p><p>总结： 可以理解为有一个工作区目录，一个暂存区虚拟目录，一个版本库目录，工作区目录的文件需要先添加到暂存区，暂存区的内容需要提交到版本库。其中工作区可能存在未添加的文件，暂存区可能存在未提交的文件，<code>git</code> 的各种命令就是操作它们之间的文件、对文件进行覆盖、恢复、撤回等操作。</p><p>版本库中的目录树查看：</p><p><img src="/2023/08/31/git/git_staged/stash26.png"></p><p>从左到右分别显示的是：文件属性、<code>blob</code> 对象、<code>ID</code>(SHA1哈希值格式)、文件大小、文件名。</p><p>我们先清除工作区当前的改动： <code>git clean -fd</code>  ，然后用暂存区的内容覆盖工作区 :  <code>git checkout .</code>  ，接着，创建 <code>a/b/c/hello.txt</code> 文件并创建相应文件夹 ，并在 <code>welcome.txt</code> 中增加一行 <code>Bye Bye.</code></p><p>现在对比一下跟暂存区的差异：</p><p><img src="/2023/08/31/git/git_staged/stash27.png"></p><p>可以看出，确实在<code> welcome.txt</code> 中增加一行 <code>Bye Bye.</code> ，但是没有显示出新的 <code>hello.txt</code> 文件，因为新文件是没被追踪的，所以无法对比，我们用 <code>git status</code> 查看一下状态就能知道：</p><p><img src="/2023/08/31/git/git_staged/stash28.png"></p><p><img src="/2023/08/31/git/git_staged/stash29.png"></p><p>输出表明，连第一层的 <code>a</code> 文件夹都没识别出来，更别说里面的文件了。</p><p>我们用 <code>git add .</code> 一次性将没被追踪的文件添加到暂存区，再次查看状态：</p><p><img src="/2023/08/31/git/git_staged/stash30.png"></p><p>我们再在 <code>hello.txt</code> 中增加一行 <code>Bye Bye.</code>  ，看一下状态：</p><p><img src="/2023/08/31/git/git_staged/stash31.png"></p><p>目前为止，我们知道现在工作区、暂存区和版本库之差的内容是有差异的。</p><ul><li>对比工作区和暂存区，可知工作区的 <code>hello.txt</code> 文件增加了一行 <code>Bye Bye.</code></li></ul><p><img src="/2023/08/31/git/git_staged/stash32.png"></p><ul><li>对比暂存区和版本库，可知暂存区增加了 <code>hello.txt</code> 文件，<code>welcome.txt</code> 增加了一行<code> Bye Bye.</code></li></ul><p><img src="/2023/08/31/git/git_staged/stash33.png"></p><ul><li>对比工作区和版本库，可知工作区增加了 <code>hello.txt</code> 文件 ，并添加了一行<code> Bye Bye.</code> ，welcome.txt 文件新增加了一行 <code>Bye Bye.</code></li></ul><p><img src="/2023/08/31/git/git_staged/stash34.png"></p><p> 最后，我们将保存当前的工作进度，在研究了 <code>HEAD</code> 和 <code>master</code> 分支的机制之后，再继续对暂存区进行研究。</p><p><img src="/2023/08/31/git/git_staged/stash35.png"></p><p><img src="/2023/08/31/git/git_staged/stash36.png"></p><p>现在，工作区和暂存区的改动全都不见了，干干净净。（暂存的内容为添加了 <code>a/b/c/hello.txt</code> 文件，并添加了一行 <code>Bye Bye.</code> ，<code>welcome.txt</code> 文件新增了一行 <code>Bye Bye.</code>）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 初识</title>
      <link href="/2023/08/30/git/git_start/"/>
      <url>/2023/08/30/git/git_start/</url>
      
        <content type="html"><![CDATA[<p>Git 初识</p><span id="more"></span><p><strong>查看版本：</strong> <code>git --version</code></p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start1.png?raw=true"></p><p><strong>查看配置列表：</strong> <code>git config --list</code></p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start2.png?raw=true"></p><p><strong>配置用户名和邮箱地址：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;fanda&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;xxxx.com&quot;</span><br></pre></td></tr></table></figure><p><strong>单独查询某条配置，比如：</strong></p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start3.png?raw=true"></p><p><strong>开始详细操作演示：</strong></p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start4.png?raw=true"></p><p>**操作文件夹为: ** <code>e/git_study/demo</code></p><p>通过 <code>git init</code> 命令来初始化版本库，默认会在工作区创建一个隐藏目录 <code>.git</code>  ，这个 <code>.git</code> 就是版本仓库 ，可通过 <code>ls -a</code> 查看隐藏的目录。</p><p>现在 <code>demo</code> 目录就是工作区，目前除了 <code>.git</code> 目录外空无一物。</p><p>我们添加一个文件 <code> welcome.txt</code> 并编辑内容为 <code>Hello.</code></p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start5.png?raw=true"></p><p>可通过 <code>git status</code> 来查看当前工作区的状态如下：</p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start6.png?raw=true"></p><p>输出表示，没有任何内容可提交，但是出现了未被追踪的文件，应该先通过 <code>git add</code> 将文件追踪。</p><p><strong>添加并提交文件：</strong></p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start7.png?raw=true"></p><p><strong>提交结果说明：</strong></p><ol><li><p>第一行: 在名为 <code>master</code> 的分支上，且是该分支的第一个提交( <code>root-commit</code> ) ，提交 <code>ID</code> 为 <code>174d90b</code> ，提交描述为 <code>initialized.</code> 。</p></li><li><p>第二行: 提交修改了一个文件，包含一行插入。</p></li><li><p>第三行：此次提交创建了新文件 <code>welcome.txt</code> 。</p></li></ol><p><strong>阶段性总结：<code>.git</code> 所在目录就是工作区的根目录，<code>git</code> 的相关操作要在工作区中才能正常执行，当在工作区的子目录中操作时，会递归查找 <code>.git</code> 目录。</strong></p><p><strong>如果在工作区外操作，会报错：</strong></p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start8.png?raw=true"></p><p>可通过 <code>git rev-parse --git-dir</code> 命令来查看 <code>.git</code> 所在的目录 ：</p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start9.png?raw=true"></p><p>可通过 <code>git rev-parse --show-toplevel</code> 命令来查看工作区根目录：</p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start10.png?raw=true"></p><p>可通过 <code> git clone</code> 命令来备份仓库 ：</p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start11.png?raw=true"></p><p>如上，我们把 <code>demo</code> 备份为了名为 <code>demo-step-1</code> 的文件夹。</p><p><strong>注意：备份时，目录路径为 <code>git_study</code> ，而不是 <code>demo</code> ，是 <code>demo</code> 的上一级 。</strong></p><p><strong>三个不同级别的配置文件：</strong></p><ul><li><p>版本库的配置文件：就是当前工作区的 <code>.git/config</code> 文件 。 <code>git config -e</code> 命令可查看 , <code>:wq</code> 退出编辑，注意先输入冒号。</p></li><li><p>全局配置文件：用户主目录下的 <code>.gitconfig</code> 文件 。 <code>git config -e --global</code> 命令可查看 , <code>:wq</code> 退出编辑，注意先输入冒号。</p></li><li><p>系统级配置文件： <code>/etc</code> 目录下。命令 <code>git config -e --system</code> 可查看 , <code>:q</code> 退出编辑，注意先输入冒号，系统文件不可写。</p></li></ul><p><strong>配置文件生效优先级：版本库级别的配置文件的优先级最高，全局配置文件次之，系统级配置文件排最后。相同的配置按优先级进行覆盖。</strong></p><p><strong>总结：版本创建三部曲，<code>git init</code> 、<code>git add</code> 、<code>git commit</code> 。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo命令使用</title>
      <link href="/2023/08/30/hexo-use/"/>
      <url>/2023/08/30/hexo-use/</url>
      
        <content type="html"><![CDATA[<p>hexo命令使用</p><span id="more"></span><ol><li><p>hexo s或hexo server  : 启动服务，默认地址为<a href="http://localhost:4000/%EF%BC%8C4000%E7%AB%AF%E5%8F%A3">http://localhost:4000/，4000端口</a></p></li><li><p>hexo d或hexo deploy  : 部署站点，在本地生成.deploy_git文件夹，并将编译后的文件上传至 GitHub。</p></li><li><p>hexo new xxx pagename  : 例如： hexo new photo “my-first-blog” 上述指令执行时，Hexo 会尝试在 scaffolds 中寻找photo.md布局，若找到，则根据该布局新建文章；若未找到或指令中未指定该参数，则使用post.md新建文章。新建文章的名称在_config.yml中配置。</p></li><li><p>hexo clean   : 将 public 文件夹删除</p></li><li><p>hexo g或hexo generate  ：该命令执行后在hexo站点根目录下生成public文件夹</p></li><li><p>可以这样创建指定目录下的文件 ： hexo new page -p git&#x2F;git_start</p></li><li><p>hexo g -d ： 可以这样一步生成并部署</p></li><li><p>图片使用： 创建文章时，会默认创建图片对应的文件夹。将文件放在里面即可。随后直接引用图片就可以在文章中显示了。之后，上传部署到远程，找到对应的图片地址后再拼接?raw&#x3D;true ，比如：<br>“<a href="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start1.png?raw=true&quot;">https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start1.png?raw=true&quot;</a> ，就能正常使用了远程地址而不是本地地址了。</p></li><li><p>E:\blog\scaffolds 下的文件可以定义文章模板，也就是创建文章时的默认显示。</p></li></ol><p>主题使用如下：<br>    E:\blog\themes\hexo-theme-ocean\source\css_partial 目录下：</p><pre><code>1. \gallery.styl  该文件下的样式可以修改博客首页面文章列表展示样式2. \tocbot.styl   该文件下的样式修改文章内的右侧菜单样式3. \article.styl  该文件下的样式修改文章详情的样式E:\blog\themes\hexo-theme-ocean\source\css下的 _variables.styl 样式修改全局的变量值</code></pre><p>文章布局如下： </p><hr><p>title: livedata<br>date: 2022-06-06 14:23:54<br>&#x2F;&#x2F; 标签<br>tags: jetpack android<br>&#x2F;&#x2F; 是否置顶<br>&#x2F;&#x2F; 是否生成文章目录，默认根据 md 样式在右边生成显示<br>top: ture<br>toc: ture<br>&#x2F;&#x2F; 这是封面图片<br>photos: [<br>        [“<a href="https://github.com/liuhangya/liuhangya.github.io/blob/main/gallery/index/juanjuan01.jpg?raw=true&quot;%5D">https://github.com/liuhangya/liuhangya.github.io/blob/main/gallery/index/juanjuan01.jpg?raw=true&quot;]</a><br>]</p><hr><p>这是显示在文章列表中的概要</p><!--more-->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 架构演进分析和代码演示</title>
      <link href="/2023/08/29/android/architecture/architecture/"/>
      <url>/2023/08/29/android/architecture/architecture/</url>
      
        <content type="html"><![CDATA[<p>架构演进分析和代码演示</p><span id="more"></span><h2 id="一、架构的使命和目的"><a href="#一、架构的使命和目的" class="headerlink" title="一、架构的使命和目的"></a>一、架构的使命和目的</h2><ol><li>架构的首要技术使命是“管理复杂度”，低复杂度才能降低理解成本和沟通难度，提升应对变更的灵活性，减少重复劳动，最终提高代码质量。</li><li>架构的目的在于“将复杂度分层”，不要将复杂度会在同一层次展开，那样会形式所谓的上帝类【比如，超1000行代码的Activity】。将复杂度会层，每一层功能独立且单一职责，这样才能尽可能地减少因为改动而导致的影响面。</li><li>为了降低客户端领域开发的复杂度，架构也在不断地演进。从 MVC 到 MVP，再到 MVVM，目前已经发展到 MVI。</li></ol><h2 id="二、MVC-架构"><a href="#二、MVC-架构" class="headerlink" title="二、MVC 架构"></a>二、MVC 架构</h2><ol><li><p>说明：模型（Model）、视图（View）、控制器（Controller）</p><p> 视图层：Android的xml布局文件和Activity&#x2F;Fragment文件被划分为View视图层。 因为xml作为视图层功能太弱，只能够实现页面的布局，不能够实现页面数据和事件的处理，需要和Activity一起才能够构成一个完整的视图层。</p><p> 业务层：大多数的MVC架构开发的安卓项目，并没有把Controller业务层独立出来，而是将业务层也在Activity&#x2F;Fragment中实现。这导致了Activity&#x2F;Fragment的代码非常臃肿，【比如，超1000行代码的Activity】。</p><p> 数据层：数据管理模块，这包括了数据的获取，加工、存储等。</p></li></ol><h3 id="实现代码说明："><a href="#实现代码说明：" class="headerlink" title="实现代码说明："></a>实现代码说明：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 描述：最早的传统 MVC 架构功能实现，这里模拟一个 登录 功能，输入账号密码，点击登录按钮，底部显示登录状态文本</span><br><span class="line"> */</span><br><span class="line">class MVCActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">  private lateinit var binding: ActivityMvcBinding</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 描述：M 层，用于处理数据</span><br><span class="line">  */</span><br><span class="line">  private val model = Model()</span><br><span class="line"></span><br><span class="line">  override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    binding = ActivityMvcBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">    // 登录按钮事件</span><br><span class="line">    binding.btnLogin.setOnClickListener &#123; login(binding.etAccount.text.toString(), binding.etPassword.text.toString()) &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 描述：登录，这里将本该放在独立业务层的，放在 V 层，把 Activity 当作 C 层用，用的时候确实方便，但是当功能非常复杂时，该类会非常臃肿，复杂度在该类</span><br><span class="line">   * 直接铺开，因为高度的耦合，不利用于代码复用，难以维护，修改容易出 bug</span><br><span class="line">   */</span><br><span class="line">  private fun login(account: String, password: String) &#123;</span><br><span class="line">    // 调用 M 层的方法获取结果</span><br><span class="line">    val success = model.login(account, password)</span><br><span class="line">    // 根据结果来渲染页面</span><br><span class="line">    binding.tvLoginResult.text = if (success) &quot;登录成功！&quot; else &quot;登录失败！&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 描述：模型层，用于数据获取、加工等</span><br><span class="line"> */</span><br><span class="line">class Model &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 描述：这里模拟一下登录成功或失败</span><br><span class="line">   */</span><br><span class="line">  fun login(account: String, password: String) =</span><br><span class="line">    account.isNotEmpty() &amp;&amp; password.isNotEmpty() &amp;&amp; account == &quot;123&quot; &amp;&amp; password == &quot;123&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、MVP-架构"><a href="#三、MVP-架构" class="headerlink" title="三、MVP 架构"></a>三、MVP 架构</h2><ol><li><p>说明：模型（Model）、视图（View）、业务逻辑层（Presenter）</p><p> 视图层：Android的xml布局文件和Activity&#x2F;Fragment文件被划分为View视图层。 因为xml作为视图层功能太弱，只能够实现页面的布局，不能够实现页面数据和事件的处理，需要和Activity一起才能够构成一个完整的视图层。</p><p> 业务层：Presenter 对象用于业务层，对逻辑进行处理，内部通过数据层来访问数据。使得界面绘制和业务逻辑分开，降低了它们的耦合，形成相互独立的界面层 V 和业务逻辑层 P。通过接口实现界面层和业务逻辑层的双向通信，界面层通过业务接口向业务逻辑层发起请求。业务逻辑层通过 View 层接口指导界面绘制。接口是一种抽象手段，它把做什么和怎么做分离，为发生多态提供了便利。</p><p> 数据层：数据管理模块，这包括了数据的获取，加工、存储等。</p></li></ol><p>由上述分析可知，V 层的业务逻辑处理给到了 P 层，所以 V 层更加单纯了，也没那么臃肿了，复杂度也降低了，跟 M 和 P 层的耦合度都降低了。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li>因为 View 层接口的存在，迫使 Presenter 得了解该把哪个数据塞给哪个 View 层接口。这是一种耦合，Presenter 和这个具体的 View 层接口耦合，较难复用于其他业务。</li><li>MVP 并未向界面提供唯一 UI 状态，而是将描述一个完整界面的 UI 状态 分散在若干 View 层接口回调中。这使得界面的绘制无法内聚到一点，增加了界面绘制逻辑维护的复杂度。</li><li>理论上，界面和业务分层之后，各自都更加单纯，为复用提供了可能性。但不管是业务接口的复用，还是View层接口的复用都相当别扭。</li><li>Presenter 与界面共存亡 ，使得 MVP 无法应对横竖屏切换的场景。</li><li>MVP 无法优雅地实现跨界面通信，也未内建粘性通信机制，得借助第三方库实现。</li><li>MVP 并未内建生命周期管理机制，易造成内存泄漏、crash、资源浪费。</li></ol><h3 id="实现代码说明：-1"><a href="#实现代码说明：-1" class="headerlink" title="实现代码说明："></a>实现代码说明：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line"> * 描述：MVP 架构功能实现，这里模拟一个 登录 功能，输入账号密码，点击登录按钮，底部显示登录状态文本</span><br><span class="line"> *  1. V 层会持有 P 层实例(面向接口，不是具体实例)，P 层实现 P层相关接口，让 V 层来发起具体业务。</span><br><span class="line"> *  2. P 层会持有 V 层实例(面向接口，不是具体实例)，V 层实现 V 层相关接口，来指导 P 层处理完业务逻辑之后的页面绘制。</span><br><span class="line"> *  3. P 层也会持有 M 层实例，用于数据的获取。</span><br><span class="line"> *</span><br><span class="line"> *  总结：思想是独立业务层，页面刷新和业务发起都面向接口，便于代码复用和解耦，职责分工非常明确。但是会新增大量的接口，且代码复用时会造成很多空接口实现，增大了界面绘制的复杂度。</span><br><span class="line"> */</span><br><span class="line">class MVPActivity : AppCompatActivity(),IView&#123;</span><br><span class="line">  </span><br><span class="line">  private lateinit var binding: ActivityMvpBinding</span><br><span class="line">  </span><br><span class="line">  // 持有 P 层实例</span><br><span class="line">  private val presenter :IPresenter= Presenter()</span><br><span class="line">  </span><br><span class="line">  override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    binding = ActivityMvpBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">    presenter.init(this)</span><br><span class="line">    // 登录按钮事件，通过 P 层发起业务</span><br><span class="line">    binding.btnLogin.setOnClickListener &#123; presenter.login(binding.etAccount.text.toString(), binding.etPassword.text.toString()) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  override fun loginSuccess() &#123;</span><br><span class="line">    // 根据接口约定来渲染页面</span><br><span class="line">    binding.tvLoginResult.text = &quot;登录成功！!&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  override fun loginFail() &#123;</span><br><span class="line">    // 根据接口约定来渲染页面</span><br><span class="line">    binding.tvLoginResult.text = &quot;登录失败！！&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  override fun onDestroy() &#123;</span><br><span class="line">    super.onDestroy()</span><br><span class="line">    presenter.destroy()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：模型层，用于数据获取、加工等</span><br><span class="line"> */</span><br><span class="line">class Model &#123;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 描述：这里模拟一下登录成功或失败</span><br><span class="line">   */</span><br><span class="line">  fun login(account: String, password: String) =</span><br><span class="line">    account.isNotEmpty() &amp;&amp; password.isNotEmpty() &amp;&amp; account == &quot;123&quot; &amp;&amp; password == &quot;123&quot;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：业务逻辑层，持有 M 和 V 层，通过 View 层接口指导界面绘制</span><br><span class="line">*/</span><br><span class="line">class Presenter : IPresenter &#123;</span><br><span class="line">  // 持有 V 层，不指向具体，面向接口抽象，便于解耦</span><br><span class="line">  private var view:IView? = null</span><br><span class="line">  // 持有 M 层 ，用于数据的处理</span><br><span class="line">  private val model = Model()</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 描述：初始化</span><br><span class="line">  */</span><br><span class="line">  override fun init(view:IView) &#123;</span><br><span class="line">    this.view = view</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 描述：具体业务</span><br><span class="line">  */</span><br><span class="line">  override fun login(account: String, password: String) &#123;</span><br><span class="line">    val success = model.login(account, password)</span><br><span class="line">    if (success) &#123;</span><br><span class="line">      view?.loginSuccess()</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      view?.loginFail()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 描述：销毁</span><br><span class="line">  */</span><br><span class="line">  override fun destroy() &#123;</span><br><span class="line">    this.view = null</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：业务逻辑层接口，让 V 层通过业务接口向业务逻辑层发起请求</span><br><span class="line"> */</span><br><span class="line">interface IPresenter &#123;</span><br><span class="line">  fun init(view:IView)</span><br><span class="line">  fun login(account: String, password: String)</span><br><span class="line">  fun destroy()</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：V 层接口，让 P 层通过该层接口指导界面绘制</span><br><span class="line"> */</span><br><span class="line">interface IView &#123;</span><br><span class="line">  fun loginSuccess()</span><br><span class="line">  fun loginFail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、MVVM-架构"><a href="#四、MVVM-架构" class="headerlink" title="四、MVVM 架构"></a>四、MVVM 架构</h2><ol><li><p>说明：模型（Model）、视图（View）、业务逻辑层（ViewModel）</p><p>视图层：Android的xml布局文件被划分为View视图层。</p><p>   业务层：ViewModel 对象用于业务层，对逻辑进行处理，内部通过数据层来访问数据。使得界面绘制和业务逻辑分开，降低了它们的耦合，形成相互独立的界面层 V 和业务逻辑层 VM。</p><p>   数据层：数据管理模块，这包括了数据的获取，加工、存储等。</p></li></ol><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>V 层会持有 VM 层实例，但是 VM 的生命周期比界面更长，在能够感知界面的生命周期，在 Activity 配置发生变化被销毁重建时恢复数据，以保证不会重新触发业务逻辑，解决了 P 层的痛点。</li><li>VM 层不再需要持有 V 层的引用了，而是通过 DataBinding 来跟页面进行绑定，进行双向通信，通过观察者模式，在数据更新时自动刷新界面。</li><li>界面刷新是以数据来驱动的，是响应式的，界面的刷新是持续不断去响应的，只要数据变更，就会响应刷新。而不像 P 层那样，要找到对应的 V 层接口方法去命令式地调用，进行界面刷新。</li><li>. 因为业务层只操纵数据，界面通过观察数据的方式实现刷新，所以更加的解耦，VM 层能更好地被复用。不同的界面可以以任何喜欢的方式组合使用业务层提供的数据。</li><li>不再需要定义各种根据业务或状态而决定的接口回调，更加的自由了。</li></ol><h3 id="实现代码说明：-2"><a href="#实现代码说明：-2" class="headerlink" title="实现代码说明："></a>实现代码说明：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">   /**</span><br><span class="line"> * 描述：MVVM 架构功能实现，这里模拟一个 登录 功能，输入账号密码，点击登录按钮，底部显示登录状态文本</span><br><span class="line"> *</span><br><span class="line"> *  1. V 层会持有 VM 层实例，但是 VM 的生命周期比界面更长，在能够感知界面的生命周期，在 Activity 配置发生变化被销毁重建时恢复数据，以保证不会重新触发业务逻辑，解决了 P 层的痛点。</span><br><span class="line"> *  2. VM 层不再需要持有 V 层的引用了，而是通过 DataBinding 来跟页面进行绑定，进行双向通信，通过观察者模式，在数据更新时自动刷新界面。</span><br><span class="line"> *  3. 界面刷新是以数据来驱动的，是响应式的，界面的刷新是持续不断去响应的，只要数据变更，就会响应刷新。而不像 P 层那样，要找到对应的 V 层接口方法去命令式地调用，进行界面刷新。</span><br><span class="line"> *  4. 因为业务层只操纵数据，界面通过观察数据的方式实现刷新，所以更加的解耦，VM 层能更好地被复用。不同的界面可以以任何喜欢的方式组合使用业务层提供的数据。</span><br><span class="line"> *</span><br><span class="line"> *  代码实现说明 ：通过Android提供的数据双向绑定库data binding 将Acitvity/xml视图层与ViewModel绑定。在xml布局文件中，通过@&#123;&#125;来表示单向绑定或者@=&#123;&#125;来表示双向绑定。</span><br><span class="line"> *  Activity接受到视图层的登录点击事件后，调用ViewModel处理登录业务逻辑，ViewModel通过双向数据绑定拿到到视图层输入的账号密码数据，调用Model处理数据，Model处理数据后，</span><br><span class="line"> *  回传给ViewModel, ViewModel的数据改变，View感知后刷新页面。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class MVVMActivity : AppCompatActivity() &#123;</span><br><span class="line">  </span><br><span class="line">  // 持有 VM 层实例</span><br><span class="line">  private val vm by viewModels&lt;MVVMViewModel&gt;()</span><br><span class="line">  </span><br><span class="line">  private lateinit var binding: ActivityMvvmBinding</span><br><span class="line">  </span><br><span class="line">  override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">     binding =</span><br><span class="line">         DataBindingUtil.setContentView&lt;ActivityMvvmBinding?&gt;(this, </span><br><span class="line">         R.layout.activity_mvvm).apply &#123;</span><br><span class="line">         setVariable(BR.viewModel, vm)</span><br><span class="line">         lifecycleOwner = this@MVVMActivity</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    // 登录按钮事件，通过 VM 层发起业务</span><br><span class="line">     binding.btnLogin.setOnClickListener &#123; vm.login() &#125;</span><br><span class="line">  </span><br><span class="line">    // 观察数据</span><br><span class="line">    vm.account.observe(this) &#123;</span><br><span class="line">      ToastUtils.showShortToast(it)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    // 观察数据</span><br><span class="line">    vm.password.observe(this) &#123;</span><br><span class="line">      ToastUtils.showShortToast(it)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    // 观察数据</span><br><span class="line">    vm.loginResult.observe(this) &#123;</span><br><span class="line">      ToastUtils.showShortToast(it)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：模型层，用于数据获取、加工等</span><br><span class="line"> */</span><br><span class="line">class Model &#123;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 描述：这里模拟一下登录成功或失败</span><br><span class="line">   */</span><br><span class="line">  fun login(account: String, password: String) =</span><br><span class="line">    account.isNotEmpty() &amp;&amp; password.isNotEmpty() &amp;&amp; account == &quot;123&quot; &amp;&amp; password == &quot;123&quot;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：VM 层，相当于 P 层，但是不需要通过 V 层接口来指导页面来绘制了，而是通过 DataBinding 来跟页面进行绑定，进行双向通信，通过观察者模式，在数据更新时自动刷新界面。</span><br><span class="line"> *      这使得 VM 层不再需要持有 V 层，跟 V 层解耦， V 层持有 VM 层实例，对想要观察的数据进行监听即可。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class MVVMViewModel : ViewModel() &#123;</span><br><span class="line">  // 可观察数据</span><br><span class="line">  val account = MutableLiveData(&quot;&quot;)</span><br><span class="line">  val password = MutableLiveData(&quot;&quot;)</span><br><span class="line">  val loginResult = MutableLiveData(&quot;&quot;)</span><br><span class="line">  </span><br><span class="line">  // 持有 M 层 ，用于数据的处理</span><br><span class="line">  private val model = Model()</span><br><span class="line">  </span><br><span class="line">  // 登录业务方法</span><br><span class="line">  fun login() &#123;</span><br><span class="line">    val success = model.login(account.value.orEmpty(), password.value.orEmpty())</span><br><span class="line">    loginResult.value = if (success) &quot;登录成功！!&quot; else &quot;登录失败！！&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、MVI-架构"><a href="#五、MVI-架构" class="headerlink" title="五、MVI 架构"></a>五、MVI 架构</h2><ol><li>说明：不关心业务层形态，而是关心业务数据变换及流动的形态。是一个单向数据流。界面是数据流的起点（生产者）也是终点（消费者），界面发出的数据叫（业务）意图，意图会用函数式编程的方式被变换为状态，最终状态通过响应式编程的方式流向界面，界面消费状态完成刷新。在这个流动的过程中，若保证了唯一可信数据源，就能实现单向数据流。</li></ol><h3 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h3><ol><li>MVI 架构对意图和状态的管理非常重要，过分仔细地区别会显得太乱，全部集中管理状态，会显的太臃肿，可能对界面刷新有性能影响。我们应该尽量集中管理独立的业务和状态，互相不影响。</li><li>什么情况下应该定义为意图，意图的维度，还有状态的维度，状态的字段到底要集中管理多少个属性，怎么定义并区分独立于其他的状态。页面状态独立消费处理，粒度不能太大，因为不能频繁刷新而影响性能，也不能太小，会导致刷新位置过于分散。</li><li>意图的管理：是通过多个不同的意图来区别业务，还是通过不同的入参来区别业务，需要斟酌。如果通过入参来区分，那么出参可能也要增加字段。</li><li>状态的管理：是通过不同的 data class 来刷新页面，还是通过集中管理 data class 中包括的字段来刷新页面。最终的 State 会通过 Intent ，copy 一个无副作用的对象（保证线程安全、数据可信唯一）并设置到出参字段，然后流向终点（界面）进行消费。在界面中，会通过不同的业务意图进行分支处理。</li></ol><h3 id="以下为非传统的-MVI-实现方式分析-："><a href="#以下为非传统的-MVI-实现方式分析-：" class="headerlink" title="以下为非传统的 MVI 实现方式分析 ："></a>以下为非传统的 MVI 实现方式分析 ：</h3><ol><li>意图(Intent)： 当前框架中的 Intent 非传统意义上的 MVI intent， 而是简化 reduce 和 action 后，拍平的 intent， 它可以携带 param，input 至 mvi-Dispatcher， 也可以 copy 和携带 result，output 至表现层。当实现 MVI 功能时，首先要分析各业务意图，进行意图的划分管理，包括入参和出参。</li><li>状态的定义(UIState)： 意图通过响应式编程处理并加工各种数据，并将（最终的处理结果）界面需要的状态封装成 data class ， 这里的 data 称之为 State 状态，但是这个状态不是对应一个 LiveData ，而是通过状态管理划分出来的一个数据对象。</li><li>整体流程是这样的： 意图带入参进行业务发送，ViewModel 来处理业务（单纯的领域层，内部包括 M 层进行数据的获取等，根据不同的意图进行一定程度的业务处理，并不包括数据的存储和恢复）。本架构的 StateHolder 不在同一个 ViewModel 中，而是新建的ViewModel ，放在 UI 层，用于数据的保存和恢复。这样，业务层的 ViewModel 相当的单纯，很方便被复用。StateHolder 的属性都是 ObservableField 对象，通过 DataBinding 进行页面的刷新绑定。</li><li>对于一些全局的业务VM ，可以通过 applicationViewModels 扩展函数来获取 VM ，这样该 VM 生命周期就是 Application 生命周期的，可随时进行意图的加工和发送，比如一些页面的刷新处理，一定程度上可以替代 EventBus 。</li></ol><h3 id="一些疑问？"><a href="#一些疑问？" class="headerlink" title="一些疑问？"></a>一些疑问？</h3><ul><li><p>为什么不直接在 UI 层通过方法调用来处理逻辑呢？</p><p> 答： 不符合 MVI 架构的理念，并不是单向数据流且复用度低。比如 A、B、C 三个页面都有一些相同的意图业务，每个类都是直接通过类内函数来处理，则无法进行代码复用。将方法放在基类又有点违反原则了。放在 VM 中进行复用，相当的有效，跟 MVP 中放在 P 层共用是一样的道理。注意，是业务意图，如果是单纯的界面处理逻辑，完全可以通过方法进行调用。</p></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>Intent 就是在提示你，将原先命令式的函数调用转换成一个事件数据，用响应式编程的方式进行事件到状态的变换，并且还得保证界面状态有唯一可信数据源，这样界面的刷新就形成了一条单向数据流。</li><li>只要满足“响应式编程”、“单向数据流”、“唯一可信数据源”这三个原则的都可以称之为 MVI。不管使用的是 ViewModel 还是 Presenter。MVI 关心的不是具体的界面状态持有者，而是整个更新界面数据链路的流动方式和方向。</li><li>整个页面的刷新逻辑都是遵循： Intent(业务意图) - (VM 处理) - View (消费)。</li></ol><h3 id="本项目架构中的-MVI-使用："><a href="#本项目架构中的-MVI-使用：" class="headerlink" title="本项目架构中的 MVI 使用："></a>本项目架构中的 MVI 使用：</h3><ol><li>在 MVVM 中 ，原本界面发起的事件是通过 ViewModel 的一个方法调用传递的。MVI 中，是响应式编程，得把函数调用用 “数据” 的形式包装起来。本架构中，用 input 方法发送上游数据。</li><li>接着在 onHandle 方法中对流上的数据进行变换处理，这个阶段可以通过 flow 的各种操作进行处理，流出的是 State ，用于界面消费渲染。本架构中，最终的 State 通过 Intent copy 之后的出参来设置。</li><li>最终 State 的消费由 sendResult 方法发送到界面层，界面层通过 output 出口拿到对应的 Intent 中的 State 进行消费【其中， State 会被界面层专属的 StateHolder 进行保存，用于数据恢复和使用】，本架构不对领域层的 State 进行监听消费，而将 State（界面状态）和 Activity&#x2F;fragment（界面展示）放在一起，归为 UI 层 ，但是 State 是通过 StateHolder 来保存的，也是一个 ViewModel ，只是这个 ViewModel 的职责专属该 UI 层保存和恢复数据 ，而领域层 VM ，对流进行业务处理，可供同业务不同页面复用。至此，一个单向数据流消费完成。</li></ol><h3 id="实现代码说明：-3"><a href="#实现代码说明：-3" class="headerlink" title="实现代码说明："></a>实现代码说明：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line"> * 描述：MVI 架构功能实现，这里模拟一个 登录 功能，输入账号密码，点击登录按钮，底部显示登录状态文本</span><br><span class="line"> *</span><br><span class="line"> * 本架构中的 MVI 使用：</span><br><span class="line"> *   1. MVVM 中 ，原本界面发起的事件是通过 ViewModel 的一个方法调用传递的。MVI 中，是响应式编程，得把函数调用用 &quot;数据&quot; 的形式包装起来。本架构中，用 input 方法发送上游数据。</span><br><span class="line"> *   2. 接着在 onHandle 方法中对流上的数据进行变换处理，这个阶段可以通过 flow 的各种操作进行处理，流出的是 State ，用于界面消费渲染。本架构中，最终的 State 通过 Intent copy 之后的出参来设置。</span><br><span class="line"> *   3. 最终 State 的消费由 sendResult 方法发送到界面层，界面层通过 output 出口拿到对应的 Intent 中的 State 进行消费【其中， State 会被界面层专属的 StateHolder 进行保存，用于数据恢复和使用】，本架构不对</span><br><span class="line"> *      领域层的 State 进行监听消费，而将 State（界面状态）和 Activity/fragment（界面展示）放在一起，归为 UI 层 ，但是 State 是通过 StateHolder 来保存的，也是一个 ViewModel ，只是这个 ViewModel 的职责专属该 UI 层保存和</span><br><span class="line"> *      恢复数据 ，而领域层 VM ，对流进行业务处理，可供同业务不同页面复用。至此，一个单向数据流消费完成。</span><br><span class="line"> */</span><br><span class="line">class MVIActivity : AppCompatActivity() &#123;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 描述： State（界面状态）和 Activity/fragment（界面展示）放在一起，归为 UI 层，专属该 UI 层保存和恢复数据</span><br><span class="line">   */</span><br><span class="line">  class MVIStateHolder : StateHolder() &#123;</span><br><span class="line">    val account = State(&quot;&quot;)</span><br><span class="line">    val password = State(&quot;&quot;)</span><br><span class="line">    val loginResult = State(&quot;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 持有 VM 层实例</span><br><span class="line">  private val vm by viewModels&lt;MVIViewModel&gt;()</span><br><span class="line">  private val accountStates by viewModels&lt;MVIStateHolder&gt;()</span><br><span class="line">  </span><br><span class="line">  private lateinit var binding: ActivityMviBinding</span><br><span class="line">  </span><br><span class="line">  override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    binding =</span><br><span class="line">      DataBindingUtil.setContentView&lt;ActivityMviBinding&gt;(this, R.layout.activity_mvi).apply &#123;</span><br><span class="line">        // 注意：这里传进去的 states 不要跟外层定义的变量同名，不然根据就没传入，引用的还是内层的对象</span><br><span class="line">        setVariable(BR.states, accountStates)</span><br><span class="line">        lifecycleOwner = this@MVIActivity</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">    binding.btnLogin.setOnClickListener &#123;</span><br><span class="line">      // 发送登录意图</span><br><span class="line">      vm.input(</span><br><span class="line">        AccountManagerIntent.LoginAccount(</span><br><span class="line">          accountStates.account.get()!!,</span><br><span class="line">          accountStates.password.get()!!</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    // 唯一出口，消费 Intent 中的 State</span><br><span class="line">    vm.output(this) &#123; accountManagerIntent -&gt;</span><br><span class="line">      when (accountManagerIntent) &#123;</span><br><span class="line">        is AccountManagerIntent.LoginAccount -&gt; &#123;</span><br><span class="line">  </span><br><span class="line">          updateUIState(accountManagerIntent.state)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 描述： 更新页面，状态独立处理，粒度不能太大，因为不能频繁刷新而影响性能，也不能太小，会导致刷新位置过于分散</span><br><span class="line">   */</span><br><span class="line">  private fun updateUIState(state: AccountManagerState) &#123;</span><br><span class="line">    accountStates.loginResult.set(state.loginResult)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：模型层，用于数据获取、加工等</span><br><span class="line"> */</span><br><span class="line">class Model &#123;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 描述：这里模拟一下登录成功或失败</span><br><span class="line">   */</span><br><span class="line">  fun login(account: String, password: String) =</span><br><span class="line">    account.isNotEmpty() &amp;&amp; password.isNotEmpty() &amp;&amp; account == &quot;123&quot; &amp;&amp; password == &quot;123&quot;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：UI State</span><br><span class="line"> */</span><br><span class="line">data class AccountManagerState(val success: Boolean = false, val loginResult: String = &quot;没登录&quot;)</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述： 账号管理意图，可能包括账号注册、登录、找回密码、注销等等</span><br><span class="line"> */</span><br><span class="line">sealed class AccountManagerIntent &#123;</span><br><span class="line">  // 登录业务意图</span><br><span class="line">  data class LoginAccount(</span><br><span class="line">    val account: String,</span><br><span class="line">    val password: String,</span><br><span class="line">    val state: AccountManagerState = AccountManagerState()</span><br><span class="line">  ) : AccountManagerIntent()</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：对流进行业务处理，可供同业务不同页面复用</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class MVIViewModel : MviDispatcherKTX&lt;AccountManagerIntent&gt;() &#123;</span><br><span class="line">  </span><br><span class="line">  // 持有 M 层 ，用于数据的处理</span><br><span class="line">  private val model = Model()</span><br><span class="line">  </span><br><span class="line">  override suspend fun onHandle(event: AccountManagerIntent) &#123;</span><br><span class="line">    when (event) &#123;</span><br><span class="line">      is AccountManagerIntent.LoginAccount -&gt; &#123;</span><br><span class="line">        // 业务处理，可以是复杂的 flow 处理，流出 State</span><br><span class="line">        val success = model.login(event.account, event.password)</span><br><span class="line">        // 发送 State 给 UI 层消费，通过同一个 Intent 流出</span><br><span class="line">        val state = AccountManagerState(success, if (success) &quot;登录成功！!&quot; else &quot;登录失败！！&quot;)</span><br><span class="line">        ToastUtils.showShortToast(state.loginResult)</span><br><span class="line">        sendResult(event.copy(state = state))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>布局文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;data&gt;</span><br><span class="line">    &lt;variable</span><br><span class="line">      name=&quot;states&quot;</span><br><span class="line">      type=&quot;com.kunminx.purenote.mvi.MVIActivity.MVIStateHolder&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">  &lt;androidx.constraintlayout.widget.ConstraintLayout</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;EditText</span><br><span class="line">      android:id=&quot;@+id/et_account&quot;</span><br><span class="line">      android:layout_width=&quot;match_parent&quot;</span><br><span class="line">      android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">      app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class="line">      android:layout_margin=&quot;40dp&quot;</span><br><span class="line">      android:text=&quot;@=&#123;states.account&#125;&quot;</span><br><span class="line">      android:hint=&quot;账号&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;EditText</span><br><span class="line">      android:id=&quot;@+id/et_password&quot;</span><br><span class="line">      android:layout_width=&quot;match_parent&quot;</span><br><span class="line">      android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">      app:layout_constraintTop_toBottomOf=&quot;@id/et_account&quot;</span><br><span class="line">      android:layout_margin=&quot;40dp&quot;</span><br><span class="line">      android:text=&quot;@=&#123;states.password&#125;&quot;</span><br><span class="line">      android:hint=&quot;密码&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">      android:id=&quot;@+id/btn_login&quot;</span><br><span class="line">      android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">      android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">      app:layout_constraintTop_toBottomOf=&quot;@id/et_password&quot;</span><br><span class="line">      app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">      app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">      android:layout_marginTop=&quot;20dp&quot;</span><br><span class="line">      android:text=&quot;登录&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">      android:id=&quot;@+id/tv_login_result&quot;</span><br><span class="line">      android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">      android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">      app:layout_constraintTop_toBottomOf=&quot;@id/btn_login&quot;</span><br><span class="line">      app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">      android:layout_marginTop=&quot;40dp&quot;</span><br><span class="line">      android:textSize=&quot;20sp&quot;</span><br><span class="line">      app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">      android:text=&quot;@&#123;states.loginResult&#125;&quot;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/layout&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>livedata</title>
      <link href="/2022/06/06/livedata/"/>
      <url>/2022/06/06/livedata/</url>
      
        <content type="html"><![CDATA[<p>LiveData (可观察的数据存储器类)，使用篇…</p><span id="more"></span><h2 id="LiveData-可观察的数据存储器类-，使用篇"><a href="#LiveData-可观察的数据存储器类-，使用篇" class="headerlink" title="LiveData (可观察的数据存储器类)，使用篇"></a><strong>LiveData (可观察的数据存储器类)，使用篇</strong></h2><!-- 本地图片引用 --><!-- <img src="/2022/06/06/livedata/juanjuan01.jpg" class=""> --><p><img src="/2022/06/06/livedata/juanjuan01.jpg"></p><h4 id="作用：不是普通的观察类，具有生命周期感知能力，能够在-Activity、Fragment、Service-中正确的处理生命周期。"><a href="#作用：不是普通的观察类，具有生命周期感知能力，能够在-Activity、Fragment、Service-中正确的处理生命周期。" class="headerlink" title="作用：不是普通的观察类，具有生命周期感知能力，能够在 Activity、Fragment、Service 中正确的处理生命周期。"></a>作用：不是普通的观察类，具有生命周期感知能力，能够在 <code>Activity、Fragment、Service</code> 中正确的处理生命周期。</h4><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><h5 id="1-LiveData-是一个数据持有者，是数据源的包装类。"><a href="#1-LiveData-是一个数据持有者，是数据源的包装类。" class="headerlink" title="1. LiveData 是一个数据持有者，是数据源的包装类。"></a>1. <code>LiveData</code> 是一个数据持有者，是数据源的包装类。</h5><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="2-源数据使用-LiveData-进行包装之后，可以被观察，当数据有更新时，观察者可感知。"><a href="#2-源数据使用-LiveData-进行包装之后，可以被观察，当数据有更新时，观察者可感知。" class="headerlink" title="2. 源数据使用 LiveData 进行包装之后，可以被观察，当数据有更新时，观察者可感知。"></a>2. 源数据使用 <code>LiveData</code> 进行包装之后，可以被观察，当数据有更新时，观察者可感知。</h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h5 id="3-观察者感知或被通知到的时机是跟生命周期相关的，只发生在-Activity-Fragment-活跃生命周期状态，如果一个观察者处于-Paused-或-Destroyed-状态，它将不会收到通知。"><a href="#3-观察者感知或被通知到的时机是跟生命周期相关的，只发生在-Activity-Fragment-活跃生命周期状态，如果一个观察者处于-Paused-或-Destroyed-状态，它将不会收到通知。" class="headerlink" title="3. 观察者感知或被通知到的时机是跟生命周期相关的，只发生在 Activity/Fragment 活跃生命周期状态，如果一个观察者处于 Paused 或 Destroyed 状态，它将不会收到通知。"></a>3. 观察者感知或被通知到的时机是跟生命周期相关的，只发生在 <code>Activity/Fragment</code> 活跃生命周期状态，如果一个观察者处于 <code>Paused</code> 或 <code>Destroyed</code> 状态，它将不会收到通知。</h5><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><h5 id="1-不会发生内存泄漏且无须手动解除观察，LiveData-会在相应生命周期自动移除。"><a href="#1-不会发生内存泄漏且无须手动解除观察，LiveData-会在相应生命周期自动移除。" class="headerlink" title="1. 不会发生内存泄漏且无须手动解除观察，LiveData 会在相应生命周期自动移除。"></a>1. 不会发生内存泄漏且无须手动解除观察，<code>LiveData</code> 会在相应生命周期自动移除。</h5><h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5><h5 id="2-不会因-Activity-停止而导致崩溃，当生命周期处于非活跃状态，不会接收任何-LiveData-事件。"><a href="#2-不会因-Activity-停止而导致崩溃，当生命周期处于非活跃状态，不会接收任何-LiveData-事件。" class="headerlink" title="2. 不会因 Activity 停止而导致崩溃，当生命周期处于非活跃状态，不会接收任何 LiveData 事件。"></a>2. 不会因 <code>Activity</code> 停止而导致崩溃，当生命周期处于非活跃状态，不会接收任何 <code>LiveData</code> 事件。</h5><h5 id="-3"><a href="#-3" class="headerlink" title=""></a></h5><h5 id="3-数据始终保持最新状态且避免重复刷新界面，数据更新时若-Activity-为非活跃状态，那么会在变为活跃时接收最新数据。例如，在后台的-Activity-会在返回前台时立即接收最新的数据，而不是在每次数据变化时刷新界面。"><a href="#3-数据始终保持最新状态且避免重复刷新界面，数据更新时若-Activity-为非活跃状态，那么会在变为活跃时接收最新数据。例如，在后台的-Activity-会在返回前台时立即接收最新的数据，而不是在每次数据变化时刷新界面。" class="headerlink" title="3. 数据始终保持最新状态且避免重复刷新界面，数据更新时若 Activity 为非活跃状态，那么会在变为活跃时接收最新数据。例如，在后台的 Activity 会在返回前台时立即接收最新的数据，而不是在每次数据变化时刷新界面。"></a>3. 数据始终保持最新状态且避免重复刷新界面，数据更新时若 <code>Activity</code> 为非活跃状态，那么会在变为活跃时接收最新数据。例如，在后台的 <code>Activity</code> 会在返回前台时立即接收最新的数据，而不是在每次数据变化时刷新界面。</h5><h3 id="LiveData-的基础使用"><a href="#LiveData-的基础使用" class="headerlink" title="LiveData 的基础使用"></a>LiveData 的基础使用</h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><h5 id="1-创建-LiveData-实例，通过泛型指定源数据类型。"><a href="#1-创建-LiveData-实例，通过泛型指定源数据类型。" class="headerlink" title="1. 创建 LiveData 实例，通过泛型指定源数据类型。"></a>1. 创建 <code>LiveData</code> 实例，通过泛型指定源数据类型。</h5><h5 id="-4"><a href="#-4" class="headerlink" title=""></a></h5><h5 id="2-创建-Observer-实例，实现-onChanged-方法，用于接收源数据变化并刷新-UI。"><a href="#2-创建-Observer-实例，实现-onChanged-方法，用于接收源数据变化并刷新-UI。" class="headerlink" title="2. 创建 Observer 实例，实现 onChanged() 方法，用于接收源数据变化并刷新 UI。"></a>2. 创建 <code>Observer</code> 实例，实现 <code>onChanged()</code> 方法，用于接收源数据变化并刷新 UI。</h5><h5 id="-5"><a href="#-5" class="headerlink" title=""></a></h5><h5 id="3-LiveData-实例使用-observe-方法添加观察者，并传入-LifecycleOwner，就是-Activity-本身。"><a href="#3-LiveData-实例使用-observe-方法添加观察者，并传入-LifecycleOwner，就是-Activity-本身。" class="headerlink" title="3. LiveData 实例使用 observe() 方法添加观察者，并传入 LifecycleOwner，就是 Activity 本身。"></a>3. <code>LiveData</code> 实例使用 <code>observe()</code> 方法添加观察者，并传入 <code>LifecycleOwner</code>，就是 <code>Activity</code> 本身。</h5><h5 id="-6"><a href="#-6" class="headerlink" title=""></a></h5><h5 id="4-LiveData-实例使用-setValue-postValue-更新源数据-（工作线程要使用-postValue-）"><a href="#4-LiveData-实例使用-setValue-postValue-更新源数据-（工作线程要使用-postValue-）" class="headerlink" title="4. LiveData 实例使用 setValue()/postValue() 更新源数据 （工作线程要使用 postValue()）"></a>4. <code>LiveData</code> 实例使用 <code>setValue()/postValue()</code> 更新源数据 （工作线程要使用 <code>postValue()</code>）</h5><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class LiveDataTestActivity extends AppCompatActivity&#123;</span><br><span class="line"></span><br><span class="line">   private MutableLiveData&lt;String&gt; mLiveData;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">       super.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_lifecycle_test);</span><br><span class="line"></span><br><span class="line">       //liveData基本使用</span><br><span class="line">       mLiveData = new MutableLiveData&lt;&gt;();</span><br><span class="line">       mLiveData.observe(this, new Observer&lt;String&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onChanged(String s) &#123;</span><br><span class="line">               Log.i(TAG, &quot;onChanged: &quot;+s);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       Log.i(TAG, &quot;onCreate: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onCreate&quot;);//activity是非活跃状态，不会回调onChanged。变为活跃时，value被onStart中的value覆盖</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   protected void onStart() &#123;</span><br><span class="line">       super.onStart();</span><br><span class="line">       Log.i(TAG, &quot;onStart: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onStart&quot;);//活跃状态，会回调onChanged。并且value会覆盖onCreate、onStop中设置的value</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   protected void onResume() &#123;</span><br><span class="line">       super.onResume();</span><br><span class="line">       Log.i(TAG, &quot;onResume: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onResume&quot;);//活跃状态，回调onChanged</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   protected void onPause() &#123;</span><br><span class="line">       super.onPause();</span><br><span class="line">       Log.i(TAG, &quot;onPause: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onPause&quot;);//活跃状态，回调onChanged</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   protected void onStop() &#123;</span><br><span class="line">       super.onStop();</span><br><span class="line">       Log.i(TAG, &quot;onStop: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onStop&quot;);//非活跃状态，不会回调onChanged。后面变为活跃时，value被onStart中的value覆盖</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   protected void onDestroy() &#123;</span><br><span class="line">       super.onDestroy();</span><br><span class="line">       Log.i(TAG, &quot;onDestroy: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onDestroy&quot;);//非活跃状态，且此时Observer已被移除，不会回调onChanged</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="注意：除了使用-observe-方法添加观察者，也可以使用-observeForever-Observer-方法来注册未关联-LifecycleOwner-的观察者。在这种情况下，观察者会被视为始终处于活跃状态。"><a href="#注意：除了使用-observe-方法添加观察者，也可以使用-observeForever-Observer-方法来注册未关联-LifecycleOwner-的观察者。在这种情况下，观察者会被视为始终处于活跃状态。" class="headerlink" title="注意：除了使用 observe() 方法添加观察者，也可以使用 observeForever(Observer) 方法来注册未关联 LifecycleOwner 的观察者。在这种情况下，观察者会被视为始终处于活跃状态。"></a>注意：除了使用 <code>observe()</code> 方法添加观察者，也可以使用 <code>observeForever(Observer)</code> 方法来注册未关联 <code>LifecycleOwner</code> 的观察者。在这种情况下，观察者会被视为始终处于活跃状态。</h5><h3 id="LiveData-的进阶使用"><a href="#LiveData-的进阶使用" class="headerlink" title="LiveData 的进阶使用"></a>LiveData 的进阶使用</h3><h4 id="1-Transformations-map-，如果想要在-LiveData-对象分发给观察者之前对其中存储的值进行更改，可以使用该方法。"><a href="#1-Transformations-map-，如果想要在-LiveData-对象分发给观察者之前对其中存储的值进行更改，可以使用该方法。" class="headerlink" title="1. Transformations.map()，如果想要在 LiveData 对象分发给观察者之前对其中存储的值进行更改，可以使用该方法。"></a>1. <code>Transformations.map()</code>，如果想要在 <code>LiveData</code> 对象分发给观察者之前对其中存储的值进行更改，可以使用该方法。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  //Integer类型的liveData</span><br><span class="line">  MutableLiveData&lt;Integer&gt; liveData = new MutableLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  //转换成String类型的transformedLiveData</span><br><span class="line">  LiveData&lt;String&gt; transformedLiveData  = Transformations.map(liveData1, new Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public String apply(Integer input) &#123;</span><br><span class="line">          String s = input + &quot; + Transformations.map&quot;;</span><br><span class="line">          Log.i(TAG, &quot;apply: &quot; + s);</span><br><span class="line">          return s;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">transformedLiveData .observe(this, new Observer&lt;String&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onChanged(String s) &#123;</span><br><span class="line">          Log.i(TAG, &quot;onChanged1: &quot;+s);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  liveData.setValue(100);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-Transformations-switchMap-，如果想要手动控制监听其中一个的数据变化，并能根据需要随时切换监听，这时可以使用-Transformations-switchMap-，它和-Transformations-map-使用方式类似，只不过switchMap-必须返回一个-LiveData-对象。如果要返回-必须返回一个LiveData-对象-就用-switchMap-，不需要就用-map-，效果差不多。"><a href="#2-Transformations-switchMap-，如果想要手动控制监听其中一个的数据变化，并能根据需要随时切换监听，这时可以使用-Transformations-switchMap-，它和-Transformations-map-使用方式类似，只不过switchMap-必须返回一个-LiveData-对象。如果要返回-必须返回一个LiveData-对象-就用-switchMap-，不需要就用-map-，效果差不多。" class="headerlink" title="2. Transformations.switchMap() ，如果想要手动控制监听其中一个的数据变化，并能根据需要随时切换监听，这时可以使用 Transformations.switchMap() ，它和 Transformations.map() 使用方式类似，只不过switchMap() 必须返回一个 LiveData 对象。如果要返回 必须返回一个LiveData 对象 就用 switchMap ，不需要就用 map ，效果差不多。"></a>2. <code>Transformations.switchMap()</code> ，如果想要手动控制监听其中一个的数据变化，并能根据需要随时切换监听，这时可以使用 <code>Transformations.switchMap()</code> ，它和 <code>Transformations.map()</code> 使用方式类似，只不过<code>switchMap()</code> 必须返回一个 <code>LiveData</code> 对象。如果要返回 <code>必须返回一个LiveData</code> 对象 就用 <code>switchMap</code> ，不需要就用 <code>map</code> ，效果差不多。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    private static final String TAG = &quot;MainActivity&quot;;</span><br><span class="line">    MutableLiveData&lt;String&gt; mutableLiveData1;</span><br><span class="line">    MutableLiveData&lt;String&gt; mutableLiveData2;</span><br><span class="line">    MutableLiveData&lt;Boolean&gt; liveDataSwitch;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mutableLiveData1 = new MutableLiveData&lt;&gt;();</span><br><span class="line">        mutableLiveData2 = new MutableLiveData&lt;&gt;();</span><br><span class="line">        liveDataSwitch = new MutableLiveData&lt;Boolean&gt;();//1</span><br><span class="line"></span><br><span class="line">        LiveData transformedLiveData= Transformations.switchMap(liveDataSwitch, new Function&lt;Boolean, LiveData&lt;String&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public LiveData&lt;String&gt; apply(Boolean input) &#123;</span><br><span class="line">                if (input) &#123;</span><br><span class="line">                    return mutableLiveData1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return mutableLiveData2;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        transformedLiveData.observe(this, new Observer&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onChanged(@Nullable final String s) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onChanged:&quot; + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        liveDataSwitch.postValue(false);//2</span><br><span class="line">        mutableLiveData1.postValue(&quot;kotlin&quot;);</span><br><span class="line">        mutableLiveData2.postValue(&quot;java&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通过-liveDataSwitch-对象控制是监听-mutableLiveData1-的数据还是-mutableLiveData2-的数据。"><a href="#通过-liveDataSwitch-对象控制是监听-mutableLiveData1-的数据还是-mutableLiveData2-的数据。" class="headerlink" title="通过 liveDataSwitch 对象控制是监听 mutableLiveData1 的数据还是 mutableLiveData2 的数据。"></a>通过 <code>liveDataSwitch</code> 对象控制是监听 <code>mutableLiveData1</code> 的数据还是 <code>mutableLiveData2</code> 的数据。</h5><h4 id="3-合并多个-LiveData-数据源，MediatorLiveData-继承自-mutableLiveData-，它可以将多个-LiveData-数据源集合起来，可以达到一个组件监听多个-LiveData-数据变化的目的。"><a href="#3-合并多个-LiveData-数据源，MediatorLiveData-继承自-mutableLiveData-，它可以将多个-LiveData-数据源集合起来，可以达到一个组件监听多个-LiveData-数据变化的目的。" class="headerlink" title="3. 合并多个 LiveData 数据源，MediatorLiveData 继承自 mutableLiveData ，它可以将多个 LiveData 数据源集合起来，可以达到一个组件监听多个 LiveData 数据变化的目的。"></a>3. 合并多个 <code>LiveData</code> 数据源，<code>MediatorLiveData</code> 继承自 <code>mutableLiveData</code> ，它可以将多个 <code>LiveData</code> 数据源集合起来，可以达到一个组件监听多个 <code>LiveData</code> 数据变化的目的。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">val mutableLiveData1 = MutableLiveData&lt;String&gt;()</span><br><span class="line">val mutableLiveData2 = MutableLiveData&lt;String&gt;()</span><br><span class="line">val liveDataMerger = MediatorLiveData&lt;String&gt;()</span><br><span class="line">liveDataMerger.addSource(mutableLiveData1, object : Observer&lt;String&gt; &#123;</span><br><span class="line">    override fun onChanged( o: String) &#123;</span><br><span class="line">        LogUtils.d(TAG, &quot;onChanged1:$o&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">liveDataMerger.addSource(mutableLiveData2, object : Observer&lt;String&gt; &#123;</span><br><span class="line">    override fun onChanged( o: String) &#123;</span><br><span class="line">        LogUtils.d(TAG, &quot;onChanged2:$o&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">liveDataMerger.observe(this, object : Observer&lt;String&gt; &#123;</span><br><span class="line">    override fun onChanged( o: String) &#123;</span><br><span class="line">        // 这里的触发场景，通常是监听的 Livedata源达到某个条件，再更新 liveDataMerger 的值进行回调的</span><br><span class="line">        LogUtils.d(TAG, &quot;onChanged3:$o&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">mutableLiveData1.postValue(&quot;mutableLiveData1文本&quot;)</span><br><span class="line">mutableLiveData2.postValue(&quot;mutableLiveData2文本&quot;)</span><br></pre></td></tr></table></figure><h5 id="其他使用场景：比如有一个列表界面，每一个-item-都可以点赞，每个-item-的赞都是一个数据源，我们可以监听点赞的数量，在达到某个条件处理逻辑。"><a href="#其他使用场景：比如有一个列表界面，每一个-item-都可以点赞，每个-item-的赞都是一个数据源，我们可以监听点赞的数量，在达到某个条件处理逻辑。" class="headerlink" title="其他使用场景：比如有一个列表界面，每一个 item 都可以点赞，每个 item 的赞都是一个数据源，我们可以监听点赞的数量，在达到某个条件处理逻辑。"></a>其他使用场景：比如有一个列表界面，每一个 <code>item</code> 都可以点赞，每个 item 的赞都是一个数据源，我们可以监听点赞的数量，在达到某个条件处理逻辑。</h5><h4 id="4-使用全局-Livedata-在多个视图监听状态"><a href="#4-使用全局-Livedata-在多个视图监听状态" class="headerlink" title="4. 使用全局 Livedata 在多个视图监听状态"></a>4. 使用全局 <code>Livedata</code> 在多个视图监听状态</h4><h4 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h4><h5 id="1-自定义-LiveData，重写-onActive-、onInactive-方法。"><a href="#1-自定义-LiveData，重写-onActive-、onInactive-方法。" class="headerlink" title="1. 自定义 LiveData，重写 onActive()、onInactive() 方法。"></a>1. 自定义 <code>LiveData</code>，重写 <code>onActive()、onInactive()</code> 方法。</h5><h5 id="2-实现为单例模式，实现多个-Activity、Fragment-之间共享数据。"><a href="#2-实现为单例模式，实现多个-Activity、Fragment-之间共享数据。" class="headerlink" title="2. 实现为单例模式，实现多个 Activity、Fragment 之间共享数据。"></a>2. 实现为单例模式，实现多个 <code>Activity、Fragment</code> 之间共享数据。</h5><h5 id="官方示例如下："><a href="#官方示例如下：" class="headerlink" title="官方示例如下："></a>官方示例如下：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class StockLiveData extends LiveData&lt;BigDecimal&gt; &#123;</span><br><span class="line">        private static StockLiveData sInstance; //单实例</span><br><span class="line">        private StockManager stockManager;</span><br><span class="line"></span><br><span class="line">        private SimplePriceListener listener = new SimplePriceListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onPriceChanged(BigDecimal price) &#123;</span><br><span class="line">                setValue(price);//监听到股价变化 使用setValue(price) 告知所有活跃观察者</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">//获取单例</span><br><span class="line">        @MainThread</span><br><span class="line">        public static StockLiveData get(String symbol) &#123;</span><br><span class="line">            if (sInstance == null) &#123;</span><br><span class="line">                sInstance = new StockLiveData(symbol);</span><br><span class="line">            &#125;</span><br><span class="line">            return sInstance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private StockLiveData(String symbol) &#123;</span><br><span class="line">            stockManager = new StockManager(symbol);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     //活跃的观察者（LifecycleOwner）数量从 0 变为 1 时调用</span><br><span class="line">        @Override</span><br><span class="line">        protected void onActive() &#123;</span><br><span class="line">            stockManager.requestPriceUpdates(listener);//开始观察股价更新</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     //活跃的观察者（LifecycleOwner）数量从 1 变为 0 时调用。这不代表没有观察者了，可能是全都不活跃了。可以使用hasObservers()检查是否有观察者。</span><br><span class="line">        @Override</span><br><span class="line">        protected void onInactive() &#123;</span><br><span class="line">            stockManager.removeUpdates(listener);//移除股价更新的观察</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyFragment extends Fragment &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onViewCreated(view, savedInstanceState);</span><br><span class="line">        //获取StockLiveData单实例，添加观察者，更新UI</span><br><span class="line">        StockLiveData.get(symbol).observe(getViewLifecycleOwner(), price -&gt; &#123;</span><br><span class="line">            // Update the UI.</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="其他示例，比如有一个登录验证码倒计时界面，在倒计时，需要在其他的页面也要同步这个倒计时状态，可以这样写："><a href="#其他示例，比如有一个登录验证码倒计时界面，在倒计时，需要在其他的页面也要同步这个倒计时状态，可以这样写：" class="headerlink" title="其他示例，比如有一个登录验证码倒计时界面，在倒计时，需要在其他的页面也要同步这个倒计时状态，可以这样写："></a>其他示例，比如有一个登录验证码倒计时界面，在倒计时，需要在其他的页面也要同步这个倒计时状态，可以这样写：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class GlobalLivedata : LiveData&lt;String&gt;() &#123;</span><br><span class="line">    val coundManager = CountDownManager()</span><br><span class="line">    val listener = object : OnDataChangeListener &#123;</span><br><span class="line">        override fun change(data: String) &#123;</span><br><span class="line">           postValue(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onActive() &#123;</span><br><span class="line">        super.onActive()</span><br><span class="line">        coundManager.setListener(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onInactive() &#123;</span><br><span class="line">        super.onInactive()</span><br><span class="line">        coundManager.removeListener(listener)</span><br><span class="line">    &#125;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        private lateinit var globalData: GlobalLivedata</span><br><span class="line">        fun getInstance(): GlobalLivedata &#123;</span><br><span class="line">            globalData = if (::globalData.isInitialized) globalData else GlobalLivedata()</span><br><span class="line">            return globalData</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jetpack android </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
