<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fanda&#39;s blog</title>
  
  <subtitle>凡达的博客</subtitle>
  <link href="https://liuhangya.github.io/atom.xml" rel="self"/>
  
  <link href="https://liuhangya.github.io/"/>
  <updated>2023-08-31T09:09:03.000Z</updated>
  <id>https://liuhangya.github.io/</id>
  
  <author>
    <name>Fanda Zeng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git 基本操作</title>
    <link href="https://liuhangya.github.io/2023/08/31/git/git_base/"/>
    <id>https://liuhangya.github.io/2023/08/31/git/git_base/</id>
    <published>2023-08-31T09:09:03.000Z</published>
    <updated>2023-08-31T09:09:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git 基本操作</p><span id="more"></span><p>首先，简单介绍一下 <code>git tag</code> 命令，该命令可理解为 “打标签或里程碑”，本质上和 <code>branch</code>、<code>stash</code> 引用一样，也是一个引用，记录着提交 <code>ID</code> (或者创建 <code>Tag</code> 对象)，下面我们来操作一下：</p><ol><li>打上标签，标签名为 <code>old_practice</code>，并添加描述说明：</li></ol><p><img src="/2023/08/31/git/git_base/base1.png"></p><ol start="2"><li>查看标签记录的最新的提交 <code>ID</code>：</li></ol><p><img src="/2023/08/31/git/git_base/base2.png"></p><ol start="3"><li>查看该最新 <code>ID</code> 所记录的内容：</li></ol><p><img src="/2023/08/31/git/git_base/base3.png"></p><p>打标签之后，可以执行 <code>git describe</code> 命令，将最新提交显示为一个容易记的名称，显示的时候会选取离提交最近的 <code>tag</code> 为 ‘’基础版本号’’再附加距离 <code>tag</code> 的数字，以及该提交的哈希值缩写。因为当前的提交就是 <code>tag</code> 所在的提交，所以只会显示出 <code>tag</code> 名称 ：</p><p><img src="/2023/08/31/git/git_base/base4.png"></p><p>现在版本库的状态为暂存区和工作区都包含了修改，如下：</p><p><img src="/2023/08/31/git/git_base/base5.png"></p><p>接下来，我们进行各种操作来演示：</p><ol><li>先保存进度：</li></ol><p><img src="/2023/08/31/git/git_base/base6.png"></p><ol start="2"><li>再用 <code>git stash apply </code> 恢复进度，因为这个进度记录要多次使用，先不移除：</li></ol><p><img src="/2023/08/31/git/git_base/base7.png"></p><p>当前工作区的文件有：</p><p><img src="/2023/08/31/git/git_base/base8.png"></p><ol start="3"><li>直接在工作区删除这些文件</li></ol><p><img src="/2023/08/31/git/git_base/base9.png"></p><p><img src="/2023/08/31/git/git_base/base10.png"></p><p>可以看到本地文件已经删除掉了，但是暂存区和版本库中的文件仍然存在。</p><p><strong>阶段性总结：直接在工作区删除，对暂存区和版本库没任何影响。</strong></p><ol start="4"><li>查看状态看看：</li></ol><p><img src="/2023/08/31/git/git_base/base11.png"></p><p>输出表示，本地删除想要反映到暂存区，应该使用 <code>git rm</code> 命令，对不想删除的文件，可执行 <code>git restore</code> 让文件在工作区中恢复。</p><p>也就是说，需要将删除的工作的文件先 <code>git rm</code> 到暂存区再提交，才算真正的删除，那么我们操作一下：</p><p><img src="/2023/08/31/git/git_base/base12.png"></p><p><img src="/2023/08/31/git/git_base/base13.png"></p><p>现在，在最新的提交中，文件已经被删除了，但是在历史提交中还是存在的，可以通过历史提交来恢复相应的文件，所以完全不用担心。</p><ol start="5"><li>我们查一下上一次提交的文件列表：</li></ol><p><img src="/2023/08/31/git/git_base/base14.png"></p><p>可以通过文件路径，直接查看历史版本中的文件内容：</p><p><img src="/2023/08/31/git/git_base/base15.png"></p><p>我们之前将本地删除的文件反映到暂存区时，用  <code>git rm </code> 并通过空格写了一大堆文件名。其实是可以简化操作的，通过 <code>git add</code> 再加上 <code>-u</code> 参数就可以，其含义是将本地改动(更改和删除)的文件标记到暂存区。</p><p>下面我们用这种方式演示一下，首先要恢复到之前的状态才行：</p><ol><li>先回退到上一次提交的版本，即丢掉最新的提交：</li></ol><p><img src="/2023/08/31/git/git_base/base16.png"></p><ol start="2"><li>恢复之前保存的进度，<code>-q</code> 参数表示命令进入安静模式：</li></ol><p><img src="/2023/08/31/git/git_base/base17.png"></p><p>对比之前的输出：</p><p><img src="/2023/08/31/git/git_base/base18.png"></p><ol start="3"><li>再次删除工作区本地的文件：</li></ol><p><img src="/2023/08/31/git/git_base/base19.png"></p><ol start="4"><li>执行 <code>git add -u</code> 命令可以将(被版本库追踪的)本地文件的变更(修改、删除)全部记录到暂存区中 。【 git add 默认只记录修改，不包括新添加的文件和删除的文件】 ：</li></ol><p><img src="/2023/08/31/git/git_base/base20.png"></p><p>可以看到，工作区删除的文件已经被标记为下次提交时删除了【D】，之前我们看到的都是修改 【M】。</p><ol start="5"><li>最后，进行提交：</li></ol><p><img src="/2023/08/31/git/git_base/base21.png"></p><p><img src="/2023/08/31/git/git_base/base22.png"></p><p>可以看到，本地和版本库中的文件都不存在了。</p><p>一、恢复文件 ：</p><p>下面我们演示一下恢复已经被删除的指定文件，比如指定恢复被删除掉的 Welcome.txt 文件，我们都知道，当前最新的提交中，文件已经不存在，只能从历史提交中提取文件：</p><p><img src="/2023/08/31/git/git_base/base23.png"></p><p><code>HEAD~1</code> ，相当于 <code>HEAD^</code>，指上一次提交，<code>HEAD~2</code> ，相当于 <code>HEAD^^</code> ，指上上一次提交。执行 <code>git add </code> 加上 <code>-A</code> 参数，可以将工作区中所有修改、删除和新增的文件都添加到暂存区：</p><p><img src="/2023/08/31/git/git_base/base24.png"></p><p>最后，我们进行提交：</p><p><img src="/2023/08/31/git/git_base/base25.png"></p><p>二、移动文件：</p><p><img src="/2023/08/31/git/git_base/base26.png"></p><p>这里使用 <code>git mv</code> 命令完成操作，将 <code>Welcome.txt</code> 重命名为 <code>README</code> ，再进行提交。改名之后提交的输出能看到改名前后两个文件的相似度，这里因为文件没修改，所以相似度为 <code>100%</code> 。</p><p>其实可以不使用 <code>git mv </code> 命令，而使用我们之前学过的 <code>git rm</code> 和 <code>git add </code> 两条命令也能实现。</p><ol><li>首先，恢复到上一个版本：</li></ol><p><img src="/2023/08/31/git/git_base/base27.png"></p><p><img src="/2023/08/31/git/git_base/base28.png"></p><p>可以看到，<code>welcome.txt</code> 文件回来了。</p><ol start="2"><li>这次不用  <code>git mv</code> 命令，而是用 <code>mv</code> 直接更改本地文件：</li></ol><p><img src="/2023/08/31/git/git_base/base29.png"></p><p>输出表示 ， <code>welcome.txt</code> 被删除了【D】，有一个没被追踪的 <code>README</code> 【??】。</p><ol start="3"><li>在 <code>README</code> 文件增加一行，如下：</li></ol><p><img src="/2023/08/31/git/git_base/base30.png"></p><ol start="4"><li>使用 <code>git add -A</code> 命令，相当于对修改文件执行 <code>git add</code> ，对删除文件执行 <code>git rm</code> ，对本地新增文件执行 <code>git add</code> ：</li></ol><p><img src="/2023/08/31/git/git_base/base31.png"></p><ol start="5"><li>最后，进行提交：</li></ol><p><img src="/2023/08/31/git/git_base/base32.png"></p><p>这里通过 <code>rm</code> 命令本地移动文件的方式，使用 <code>add -A</code> 命令之后，查看状态时，并不是 <code>renamed</code> 而是新增和删除文件。</p><p>三、文件忽略</p><p>我们之前打了一个标签叫做 “ old_practice” ，现在再次执行 <code>git describe</code> 看一下版本号：</p><p><img src="/2023/08/31/git/git_base/base33.png"></p><p>也就是说：当前工作区的版本是 “tag” 后的第三个版本，提交 ID 是 <code>3dffaeb</code> 。【注意：要忽略ID前面的g】</p><p>当我们不想所有的文件都被 <code>Git</code> 追踪，想让指定的文件忽略(Git 当它们不存在，不进行版本控制)时。那么，可以在这个目录下，创建一个名为为  <code>.gitignore</code> 的文件 【注意，前边有个点】，把那些要忽略的文件写在其中，文件名可以使用通配符，比如：</p><p><img src="/2023/08/31/git/git_base/base34.png"></p><p>先新建一个文件，用于测试效果，先不忽略这个文件，看看状态：</p><p><img src="/2023/08/31/git/git_base/base35.png"></p><p>可以看到 <code>.gitignore 和 ignore_teset.txt</code> 文件都显示没被追踪，需要 <code>add</code> 操作。现在，我们在 <code>.gitgnore</code> 中添加一行 <code>ignore_test.txt</code> ，再查看一下状态：</p><p><img src="/2023/08/31/git/git_base/base36.png"></p><p>发现 <code>ignore_teset.txt</code> 被忽略了，无论对这个文件做什么操作，Git 都不管了。</p><p>实际上，可以把自身添加到忽略文件当中，如下：</p><p><img src="/2023/08/31/git/git_base/base37.png"></p><p><img src="/2023/08/31/git/git_base/base38.png"></p><p>工作区非常干净。<code>.gitignore</code> 通常是要添加到版本库中的，这样别人 <code>clone</code> 项目之后，也能够正常忽略指定的文件，即文件忽略在他人的工作区中同样生效。因为 <code>.gitignore</code> 文件是共享式的。</p><p>查看状态的时候，可以加上 <code>--ignored</code> 来显示被忽略的文件：</p><p><img src="/2023/08/31/git/git_base/base39.png"></p><p>如果不想共享，想本地独享忽略呢？有两种实现方式。</p><p>第一种：针对具体版本库的 “独享式” 忽略。即通过在版本库的 <code>.git</code> 目录下的文件 <code>.git/info/exclude</code> 来设置文件忽略。</p><p>第二种：全局的 “独享式”忽略。即通过 <code>Git</code> 的配置变量 <code>core.excludesfile</code>  指定一个忽略文件，其设置的忽略对<strong>所有本地版本库均有效</strong>。</p><p><strong>总结：具体使用哪一种忽略方式，取决于实际的场景。如果文件忽略对于所有使用此版本库工作的人都有用，就在版本库中创建一个  <code>.gitignore</code> 文件来建立忽略。否则，如果工作区创建的是一个实验性的目录或文件，本不应该让他人知道，那么使用本地忽略。</strong></p><p>最后，我们简单讲一下 <code>Git</code> 忽略语法：</p><ol><li>文件中的空行或以 <code>#</code> 开始的行会被忽略(相当于代码编辑中的注释)。</li><li>可以使用通配符，例如： <code>*</code> 代表任意多字符，<code>?</code> 代表一个字符，[abc] 代表可选字符范围等。</li><li>如果名称的最前面是一个路径分隔符 <code>/</code> ，表明要忽略的文件在此目录下，而非子目录的文件。</li><li>如果名称的最后面是一个路径分隔符 <code>/</code> ，表明要忽略的是整个目录。</li><li>名称最前面添加一个 <code>!</code> ，表示不忽略。</li></ol><p>下面的文件忽略示例，包含了上述要点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是注释行 -- 被忽略</span><br><span class="line">*.a# 忽略所有以 .a 为扩展名的文件</span><br><span class="line">!lib.a# 但是 lib.a 文件或目录不要忽略，即使前面设置了对 *.a 的忽略</span><br><span class="line">/TODO# 只忽略此目录下的 TODO 文件，其他目录或当前目录的子目录中的 TTODO 文件不忽略</span><br><span class="line">build/# 忽略所有 build/ 目录下的文件</span><br><span class="line">doc/*.txt# 忽略文件如 doc/notes.txt ，但是文件如 doc/server/arch.txt 不被忽略【没写到指定目录级别不会被忽略】</span><br></pre></td></tr></table></figure><p><strong>总结：文件 <code>.gitignore</code> 的作用范围是其所处的目录及其子目录，而且只对未被追踪的文件有效，如果文件已经加入版本库了，忽略对其无效。</strong></p><p>四、文件归档</p><p><code>Git</code> 提供了一个归档命令 <code>git archive</code> ，可以对任意提交对应的目录树建立归档，示例如下：</p><p><img src="/2023/08/31/git/git_base/base40.png"></p><p>基于最新提交建立归档文件 <code>latest.zip</code> 。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Git 基本操作&lt;/p&gt;</summary>
    
    
    
    
    <category term="Git" scheme="https://liuhangya.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 恢复进度</title>
    <link href="https://liuhangya.github.io/2023/08/31/git/git_stash/"/>
    <id>https://liuhangya.github.io/2023/08/31/git/git_stash/</id>
    <published>2023-08-31T08:57:27.000Z</published>
    <updated>2023-08-31T08:57:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git 恢复进度</p><span id="more"></span><p>我们之前使用 <code>git stash</code> 命令，将当时的修改进行了保存，保存的内容为： <strong>新增了 <code>a/b/c/hello.txt</code> 文件，并添加了一行 <code>Bye Bye.</code> ，<code>welcome.txt</code> 文件新增了一行 <code>Bye Bye.</code></strong></p><p>实际上，恢复进度也是用这个命令。我们先看一下当前的分支状态和日志信息：</p><p><img src="/2023/08/31/git/git_stash/stash1.png"></p><p>现在，我们处于 master 分支上，，查看保存的进度命令如下：<code>git stash list</code></p><p><img src="/2023/08/31/git/git_stash/stash2.png"></p><p>可使用 <code>git stash pop</code> 从最近保存的进度进行恢复 ：</p><p><img src="/2023/08/31/git/git_stash/stash3.png"></p><p>可以看到，之前保存的内容全都恢复了，列表中的该保存记录被销毁了。仔细查看一下输出：<code>hello.txt</code> 文件已经 <code>add</code> 了 ，等待 <code>commit</code> ，<code>welcome.txt</code> 文件修改了，还没被 <code>add</code> ， <code>stash@&#123;0&#125;</code> 这个进度记录被 <code>drop</code>（删除）了。</p><p>再查看一下工作区的状态：</p><p><img src="/2023/08/31/git/git_stash/stash4.png"></p><p>发现跟恢复进度时的输出是一致的。</p><p>现在，我们根据之前学过的各种命令，进行各种操作：</p><ol><li>把当前暂存区的内容进行提交，即只提交 <code>a/b/c/hello.txt</code> ，不提交 <code>welcome.txt</code> ：</li></ol><p><img src="/2023/08/31/git/git_stash/stash5.png"></p><p><img src="/2023/08/31/git/git_stash/stash6.png"></p><p>可以看到<code> hello.txt</code> 文件被提交了，<code>welcome.txt</code> 文件并没有。</p><ol start="2"><li>现在后悔了，想回到之前的状态，想要撤回这个提交：</li></ol><p>可用命令 <code>git reset --soft HEAD^</code> ，注意要加上 <code>--soft</code> ，只是将分支提交记录回退到上一次提交。如果用默认的 <code>--mixed</code> ，会覆盖掉暂存区的。</p><p><img src="/2023/08/31/git/git_stash/stash7.png"></p><p>可以看到，之前提交的内容回来了，提交记录也是之前的。</p><ol start="3"><li>如果想把 <code>welcome.txt</code> 进行提交，而把 <code>hello.txt</code> 撤出暂存区，可以这样操作：</li></ol><p><img src="/2023/08/31/git/git_stash/stash8.png"></p><p><img src="/2023/08/31/git/git_stash/stash9.png"></p><p>这是 <code>reset</code> 的另一种用法，该用法不会改变引用，也不会改变工作区，而是用指定提交状态下（这里是 <code>HEAD</code>）的文件替换掉暂存区中的文件。会回到 <code>git add</code> 命令之前的状态。</p><ol start="4"><li>突然又不想提交 <code>welcome.txt</code> 文件，想从暂存区撤出（<code>git reset</code> 等价于 <code>git reset --mixed HEAD</code>） ：</li></ol><p><img src="/2023/08/31/git/git_stash/stash10.png"></p><ol start="5"><li>现在，想把工作区所有修改全部清除掉，包括 <code>welcome.txt</code> 的改动和目录 <code>a</code> 以及下面的子目录和文件，可以使用 <code>git checkout .</code> 命令：</li></ol><p><img src="/2023/08/31/git/git_stash/stash11.png"></p><p>现在工作区还有一个多余的目录 a ，<code>git clean -nd</code> 命令可以查看哪些文件和目录可以被删除，以免造成误删除：</p><p><img src="/2023/08/31/git/git_stash/stash12.png"></p><p>发现 a 目录是可以被正常删除的，这时候再强制删除多余的目录和文件：</p><p><img src="/2023/08/31/git/git_stash/stash13.png"></p><p><img src="/2023/08/31/git/git_stash/stash14.png"></p><p>此时，工作区变得非常干净了。</p><p>最后，我们再详细讲解一下 <code>git stash</code> 的用法：</p><p><code>git stash </code> 用于保存和恢复工作进度，这个命令非常有用。</p><ul><li><p>命令： <code>git stash</code><br>  作用：保存当前的工作进度，会分别对暂存区和工作区的状态进行保存。</p></li><li><p>命令：<code>git stash list</code><br>  作用：显示进度列表。很明显可以对工作进度进行多次保存操作，并且在恢复的时候可以进行选择。</p></li><li><p>命令： <code>git stash pop [ &lt;stash&gt; ]</code><br>  作用：如果不使用任何参数，默认恢复最新保存的工作进度，并将恢复的工作进度从存储列表中移除。如果加上 <code>stash</code> 参数(来自 <code>git stash list</code> 显示的列表)，则从指定 <code>stash</code> 中恢复，恢复之后也将该进度从存储列表中移除。</p></li><li><p>命令：  <code>git stash [ save ] [ -k ] [&lt;message&gt;]</code><br>作用：通过  save 可以在保存进度的时候指定存储说明，格式如下：<code>git stash save &quot;this is a message&quot;</code>，如果再加上 <code>-k</code> 参数，则保存进度之后不会将暂存区重置，默认会将暂存区和工作区强制重置。</p></li><li><p>命令： <code>git stash apply [ &lt;stash&gt; ]</code><br>  作用：跟 <code>git stash pop [ &lt;stash&gt; ]</code> 功能一样，但是恢复之后，该进度不会从存储列表中移除。</p></li><li><p>命令： <code>git stash drop [&lt;stash&gt;]</code><br>  作用：删除存储记录，默认删除最新保存的记录，可指定记录进行删除。</p></li><li><p>命令：<code>git stash clear</code><br>  作用：清空所有的存储记录。</p></li><li><p>命令：<code>git stash branch &lt;branch-name&gt; &lt;stash&gt;</code><br>  作用：基于存储记录来创建分支。（分支功能后面再讲）</p></li></ul><p>简单探秘一下 <code>git stash</code> 的机制，通过示例演示一下：</p><p>当前，我们没有存储任何进度，列表为空：</p><p><img src="/2023/08/31/git/git_stash/stash15.png"></p><p>在 <code>welcome.txt</code> 文件中添加一行 <code>Bye-Bye.</code> ，并创建 <code>hack-1.txt</code> 文件（文件内添加一行 <code>hello.</code>）：</p><p><img src="/2023/08/31/git/git_stash/stash16.png"></p><p>可以看到，暂存区中添加了新创建的 <code>hack-1.txt</code> ，修改过的<code> welcome.txt</code> 并没添加到暂存区，现在我们将当前的进度保存：</p><p><img src="/2023/08/31/git/git_stash/stash17.png"></p><p><img src="/2023/08/31/git/git_stash/stash18.png"></p><p>结果是：工作区恢复到了修改前的状态（实际使用了 <code>git reset --hard HEAD</code> 命令），文件 <code>welcome.txt</code> 的修改不见了，新增的文件 <code>hack-1.txt</code> 也不见了。</p><p>接下来，我们再做一个修改，新创建 <code>hack-2.txt</code> 文件，并添加一行文本为 <code>fix.</code> ，并尝试保存进度：</p><p><img src="/2023/08/31/git/git_stash/stash19.png"></p><p>很遗憾，保存失败，说没有任何变更内容需要保存。可见，本地没有被版本控制系统跟踪的文件并不能保存进度，只能先 <code>add</code> 再保存：</p><p><img src="/2023/08/31/git/git_stash/stash20.png"></p><p>现在有两个保存记录了，如下：</p><p><img src="/2023/08/31/git/git_stash/stash21.png"></p><p>在保存进度时，最好提供说明，这样可以更好地通过进度列表找到保存的进度。每个进度的标识都是 <code>stash@&#123;&lt;n&gt;&#125;</code> 格式，像极了前面介绍的 <code>reflog</code> 的格式。实际上， <code>git stash</code> 命令就是用前面介绍的引用和引用变更日志 <code>reflog</code> 实现的：</p><p><img src="/2023/08/31/git/git_stash/stash22.png"></p><p>可以看到，在 <code>.git/refs/</code> 和 <code>.git/logs/refs</code> 目录下，都存在 <code>stash</code> 文件。</p><p>跟分支引用一样， <code>refs/stash</code> 保存的就是 <code>statsh list </code> 中最新的提交ID ，还能看到该提交的相关记录：</p><p><img src="/2023/08/31/git/git_stash/stash23.png"></p><p><strong>简单总结一下：<code>git stash</code> 保存进度，实际上会将进度保存在引用 <code>refs/stash</code> 所指向的提交中。多次的进度保存，会指向最新的保存提交ID，而 <code>refs/stash</code> 引用的变化由 <code>logs/refs/stash</code> 记录下来。</strong></p><p>那么，引用(<code>refs/stash</code>) 是怎么同时保存暂存区进度和工作区中的进度呢？我们查看一下 <code>refs/stash</code> 的提交历史 【把 <code>stash</code> 看作分支对待】：</p><p><img src="/2023/08/31/git/git_stash/stash24.png"></p><p>提交说明中的 <code>WIP ，表示 Work In Progress</code> 工作区进度，而 <code>index on master ，包含 index 字眼</code>，表示暂存区进度。而且最新的提交是一个合并提交。</p><p>下面，我们来研究一下第一次的进度保存：</p><p><img src="/2023/08/31/git/git_stash/stash25.png"></p><p><img src="/2023/08/31/git/git_stash/stash26.png"></p><p>上面显示的三个提交对应着三棵不同的树。我们先把不同的状态区分出来，用 ‘原基线’ 代表进度保存时版本库的状态，即提交ID <code>4448fe8705</code> ；用 ‘原暂存区’ 代表进度保存时暂存区的状态，即提交ID <code>16ab29038</code> ；用 ‘原工作区’ 代表进度保存时工作区的状态，即提交ID <code>d0f05c922</code> ；</p><p>现在，开始对比各种差异：</p><p>^ 用法讲解： ^2 表示中的 2 表示是第几个父提交，比如上面的 <code>stash@&#123;1&#125;</code> 表示最新的提交 ID ， <code>stash@&#123;1&#125;^2</code> ，表示其中的第二个父提交，也就是 <code>16ab29038</code>，那么  <code>stash@&#123;1&#125;^2^</code> 就表示 <code>16ab29038</code> 的父提交，也就是 <code>4448fe8705</code></p><ol><li>原基线和原暂存区的差异比较：</li></ol><p><img src="/2023/08/31/git/git_stash/stash27.png"></p><p>刚好是第一次保存时，暂存区添加了新文件 <code>hack-1.txt</code> 并在里面添加了一行 <code>hello.</code> ;(不记得可以往前面的内容再看一下)</p><ol start="2"><li>原暂存区和原工作区的差异比较：</li></ol><p><img src="/2023/08/31/git/git_stash/stash28.png"></p><p>刚好是第一次保存时，工作区的 <code> welcome.txt</code> 中添加了一行 <code>Nice to meet you.</code> ;(不记得可以往前面的内容再看一下)</p><ol start="3"><li>原基线和原工作区的差异比较：</li></ol><p><img src="/2023/08/31/git/git_stash/stash29.png"></p><p>刚好是 1 和 2 的差异汇总 。</p><p>最后，我们用 <code>stash@&#123;1&#125;</code> 来恢复进度，再清空所有保存的进度：</p><p><img src="/2023/08/31/git/git_stash/stash30.png"></p><p><img src="/2023/08/31/git/git_stash/stash31.png"></p><p>清空之后，会发现 <code>stash</code> 相关的引用和 <code>reflog</code> 的 <code>stash</code> 文件都不见了，对不找对应的文件了：</p><p><img src="/2023/08/31/git/git_stash/stash32.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Git 恢复进度&lt;/p&gt;</summary>
    
    
    
    
    <category term="Git" scheme="https://liuhangya.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 检出</title>
    <link href="https://liuhangya.github.io/2023/08/31/git/git_checkout/"/>
    <id>https://liuhangya.github.io/2023/08/31/git/git_checkout/</id>
    <published>2023-08-31T08:29:37.000Z</published>
    <updated>2023-08-31T08:29:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git 检出</p><span id="more"></span><p>在上一节，我们使用 <code>reset</code> 命令修改了引用分支的游标位置，让分支引用(比如：<code>master</code> 分支) 指向不同的提交 <code>ID</code> ，达到切换不同历史版本内容。我们默认操作的就是 <code>master</code> 分支，因为 <code>.git/HEAD</code> 指向的引用就是 <code>refs/heads/master</code> 。怎么改变 <code>HEAD</code> 的指向呢？改变之后又有什么影响呢？下面通过 <code>checkout</code> 命令的使用来仔细分析一下。</p><p><code>HEAD</code> 的理解 ： 是头指针，当有提交时， <code>HEAD</code> 指向的提交将会作为新提交的父级提交（变成老二了，老大是新的提交） 。</p><p>首先，看一下目前 <code> HEAD</code> 指向是什么：</p><p><img src="/2023/08/31/git/git_checkout/checkout1.png"></p><p>可以看出，目前指向了分支 master ，可以通过如下命令查看目前所在分支信息：</p><p><img src="/2023/08/31/git/git_checkout/checkout2.png"></p><p>再看一下我们现有的提交记录：</p><p><img src="/2023/08/31/git/git_checkout/checkout3.png"></p><p>现在我们检出 befeee4 这个提交，看看会怎样：</p><p><img src="/2023/08/31/git/git_checkout/checkout4.png"></p><p>输出了一大段内容，大概意思如下：</p><blockquote><p>您正处于 “分离头指针” 状态，您可以检查、测试和提交而不影响任何分支。如果想保留此状态下的修改和提交，使用 <code>-c</code> 参数调用 <code>switch</code> 命令来创建新的跟踪分支。如 ：<code> git switch -c &lt;new-branch-name&gt;</code> ，您现在处于 <code>befeee4</code> ，提交说明为 <code>check staged -- nice to  meet you.</code></p></blockquote><p>查看一下此时的 <code>HEAD</code> 保存的内容：</p><p><img src="/2023/08/31/git/git_checkout/checkout5.png"></p><p>可以看到，保存的是一个具体的提交 <code>ID</code> ，而不是保存（分支）引用。</p><p>阶段性总结： “分离头指针” 状态指的就是 <code>HEAD</code> 头指针指向了一个提交 ID，而不是一个引用（分支）。</p><p>通过 <code>reflog</code> 查看日志时，也可以看到 <code>HEAD</code>  头指针更改了：由指向 <code>master</code> 分支变成了指向一个提交 <code>ID</code> 。</p><p><img src="/2023/08/31/git/git_checkout/checkout6.png"></p><p><strong>注意区分是 <code>master</code> 分支的变更还是 <code>HEAD</code> 头指针的变迁记录</strong></p><p>我们查一下当前的 <code>HEAD</code> 和 <code>master</code> 对应的提交 <code>ID</code> ，会发现它们的指向并不一样：</p><p><img src="/2023/08/31/git/git_checkout/checkout7.png"></p><p>可以看到，<code>master</code> 分支的指向并没有改变，仍旧指向原有的提交 <code>ID</code> ，这也说明了 <code>checkout</code> 命令和 <code>reset</code> 命令不同。</p><p>接下来，我们进行一些操作，分析一下输出结果 ：</p><ol><li>创建一个新文件（detached-commit.txt）并添加到暂存区中，查看一下状态：</li></ol><p><img src="/2023/08/31/git/git_checkout/checkout8.png"></p><pre><code>输出表明：当前处于 “分离头状态”，其实截图红框已经显示当前不处于任何分支中，而处于某个提交 `ID` 。</code></pre><ol start="2"><li>进行提交：</li></ol><p><img src="/2023/08/31/git/git_checkout/checkout9.png"></p><pre><code>输出表明：提交成功了，此时头指针指向了新的提交 `08b3f7e` 。</code></pre><ol start="3"><li>再次查看当前的 <code>HEAD</code> 内容：</li></ol><p><img src="/2023/08/31/git/git_checkout/checkout10.png"></p><pre><code>输出表明：仍然指向一个具体的 `ID` ，但是这个 ID 变成了最新的提交 `ID` 了，它的父 ID 是原来的 `befeee4`。在 `befeee4` 出现了分叉，分别指向 `08b3f7e` 和 `master` 分支原先的提交，因为 `08b3f7e` 本来就是 `master` 的历史提交。</code></pre><ol start="4"><li>查看一下提交日志，会发现：</li></ol><p><img src="/2023/08/31/git/git_checkout/checkout11.png"></p><pre><code>输出表明：新的提交确实是建立在之前的提交基础上的。</code></pre><ol start="5"><li>切换回到 <code>master</code> 分支 ：</li></ol><p><img src="/2023/08/31/git/git_checkout/checkout13.png"></p><pre><code>输出表明：已经切换到了 `master` 分支，但是在分离头状态有一个提交，最好通过 `branch` 命令给这个提交创建一个新分支。</code></pre><ol start="6"><li>再次查看当前的 <code>HEAD</code> 内容：</li></ol><p><img src="/2023/08/31/git/git_checkout/checkout14.png"></p><pre><code>输出表明：变回 `master` 引用 ，而不是具体提交 `ID` 了。</code></pre><ol start="7"><li>查询一下当前的提交历史：</li></ol><p><img src="/2023/08/31/git/git_checkout/checkout15.png"></p><pre><code>输出表明：完全是之前 master 的提交历史了，之前在分离头状态的提交查不到了，新增的文件也不见了。</code></pre><p>我们之前在分离头状态的提交还存在于版本库的对象库中吗？</p><p>我们验证一下：</p><p><img src="/2023/08/31/git/git_checkout/checkout16.png"></p><p>可以看到这个提交仍在版本库中。<br><strong>注意：由于这个提交没有被任何分支跟踪，因此并不能保证这个提交会永久存在。实际上当 reflog 中含有该提交的日志过期后，这个提交随时都会从版本库中移除</strong>。</p><p>因为没有给提交 <code>ID</code> （<code>08b3f7e</code>）创建分支来跟踪，所以不能通过分支引用来访问，而且随时可能被清除（实际项目中要新建分支来追踪），非常不方便。</p><p>如果这个提交是 <code>master</code> 分支所需要的，怎么办呢？</p><p>答：不能用 <code>reset</code> 命令，那样会丢掉 <code>master</code> 分支原来的提交，相当于现在历史链条中存在了分叉路，只能使用 <code>merge</code> 命令进行合并操作。</p><p>方案确认了，开始进行具体的合并操作：</p><p><img src="/2023/08/31/git/git_checkout/checkout17.png"></p><p>先确认了当前处于哪个分支，接着进行 <code>merge</code> 操作，然后查看了文件列表和提交日志。日志表明出现了分叉，<code>31ab701</code> 在<code> master</code> 分支，<code>08b3f7e</code> 在分离头状态下提交的，最终在合并在新的提交 ID <code>4448fe87</code> 中 。</p><p>如果仔细查看一下最新提交，会发现这个提交有两个父提交，这就是合并的奥秘：</p><p><img src="/2023/08/31/git/git_checkout/checkout18.png"></p><p>最后，我们再深入了解一下 <code>git checkout</code> 命令：</p><ol><li><p><code>git checkout &lt;branch&gt;</code></p><p>这种用法会改变 <code>HEAD</code> 头指针，通过切换分支来对提交进行跟踪，主要作用就是切换分支。</p></li><li><p><code>git checkout [-m] [-b|--orphan &lt;new_branch&gt;] [start_point]</code></p><p> 这种用法主要是创建并切换到新的分支，新的分支从 <code>start_point</code> 指定的提交开始创建(默认从最新提交开始)。新分支和 <code>master</code> 分支没有什么不一样的，都是 <code>refs/heads</code> 命名空间下的引用。</p></li><li><p><code>git checkout branch</code> </p><p> 检出 <code>branch</code> 分支 ，更新 <code>HEAD</code> 指向 <code>branch</code> 分支，以及用 <code>branch</code> 指向的树更新暂存区和工作区。</p></li><li><p><code>git checkout -- filename</code> </p><p> 用暂存区中的 <code>filename</code> 文件覆盖工作区中的 <code>filename</code> 文件 。相当于取消自上次执行 <code>git add filename</code> 以来的本地修改。</p></li><li><p><code>git checkout branch -- filename</code></p><p><code>HEAD</code> 的指向不变，用 <code>branch</code> 所指向的分支的提交中的 <code>filename</code> 文件替换暂存区和工作中相应的文件，会直接覆盖掉。</p></li><li><p><code>git checkout .</code> </p><p> 这条命令比较危险，会直接取消本地的所有修改，相当于用暂存区的所有文件直接覆盖本地文件，不给用户任何确认的机会！</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Git 检出&lt;/p&gt;</summary>
    
    
    
    
    <category term="Git" scheme="https://liuhangya.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 重置</title>
    <link href="https://liuhangya.github.io/2023/08/31/git/git_reset/"/>
    <id>https://liuhangya.github.io/2023/08/31/git/git_reset/</id>
    <published>2023-08-31T07:20:00.000Z</published>
    <updated>2023-08-31T07:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git 重置</p><span id="more"></span><p>首先，我们看一下版本库提交历史记录：</p><p><img src="/2023/08/31/git/git_reset/reset1.png"></p><p>通过 <code>--oneline</code> 可以显示更短小的提交 <code>ID</code> 。</p><p>如果我们改变了分支文件中记录的提交 <code>ID</code> ，是不是就可以实现任意提交历史的内容切换呢？是的 ，接下来通过研究 <code>git reset</code> 命令来改变分支引用文件的提交 <code>ID</code>，实现分支内容的重置。</p><p>那么，开始操作吧，先看看现在分支中指向的提交 <code>ID</code> 是什么：</p><p><img src="/2023/08/31/git/git_reset/reset2.png"></p><p>正是我们第二次提交的 <code>ID</code> 。</p><p>接下来我们创建一个文件，再进行一次提交，看看 <code>master</code> 分支会不会自动指向最新的提交 <code>ID</code> ：</p><p><img src="/2023/08/31/git/git_reset/reset3.png"></p><p>果然指向了最新的提交 <code>ID</code> 。</p><p><strong><code>master</code> 就像一个游标，可上下浮动，最上方就是指向最新的提交 ID ，向下就可以指向历史提交了，而改变这个游标位置的命令就是 reset 命令</strong>。</p><p><code>reset</code> 命令会有一些参数，接下来会细讲。</p><p>我们可以通过 <code>reset</code> 回到上一次的提交记录，如下：</p><p><img src="/2023/08/31/git/git_reset/reset4.png"></p><p>输出表明，确实回到上一次提交了，最新的提交记录和文件都不见了。</p><p>其实我们可以通过提交 <code>ID</code> 来重置到任意提交记录，我们重置到初始的提交记录试试：</p><p><img src="/2023/08/31/git/git_reset/reset5.png"></p><p>重置成功了， <code>welcome.txt</code> 文件内容只有 <code> Hello.</code>  了 。</p><p>注意：重置后，历史记录也被丢弃了，通过 <code>git log</code> 命令查询到的历史记录只能从当前的记录到以前的记录，比如现在我们查询到的历史记录只有一条了。</p><p>那我们怎么重置到最近的提交记录呢？</p><p>答：还有一个挽救机制，通过 <code>.git/logs</code> 目录下的日志文件，该日志文件记录了分支的各种变更。**</p><p>我们通过 <code>tail</code> 命令查看一下最后5行的文件内容：</p><p><img src="/2023/08/31/git/git_reset/reset6.png"></p><p>最新的变更是追加到后面的，这个日志文件很明确地显示了提交 <code>ID</code> 的变动以及变动原因，是 <code>commit</code> 还是 <code>reset</code> 还可能是其他的原因。</p><p>通过 <code>git reflog</code> 命令也可以对这个文件进行操作，使用 <code>show</code> 子命令可以显示文件内容：</p><p><img src="/2023/08/31/git/git_reset/reset7.png"></p><p>与通过 <code>tail</code> 直接查询文件内容不同，最新的改变是显示到最前面的，而且只显示每次操作后的最终的提交 <code>ID</code> ，还有一个容易记忆的 <code>&lt;refname&gt;@&#123;n&#125;</code> 表达式代表指向的提交 <code>ID</code> ，这里的 <code>refname</code> 代表的引用名，这里是 <code>master</code> 。 <code>master@&#123;2&#125;</code> 代表 <code>31ab701</code></p><p>现在，我们回到最新的提交：</p><p><img src="/2023/08/31/git/git_reset/reset8.png"></p><p>工作区中新增的文件回来了，提交历史也回来了。如果此时我们通过 <code>reflog</code> 查看，就会看到恢复 <code>master</code> 的操作也记录在日志中了：</p><p><img src="/2023/08/31/git/git_reset/reset9.png"></p><p>reset 命令是常用的命令之一，同时也是最危险最容易误用的命令，常用用法如下：</p><p> <code>git reset [ --soft | --mixed | --hard ] [commit]</code></p><ol><li><p>使用参数 <code>--soft</code> ，如： git reset –soft [commit] ，会有如下改动：</p><p><strong>替换引用，指向目标记录ID 。不改变暂存区和工作区。</strong></p></li><li><p>使用参数 <code>--mixed</code> 或不使用参数（默认就是 <code>--mixed</code>），如： <code>git reset --mixed [commit]</code> ，会有如下改动：</p><p><strong>替换引用，指向目标记录ID 。替换暂存区，暂存区的内容和引用指向的目录树内容一致。但不改变工作区。</strong></p></li><li><p>使用参数 <code>--hard</code>  ，如： <code>git reset --hard [commit]</code> ，会有如下改动：</p><p><strong>替换引用，指向目标记录ID 。替换暂存区，暂存区的内容和引用指向的目录树内容一致。并且替换工作区，工作区和暂存区和引用指向的目录树内容一致。</strong></p></li></ol><p>最后，我们再看一下 <code>reset</code> 命令的不同用法：</p><ul><li><p>命令： <code>git reset</code> ，相当于 <code>git reset HEAD</code> ，相当于 <code>git reset --mixed HEAD</code> </p><p>仅用 <code>HEAD</code> 指向的目录树重置暂存区、工作区不受影响，相当于之前用 <code>git add</code> 命令添加到暂存区的内容撤出暂存区。引用的提交 <code>ID</code> 不变。</p></li><li><p>命令：<code>git reset -- filename</code> ，相当于 <code>git reset HEAD --filename</code> </p><p>仅将文件 <code>filename</code> 的改动撤出暂存区，其他文件不变。相当于命令 <code>git add filename</code> 的反向操作 。</p></li><li><p>命令：<code>git reset HEAD^</code> ，相当于 <code>git reset --mixed HEAD^</code> 。</p><p>工作区不改变，但是暂存区会回退到上一次提交之前，引用也会回退到上一次 。</p></li><li><p>命令：<code>git reset --hard HEAD^ </code></p><p>工作区、暂存区和引用全都回退到上一次提交的状态，最新的提交内容全部丢掉 。</p></li></ul><p><strong>其他知识：<code>.git/COMMIT_EDITMSG</code>  文件保存了目前最新的提交描述说明，当前提交说明如下：</strong></p><p><img src="/2023/08/31/git/git_reset/reset10.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Git 重置&lt;/p&gt;</summary>
    
    
    
    
    <category term="Git" scheme="https://liuhangya.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 对象</title>
    <link href="https://liuhangya.github.io/2023/08/31/git/git_object/"/>
    <id>https://liuhangya.github.io/2023/08/31/git/git_object/</id>
    <published>2023-08-31T06:39:37.000Z</published>
    <updated>2023-08-31T06:39:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git 对象</p><span id="more"></span><p>我们先查看一下当前最新的提交日志(<code>-1</code> 表明最新一条，<code>--pretty=raw</code> 表示详细输出 )：</p><p><img src="/2023/08/31/git/git_object/object1.png"></p><p>一个提交包含三个哈希值：</p><ul><li><p>commit ： 表示这是本次提交的唯一标识。</p></li><li><p>tree ： 表示这是本次提交所对应的目录树。</p></li><li><p>parent ： 表示本地提交的父提交（上一次提交）。</p></li></ul><p>可以通过 <code>git cat-file -t</code> 命令查看 <code>ID</code> 的类型 ：</p><p><img src="/2023/08/31/git/git_object/object2.png"></p><p>在引用对象 <code>ID</code> 时，可以不写全 40 位，只要开头几位不冲突即可。</p><p>可以通过 <code>git cat-file -p</code> 命令 查看 <code>ID</code> 的内容 ：</p><p><img src="/2023/08/31/git/git_object/object3.png"></p><p>接着，我们查看当前 <code>tree ID</code> 的内容 ：</p><p><img src="/2023/08/31/git/git_object/object4.png"></p><p>根据 <code>tree ID</code> 的内容可知道具体保存的内容的 <code>ID</code> ，我们查看这个内容 <code>ID</code>（应该是一个类似指针一样的，指向具体保存的内容）：</p><p><img src="/2023/08/31/git/git_object/object5.png"></p><p>里面的内容就是我们第二次提交的 <code>welcome.txt</code> 文件保存的内容。（每次提交涉及到的文件的最新内容都会被保存在当前提交中，用于文件恢复和对比等操作）</p><p>我们再查一下最初提交的内容（在这里刚好是 <code>perent ID</code> 的内容）：</p><p><img src="/2023/08/31/git/git_object/object6.png"></p><p>很清楚，我们第一次提交的 <code>welcome.txt</code> 文件内容就是 <code>Hello.</code></p><p>这些文件内容都保存在 <code>.git/objects</code> 目录下，<code>ID</code> 前两位做为目录名，后 38 位作为文件名。</p><p><img src="/2023/08/31/git/git_object/object7.png"></p><p>阶段性总结：文件树中记录了当前提交的各个文件的修改信息，通过 <code>ID</code> 找到 <code>.git/objects</code> 下对应的文件内容。</p><p>在上一节，我们通过 <code>git stash</code> 来保存了我们修改的内容，工作区中干净的，用【精简并显示分支】的形式查看状态看看：</p><p><img src="/2023/08/31/git/git_object/object8.png"></p><p>也可以通过<code> git branch</code> 命令来查看当前工作的分支，星号表示这个分支是当前分支，目录暂无其他分支（分支内容后面再介绍）。</p><p><img src="/2023/08/31/git/git_object/object9.png"></p><p>输出表明，我们现处于 <code>master</code> 分支中，这是什么意思呢？暂时先不管，我们运行以下三个命令来看下结果是什么：</p><p><img src="/2023/08/31/git/git_object/object10.png"></p><p>输出表明，在当前版本库中，<code>HEAD</code> 、<code>master</code> 和 <code>refs/heads/master</code> 具有相同的指向。</p><p><img src="/2023/08/31/git/git_object/object11.png"></p><p>通过上述命令，我们知道了 <code>HEAD</code> 和 <code>master</code>  的文件路径，<code>logs</code> 目录下的文件暂不研究。</p><p>那么 <code>HEAD</code> 和 <code>master</code> 保存的内容是什么呢？</p><p><img src="/2023/08/31/git/git_object/object12.png"></p><p>总结：</p><ol><li><p><code>HEAD</code> 保存的其实是指向的一个引用，这个引用就是当前的分支，现在指向的分支是  <code>.git/refs/heads/master</code> ，分支名叫 <code>master</code> ，所以 <code>git log -1 refs/heads/master</code> 和 <code>git log -1 master</code> 是等价的，后者只是简写而已。后续如果有不同的分支，每个分支会生成一个文件保存在这个目录下。</p></li><li><p>分支文件保存的内容是当前分支最新的提交 <code>ID</code> ，根据该 <code>ID</code> 可以查到最新的提交记录，而根据记录的 <code>parent ID</code> 可以知道上一次提交记录，这样就能追踪到完整的提交历史记录链，真的是相当巧妙！</p></li></ol><p>如下是一个更接近于真实的版本库结构图：</p><p><img src="/2023/08/31/git/git_object/object13.png"></p><p>其实 Git 还有一个命令可以用于显示对应的提交 ID ，如下：</p><p><img src="/2023/08/31/git/git_object/object14.png"></p><p> Git 中提供了很多方法可以方便地访问库中的对象：</p><p><img src="/2023/08/31/git/git_object/object15.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Git 对象&lt;/p&gt;</summary>
    
    
    
    
    <category term="Git" scheme="https://liuhangya.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 暂存区</title>
    <link href="https://liuhangya.github.io/2023/08/31/git/git_staged/"/>
    <id>https://liuhangya.github.io/2023/08/31/git/git_staged/</id>
    <published>2023-08-31T02:45:55.000Z</published>
    <updated>2023-08-31T02:45:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git 暂存区</p><span id="more"></span><p>可以用 <code>git log</code> 查看提交日志，加上 <code>--stat</code> 参数可以看到每次提交的文件变更统计 。</p><p><img src="/2023/08/31/git/git_staged/stash1.png"></p><p>在 <code>welcome.txt</code> 中添加一行 <code>Nice to meet you.</code> 。然后通过 <code>git diff</code> 来对比修改后的文件和中间状态的文件的差别。</p><p><img src="/2023/08/31/git/git_staged/stash2.png"></p><p>现在提交试试：</p><p><img src="/2023/08/31/git/git_staged/stash3.png"></p><p>输出表示：提交失败，没有需要提交的文件。</p><p>假设提交成功，会有新的提交记录，通过日志【精简显示】 ： <code>git log --pretty=oneline</code> 可知，只有之前提交的一条记录，证明没提交成功 。</p><p><img src="/2023/08/31/git/git_staged/stash4.png"></p><p>通过 <code>git status</code> 查看状态，发现输出和使用 <code>git commit</code> 命令是一样的：</p><p><img src="/2023/08/31/git/git_staged/stash5.png"></p><p>查看状态【精简显示】： <code>git status -s</code> 可知，<code> welcome.txt</code> 文件被修改了。</p><p><img src="/2023/08/31/git/git_staged/stash6.png"></p><p>我们再仔细查看一下上述 <code>git status</code> 命令的输出内容：需要对修改的 <code>welcome.txt</code> 文件执行 <code>git add</code> 操作，将修改的文件添加到 “提交任务”中，才能提交！</p><p>那么，按照要求来：</p><p><img src="/2023/08/31/git/git_staged/stash7.png"></p><p>接着再 <code>git diff</code> 对比一下，发现没有任何输出：</p><p><img src="/2023/08/31/git/git_staged/stash8.png"></p><p>注意：我们并没有提交代码，只是将这个文件标记为了等待提交状态。</p><p> <strong>为什么没有任何输出呢？？？</strong></p><p><strong>答：因为 <code>git diff</code> 默认对比的是本地文件【工作区】和中间状态【暂存区】的差异，我们已经通过 <code>git add</code> 更新了暂存区文件了，因此两者文件一致了，就没有任何差异了。</strong></p><p>如果我们通过与 <code>HEAD</code>（当前版本库的头指针）或 <code>master</code> 分支（当前工作分支）进行比较，就会发现有差异，毕竟还没提交嘛：</p><p><img src="/2023/08/31/git/git_staged/stash9.png"></p><p>我们再通过 <code>git status</code> 查看一下状态：</p><p><img src="/2023/08/31/git/git_staged/stash10.png"></p><p>输出明确表示了，文件可以被 <code>commit</code> 了，而且还可以通过 <code>restore</code> 命令从暂存区中撤回。</p><p>如果查看状态【精简显示】： <code>git status -s</code> ，是这样显示的：</p><p><img src="/2023/08/31/git/git_staged/stash11.png"></p><p>跟之前没加入暂存区的状态比较一下：</p><p><img src="/2023/08/31/git/git_staged/stash12.png"></p><p>我们发现有如下几点是不一样的 ：</p><ol><li><p>颜色输出是不一样，没加入暂存区的时候是红色的，加入之后是绿色的。</p></li><li><p><code>M</code> 的位置不一样，没加入之前，前面还有一个空格，加入之后是在首列，没有空格。</p></li></ol><p>继续来操作，在 <code>welcome.txt</code> 中再加入一行：</p><p><img src="/2023/08/31/git/git_staged/stash13.png"></p><p> 查看一下状态 <code>git status</code> :</p><p><img src="/2023/08/31/git/git_staged/stash14.png"></p><p> 再查看一下精简状态 <code>git status -s</code> :</p><p><img src="/2023/08/31/git/git_staged/stash15.png"></p><p>怎么理解同一个文件即有红色的输出，也有绿色的输出呢？</p><p>可以这样理解：工作区中的文件跟暂存区中的对比，工作区的文件有修改（红色输出），暂存区中的文件跟版本库中的文件对比也有修改（绿色输出）。</p><p>现在 <code>welcome.txt</code> 有三个不同的版本，一个在工作区，一个在等待提交的暂存区，一个是版本库中最新的版本，我们可以通过 <code>git diff</code> 命令再加上不同的参数来查看不同状态下的差异：</p><ol><li>不带任何参数，对比的是工作区与暂存区的差异：</li></ol><p><img src="/2023/08/31/git/git_staged/stash16.png"></p><p>输出说明 ： 工作区比暂存区多了一行 <code>Bye Bye.</code></p><ol start="2"><li>加上 HEAD ，对比的是工作区跟版本库当前工作分支：</li></ol><p><img src="/2023/08/31/git/git_staged/stash17.png"></p><p>输出说明 ： 工作区的比版本库当前工作分支多了两行 </p><pre><code>  Nice to meet you.  Bye Bye.</code></pre><ol start="3"><li>加上 <code>--cached</code> 或 <code>--staged</code> ，对比的是暂存区和版本库当前工作分支：</li></ol><p><img src="/2023/08/31/git/git_staged/stash18.png"></p><p>输出说明 ： 暂存区的比版本库当前工作分支多了一行 <code>Nice to meet you.</code></p><p>最后，我们进行提交，将暂存区的内容提交到版本库中，工作区的修改是不会被提交的，因为现在只将改动 <code>Nice to  meet you</code> 提交到了暂存区，<code>Bye Bye</code> 还是在工作区中的，并不会被提交。</p><p><img src="/2023/08/31/git/git_staged/stash19.png"></p><p>显示提交成功，根据描述，有一个文件改动了，插入了一行，正是 <code>Nice to  meet you</code> 这一行。</p><p>查看一下【精简日志】看看：</p><p><img src="/2023/08/31/git/git_staged/stash20.png"></p><p>查看精简【精简状态】看看：</p><p><img src="/2023/08/31/git/git_staged/stash21.png"></p><p>只看到一个没有提交到暂存区的提示了。因为<code> Bye Bye.</code> 这一行内容还在工作区中，并没提交到暂存区。</p><p>对比一下差异看看：</p><p><img src="/2023/08/31/git/git_staged/stash22.png"></p><p>跟我们分析的一模一样的。</p><p>下图展示简化后的工作区、版本库的暂存区和版本库之间的关系：</p><p><img src="/2023/08/31/git/git_staged/stash37.png"></p><p> 休息一下，继续操作：</p><ol><li>通过 <code>checkout</code> 命令，撤销工作区中 <code>welcome.txt</code> 文件的修改 ：</li></ol><p><img src="/2023/08/31/git/git_staged/stash23.png"></p><p>可以看到工作区非常干净，没有任何改动了。上述操作其实是用暂存区中的 <code>filename</code> 文件覆盖掉工作区中的 <code>filename</code> 文件 。那么还没 <code>add</code> 的修改肯定就没了。</p><ol start="2"><li>查看一下 <code>.git/index</code> 文件，特别注意一下时间：</li></ol><p><img src="/2023/08/31/git/git_staged/stash24.png"></p><ol start="3"><li>现在更改一下时间戳，但是不改变它的内容，再次查看时间：</li></ol><p><img src="/2023/08/31/git/git_staged/stash25.png"></p><p> 上述操作表明：工作区扫描改动的时候，是根据 <code>.git/index</code> 文件中记录的时间、长度等信息判断工作区文件是否改变的。如果改变了，说明文件的内容可能也被改变了，再打开文件读取文件内容，与更改前的原始文件相比较，判断文件内容是否更改，同时该文件的新的时间戳会被记录到 <code>index</code> 文件中，这样扫描会更高效。</p><p><code> .git/index</code> 文件：是一个包含文件索引的目录树，记录了文件名和文件的状态信息，文件的内容并没有存储在其中，而是保存在 <code>.git/objects</code> 目录中，文件索引建立了文件和对象库中对象实体之间的对应。</p><p>总结： 可以理解为有一个工作区目录，一个暂存区虚拟目录，一个版本库目录，工作区目录的文件需要先添加到暂存区，暂存区的内容需要提交到版本库。其中工作区可能存在未添加的文件，暂存区可能存在未提交的文件，<code>git</code> 的各种命令就是操作它们之间的文件、对文件进行覆盖、恢复、撤回等操作。</p><p>版本库中的目录树查看：</p><p><img src="/2023/08/31/git/git_staged/stash26.png"></p><p>从左到右分别显示的是：文件属性、<code>blob</code> 对象、<code>ID</code>(SHA1哈希值格式)、文件大小、文件名。</p><p>我们先清除工作区当前的改动： <code>git clean -fd</code>  ，然后用暂存区的内容覆盖工作区 :  <code>git checkout .</code>  ，接着，创建 <code>a/b/c/hello.txt</code> 文件并创建相应文件夹 ，并在 <code>welcome.txt</code> 中增加一行 <code>Bye Bye.</code></p><p>现在对比一下跟暂存区的差异：</p><p><img src="/2023/08/31/git/git_staged/stash27.png"></p><p>可以看出，确实在<code> welcome.txt</code> 中增加一行 <code>Bye Bye.</code> ，但是没有显示出新的 <code>hello.txt</code> 文件，因为新文件是没被追踪的，所以无法对比，我们用 <code>git status</code> 查看一下状态就能知道：</p><p><img src="/2023/08/31/git/git_staged/stash28.png"></p><p><img src="/2023/08/31/git/git_staged/stash29.png"></p><p>输出表明，连第一层的 <code>a</code> 文件夹都没识别出来，更别说里面的文件了。</p><p>我们用 <code>git add .</code> 一次性将没被追踪的文件添加到暂存区，再次查看状态：</p><p><img src="/2023/08/31/git/git_staged/stash30.png"></p><p>我们再在 <code>hello.txt</code> 中增加一行 <code>Bye Bye.</code>  ，看一下状态：</p><p><img src="/2023/08/31/git/git_staged/stash31.png"></p><p>目前为止，我们知道现在工作区、暂存区和版本库之差的内容是有差异的。</p><ul><li>对比工作区和暂存区，可知工作区的 <code>hello.txt</code> 文件增加了一行 <code>Bye Bye.</code></li></ul><p><img src="/2023/08/31/git/git_staged/stash32.png"></p><ul><li>对比暂存区和版本库，可知暂存区增加了 <code>hello.txt</code> 文件，<code>welcome.txt</code> 增加了一行<code> Bye Bye.</code></li></ul><p><img src="/2023/08/31/git/git_staged/stash33.png"></p><ul><li>对比工作区和版本库，可知工作区增加了 <code>hello.txt</code> 文件 ，并添加了一行<code> Bye Bye.</code> ，welcome.txt 文件新增加了一行 <code>Bye Bye.</code></li></ul><p><img src="/2023/08/31/git/git_staged/stash34.png"></p><p> 最后，我们将保存当前的工作进度，在研究了 <code>HEAD</code> 和 <code>master</code> 分支的机制之后，再继续对暂存区进行研究。</p><p><img src="/2023/08/31/git/git_staged/stash35.png"></p><p><img src="/2023/08/31/git/git_staged/stash36.png"></p><p>现在，工作区和暂存区的改动全都不见了，干干净净。（暂存的内容为添加了 <code>a/b/c/hello.txt</code> 文件，并添加了一行 <code>Bye Bye.</code> ，<code>welcome.txt</code> 文件新增了一行 <code>Bye Bye.</code>）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Git 暂存区&lt;/p&gt;</summary>
    
    
    
    
    <category term="Git" scheme="https://liuhangya.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 初识</title>
    <link href="https://liuhangya.github.io/2023/08/30/git/git_start/"/>
    <id>https://liuhangya.github.io/2023/08/30/git/git_start/</id>
    <published>2023-08-30T07:11:26.000Z</published>
    <updated>2023-08-30T07:11:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git 初识</p><span id="more"></span><p><strong>查看版本：</strong> <code>git --version</code></p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start1.png?raw=true"></p><p><strong>查看配置列表：</strong> <code>git config --list</code></p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start2.png?raw=true"></p><p><strong>配置用户名和邮箱地址：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;fanda&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;xxxx.com&quot;</span><br></pre></td></tr></table></figure><p><strong>单独查询某条配置，比如：</strong></p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start3.png?raw=true"></p><p><strong>开始详细操作演示：</strong></p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start4.png?raw=true"></p><p>**操作文件夹为: ** <code>e/git_study/demo</code></p><p>通过 <code>git init</code> 命令来初始化版本库，默认会在工作区创建一个隐藏目录 <code>.git</code>  ，这个 <code>.git</code> 就是版本仓库 ，可通过 <code>ls -a</code> 查看隐藏的目录。</p><p>现在 <code>demo</code> 目录就是工作区，目前除了 <code>.git</code> 目录外空无一物。</p><p>我们添加一个文件 <code> welcome.txt</code> 并编辑内容为 <code>Hello.</code></p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start5.png?raw=true"></p><p>可通过 <code>git status</code> 来查看当前工作区的状态如下：</p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start6.png?raw=true"></p><p>输出表示，没有任何内容可提交，但是出现了未被追踪的文件，应该先通过 <code>git add</code> 将文件追踪。</p><p><strong>添加并提交文件：</strong></p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start7.png?raw=true"></p><p><strong>提交结果说明：</strong></p><ol><li><p>第一行: 在名为 <code>master</code> 的分支上，且是该分支的第一个提交( <code>root-commit</code> ) ，提交 <code>ID</code> 为 <code>174d90b</code> ，提交描述为 <code>initialized.</code> 。</p></li><li><p>第二行: 提交修改了一个文件，包含一行插入。</p></li><li><p>第三行：此次提交创建了新文件 <code>welcome.txt</code> 。</p></li></ol><p><strong>阶段性总结：<code>.git</code> 所在目录就是工作区的根目录，<code>git</code> 的相关操作要在工作区中才能正常执行，当在工作区的子目录中操作时，会递归查找 <code>.git</code> 目录。</strong></p><p><strong>如果在工作区外操作，会报错：</strong></p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start8.png?raw=true"></p><p>可通过 <code>git rev-parse --git-dir</code> 命令来查看 <code>.git</code> 所在的目录 ：</p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start9.png?raw=true"></p><p>可通过 <code>git rev-parse --show-toplevel</code> 命令来查看工作区根目录：</p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start10.png?raw=true"></p><p>可通过 <code> git clone</code> 命令来备份仓库 ：</p><p><img src="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start11.png?raw=true"></p><p>如上，我们把 <code>demo</code> 备份为了名为 <code>demo-step-1</code> 的文件夹。</p><p><strong>注意：备份时，目录路径为 <code>git_study</code> ，而不是 <code>demo</code> ，是 <code>demo</code> 的上一级 。</strong></p><p><strong>三个不同级别的配置文件：</strong></p><ul><li><p>版本库的配置文件：就是当前工作区的 <code>.git/config</code> 文件 。 <code>git config -e</code> 命令可查看 , <code>:wq</code> 退出编辑，注意先输入冒号。</p></li><li><p>全局配置文件：用户主目录下的 <code>.gitconfig</code> 文件 。 <code>git config -e --global</code> 命令可查看 , <code>:wq</code> 退出编辑，注意先输入冒号。</p></li><li><p>系统级配置文件： <code>/etc</code> 目录下。命令 <code>git config -e --system</code> 可查看 , <code>:q</code> 退出编辑，注意先输入冒号，系统文件不可写。</p></li></ul><p><strong>配置文件生效优先级：版本库级别的配置文件的优先级最高，全局配置文件次之，系统级配置文件排最后。相同的配置按优先级进行覆盖。</strong></p><p><strong>总结：版本创建三部曲，<code>git init</code> 、<code>git add</code> 、<code>git commit</code> 。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Git 初识&lt;/p&gt;</summary>
    
    
    
    
    <category term="Git" scheme="https://liuhangya.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>hexo命令使用</title>
    <link href="https://liuhangya.github.io/2023/08/30/hexo-use/"/>
    <id>https://liuhangya.github.io/2023/08/30/hexo-use/</id>
    <published>2023-08-30T06:51:01.000Z</published>
    <updated>2023-08-30T06:51:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>hexo命令使用</p><span id="more"></span><ol><li><p>hexo s或hexo server  : 启动服务，默认地址为<a href="http://localhost:4000/%EF%BC%8C4000%E7%AB%AF%E5%8F%A3">http://localhost:4000/，4000端口</a></p></li><li><p>hexo d或hexo deploy  : 部署站点，在本地生成.deploy_git文件夹，并将编译后的文件上传至 GitHub。</p></li><li><p>hexo new xxx pagename  : 例如： hexo new photo “my-first-blog” 上述指令执行时，Hexo 会尝试在 scaffolds 中寻找photo.md布局，若找到，则根据该布局新建文章；若未找到或指令中未指定该参数，则使用post.md新建文章。新建文章的名称在_config.yml中配置。</p></li><li><p>hexo clean   : 将 public 文件夹删除</p></li><li><p>hexo g或hexo generate  ：该命令执行后在hexo站点根目录下生成public文件夹</p></li><li><p>可以这样创建指定目录下的文件 ： hexo new page -p git&#x2F;git_start</p></li><li><p>hexo g -d ： 可以这样一步生成并部署</p></li><li><p>图片使用： 创建文章时，会默认创建图片对应的文件夹。将文件放在里面即可。随后直接引用图片就可以在文章中显示了。之后，上传部署到远程，找到对应的图片地址后再拼接?raw&#x3D;true ，比如：<br>“<a href="https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start1.png?raw=true&quot;">https://github.com/liuhangya/liuhangya.github.io/blob/main/2023/08/30/git/git_start/start1.png?raw=true&quot;</a> ，就能正常使用了远程地址而不是本地地址了。</p></li><li><p>E:\blog\scaffolds 下的文件可以定义文章模板，也就是创建文章时的默认显示。</p></li></ol><p>主题使用如下：<br>    E:\blog\themes\hexo-theme-ocean\source\css_partial 目录下：</p><pre><code>1. \gallery.styl  该文件下的样式可以修改博客首页面文章列表展示样式2. \tocbot.styl   该文件下的样式修改文章内的右侧菜单样式3. \article.styl  该文件下的样式修改文章详情的样式E:\blog\themes\hexo-theme-ocean\source\css下的 _variables.styl 样式修改全局的变量值</code></pre><p>文章布局如下： </p><hr><p>title: livedata<br>date: 2022-06-06 14:23:54<br>&#x2F;&#x2F; 标签<br>tags: jetpack android<br>&#x2F;&#x2F; 是否置顶<br>&#x2F;&#x2F; 是否生成文章目录，默认根据 md 样式在右边生成显示<br>top: ture<br>toc: ture<br>&#x2F;&#x2F; 这是封面图片<br>photos: [<br>        [“<a href="https://github.com/liuhangya/liuhangya.github.io/blob/main/gallery/index/juanjuan01.jpg?raw=true&quot;%5D">https://github.com/liuhangya/liuhangya.github.io/blob/main/gallery/index/juanjuan01.jpg?raw=true&quot;]</a><br>]</p><hr><p>这是显示在文章列表中的概要</p><!--more-->]]></content>
    
    
    <summary type="html">&lt;p&gt;hexo命令使用&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Android 架构演进分析和代码演示</title>
    <link href="https://liuhangya.github.io/2023/08/29/android/architecture/architecture/"/>
    <id>https://liuhangya.github.io/2023/08/29/android/architecture/architecture/</id>
    <published>2023-08-29T07:15:51.000Z</published>
    <updated>2023-08-29T07:15:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>架构演进分析和代码演示</p><span id="more"></span><h2 id="一、架构的使命和目的"><a href="#一、架构的使命和目的" class="headerlink" title="一、架构的使命和目的"></a>一、架构的使命和目的</h2><ol><li>架构的首要技术使命是“管理复杂度”，低复杂度才能降低理解成本和沟通难度，提升应对变更的灵活性，减少重复劳动，最终提高代码质量。</li><li>架构的目的在于“将复杂度分层”，不要将复杂度会在同一层次展开，那样会形式所谓的上帝类【比如，超1000行代码的Activity】。将复杂度会层，每一层功能独立且单一职责，这样才能尽可能地减少因为改动而导致的影响面。</li><li>为了降低客户端领域开发的复杂度，架构也在不断地演进。从 MVC 到 MVP，再到 MVVM，目前已经发展到 MVI。</li></ol><h2 id="二、MVC-架构"><a href="#二、MVC-架构" class="headerlink" title="二、MVC 架构"></a>二、MVC 架构</h2><ol><li><p>说明：模型（Model）、视图（View）、控制器（Controller）</p><p> 视图层：Android的xml布局文件和Activity&#x2F;Fragment文件被划分为View视图层。 因为xml作为视图层功能太弱，只能够实现页面的布局，不能够实现页面数据和事件的处理，需要和Activity一起才能够构成一个完整的视图层。</p><p> 业务层：大多数的MVC架构开发的安卓项目，并没有把Controller业务层独立出来，而是将业务层也在Activity&#x2F;Fragment中实现。这导致了Activity&#x2F;Fragment的代码非常臃肿，【比如，超1000行代码的Activity】。</p><p> 数据层：数据管理模块，这包括了数据的获取，加工、存储等。</p></li></ol><h3 id="实现代码说明："><a href="#实现代码说明：" class="headerlink" title="实现代码说明："></a>实现代码说明：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 描述：最早的传统 MVC 架构功能实现，这里模拟一个 登录 功能，输入账号密码，点击登录按钮，底部显示登录状态文本</span><br><span class="line"> */</span><br><span class="line">class MVCActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">  private lateinit var binding: ActivityMvcBinding</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 描述：M 层，用于处理数据</span><br><span class="line">  */</span><br><span class="line">  private val model = Model()</span><br><span class="line"></span><br><span class="line">  override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    binding = ActivityMvcBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">    // 登录按钮事件</span><br><span class="line">    binding.btnLogin.setOnClickListener &#123; login(binding.etAccount.text.toString(), binding.etPassword.text.toString()) &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 描述：登录，这里将本该放在独立业务层的，放在 V 层，把 Activity 当作 C 层用，用的时候确实方便，但是当功能非常复杂时，该类会非常臃肿，复杂度在该类</span><br><span class="line">   * 直接铺开，因为高度的耦合，不利用于代码复用，难以维护，修改容易出 bug</span><br><span class="line">   */</span><br><span class="line">  private fun login(account: String, password: String) &#123;</span><br><span class="line">    // 调用 M 层的方法获取结果</span><br><span class="line">    val success = model.login(account, password)</span><br><span class="line">    // 根据结果来渲染页面</span><br><span class="line">    binding.tvLoginResult.text = if (success) &quot;登录成功！&quot; else &quot;登录失败！&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 描述：模型层，用于数据获取、加工等</span><br><span class="line"> */</span><br><span class="line">class Model &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 描述：这里模拟一下登录成功或失败</span><br><span class="line">   */</span><br><span class="line">  fun login(account: String, password: String) =</span><br><span class="line">    account.isNotEmpty() &amp;&amp; password.isNotEmpty() &amp;&amp; account == &quot;123&quot; &amp;&amp; password == &quot;123&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、MVP-架构"><a href="#三、MVP-架构" class="headerlink" title="三、MVP 架构"></a>三、MVP 架构</h2><ol><li><p>说明：模型（Model）、视图（View）、业务逻辑层（Presenter）</p><p> 视图层：Android的xml布局文件和Activity&#x2F;Fragment文件被划分为View视图层。 因为xml作为视图层功能太弱，只能够实现页面的布局，不能够实现页面数据和事件的处理，需要和Activity一起才能够构成一个完整的视图层。</p><p> 业务层：Presenter 对象用于业务层，对逻辑进行处理，内部通过数据层来访问数据。使得界面绘制和业务逻辑分开，降低了它们的耦合，形成相互独立的界面层 V 和业务逻辑层 P。通过接口实现界面层和业务逻辑层的双向通信，界面层通过业务接口向业务逻辑层发起请求。业务逻辑层通过 View 层接口指导界面绘制。接口是一种抽象手段，它把做什么和怎么做分离，为发生多态提供了便利。</p><p> 数据层：数据管理模块，这包括了数据的获取，加工、存储等。</p></li></ol><p>由上述分析可知，V 层的业务逻辑处理给到了 P 层，所以 V 层更加单纯了，也没那么臃肿了，复杂度也降低了，跟 M 和 P 层的耦合度都降低了。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li>因为 View 层接口的存在，迫使 Presenter 得了解该把哪个数据塞给哪个 View 层接口。这是一种耦合，Presenter 和这个具体的 View 层接口耦合，较难复用于其他业务。</li><li>MVP 并未向界面提供唯一 UI 状态，而是将描述一个完整界面的 UI 状态 分散在若干 View 层接口回调中。这使得界面的绘制无法内聚到一点，增加了界面绘制逻辑维护的复杂度。</li><li>理论上，界面和业务分层之后，各自都更加单纯，为复用提供了可能性。但不管是业务接口的复用，还是View层接口的复用都相当别扭。</li><li>Presenter 与界面共存亡 ，使得 MVP 无法应对横竖屏切换的场景。</li><li>MVP 无法优雅地实现跨界面通信，也未内建粘性通信机制，得借助第三方库实现。</li><li>MVP 并未内建生命周期管理机制，易造成内存泄漏、crash、资源浪费。</li></ol><h3 id="实现代码说明：-1"><a href="#实现代码说明：-1" class="headerlink" title="实现代码说明："></a>实现代码说明：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line"> * 描述：MVP 架构功能实现，这里模拟一个 登录 功能，输入账号密码，点击登录按钮，底部显示登录状态文本</span><br><span class="line"> *  1. V 层会持有 P 层实例(面向接口，不是具体实例)，P 层实现 P层相关接口，让 V 层来发起具体业务。</span><br><span class="line"> *  2. P 层会持有 V 层实例(面向接口，不是具体实例)，V 层实现 V 层相关接口，来指导 P 层处理完业务逻辑之后的页面绘制。</span><br><span class="line"> *  3. P 层也会持有 M 层实例，用于数据的获取。</span><br><span class="line"> *</span><br><span class="line"> *  总结：思想是独立业务层，页面刷新和业务发起都面向接口，便于代码复用和解耦，职责分工非常明确。但是会新增大量的接口，且代码复用时会造成很多空接口实现，增大了界面绘制的复杂度。</span><br><span class="line"> */</span><br><span class="line">class MVPActivity : AppCompatActivity(),IView&#123;</span><br><span class="line">  </span><br><span class="line">  private lateinit var binding: ActivityMvpBinding</span><br><span class="line">  </span><br><span class="line">  // 持有 P 层实例</span><br><span class="line">  private val presenter :IPresenter= Presenter()</span><br><span class="line">  </span><br><span class="line">  override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    binding = ActivityMvpBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">    presenter.init(this)</span><br><span class="line">    // 登录按钮事件，通过 P 层发起业务</span><br><span class="line">    binding.btnLogin.setOnClickListener &#123; presenter.login(binding.etAccount.text.toString(), binding.etPassword.text.toString()) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  override fun loginSuccess() &#123;</span><br><span class="line">    // 根据接口约定来渲染页面</span><br><span class="line">    binding.tvLoginResult.text = &quot;登录成功！!&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  override fun loginFail() &#123;</span><br><span class="line">    // 根据接口约定来渲染页面</span><br><span class="line">    binding.tvLoginResult.text = &quot;登录失败！！&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  override fun onDestroy() &#123;</span><br><span class="line">    super.onDestroy()</span><br><span class="line">    presenter.destroy()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：模型层，用于数据获取、加工等</span><br><span class="line"> */</span><br><span class="line">class Model &#123;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 描述：这里模拟一下登录成功或失败</span><br><span class="line">   */</span><br><span class="line">  fun login(account: String, password: String) =</span><br><span class="line">    account.isNotEmpty() &amp;&amp; password.isNotEmpty() &amp;&amp; account == &quot;123&quot; &amp;&amp; password == &quot;123&quot;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：业务逻辑层，持有 M 和 V 层，通过 View 层接口指导界面绘制</span><br><span class="line">*/</span><br><span class="line">class Presenter : IPresenter &#123;</span><br><span class="line">  // 持有 V 层，不指向具体，面向接口抽象，便于解耦</span><br><span class="line">  private var view:IView? = null</span><br><span class="line">  // 持有 M 层 ，用于数据的处理</span><br><span class="line">  private val model = Model()</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 描述：初始化</span><br><span class="line">  */</span><br><span class="line">  override fun init(view:IView) &#123;</span><br><span class="line">    this.view = view</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 描述：具体业务</span><br><span class="line">  */</span><br><span class="line">  override fun login(account: String, password: String) &#123;</span><br><span class="line">    val success = model.login(account, password)</span><br><span class="line">    if (success) &#123;</span><br><span class="line">      view?.loginSuccess()</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      view?.loginFail()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 描述：销毁</span><br><span class="line">  */</span><br><span class="line">  override fun destroy() &#123;</span><br><span class="line">    this.view = null</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：业务逻辑层接口，让 V 层通过业务接口向业务逻辑层发起请求</span><br><span class="line"> */</span><br><span class="line">interface IPresenter &#123;</span><br><span class="line">  fun init(view:IView)</span><br><span class="line">  fun login(account: String, password: String)</span><br><span class="line">  fun destroy()</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：V 层接口，让 P 层通过该层接口指导界面绘制</span><br><span class="line"> */</span><br><span class="line">interface IView &#123;</span><br><span class="line">  fun loginSuccess()</span><br><span class="line">  fun loginFail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、MVVM-架构"><a href="#四、MVVM-架构" class="headerlink" title="四、MVVM 架构"></a>四、MVVM 架构</h2><ol><li><p>说明：模型（Model）、视图（View）、业务逻辑层（ViewModel）</p><p>视图层：Android的xml布局文件被划分为View视图层。</p><p>   业务层：ViewModel 对象用于业务层，对逻辑进行处理，内部通过数据层来访问数据。使得界面绘制和业务逻辑分开，降低了它们的耦合，形成相互独立的界面层 V 和业务逻辑层 VM。</p><p>   数据层：数据管理模块，这包括了数据的获取，加工、存储等。</p></li></ol><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>V 层会持有 VM 层实例，但是 VM 的生命周期比界面更长，在能够感知界面的生命周期，在 Activity 配置发生变化被销毁重建时恢复数据，以保证不会重新触发业务逻辑，解决了 P 层的痛点。</li><li>VM 层不再需要持有 V 层的引用了，而是通过 DataBinding 来跟页面进行绑定，进行双向通信，通过观察者模式，在数据更新时自动刷新界面。</li><li>界面刷新是以数据来驱动的，是响应式的，界面的刷新是持续不断去响应的，只要数据变更，就会响应刷新。而不像 P 层那样，要找到对应的 V 层接口方法去命令式地调用，进行界面刷新。</li><li>. 因为业务层只操纵数据，界面通过观察数据的方式实现刷新，所以更加的解耦，VM 层能更好地被复用。不同的界面可以以任何喜欢的方式组合使用业务层提供的数据。</li><li>不再需要定义各种根据业务或状态而决定的接口回调，更加的自由了。</li></ol><h3 id="实现代码说明：-2"><a href="#实现代码说明：-2" class="headerlink" title="实现代码说明："></a>实现代码说明：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">   /**</span><br><span class="line"> * 描述：MVVM 架构功能实现，这里模拟一个 登录 功能，输入账号密码，点击登录按钮，底部显示登录状态文本</span><br><span class="line"> *</span><br><span class="line"> *  1. V 层会持有 VM 层实例，但是 VM 的生命周期比界面更长，在能够感知界面的生命周期，在 Activity 配置发生变化被销毁重建时恢复数据，以保证不会重新触发业务逻辑，解决了 P 层的痛点。</span><br><span class="line"> *  2. VM 层不再需要持有 V 层的引用了，而是通过 DataBinding 来跟页面进行绑定，进行双向通信，通过观察者模式，在数据更新时自动刷新界面。</span><br><span class="line"> *  3. 界面刷新是以数据来驱动的，是响应式的，界面的刷新是持续不断去响应的，只要数据变更，就会响应刷新。而不像 P 层那样，要找到对应的 V 层接口方法去命令式地调用，进行界面刷新。</span><br><span class="line"> *  4. 因为业务层只操纵数据，界面通过观察数据的方式实现刷新，所以更加的解耦，VM 层能更好地被复用。不同的界面可以以任何喜欢的方式组合使用业务层提供的数据。</span><br><span class="line"> *</span><br><span class="line"> *  代码实现说明 ：通过Android提供的数据双向绑定库data binding 将Acitvity/xml视图层与ViewModel绑定。在xml布局文件中，通过@&#123;&#125;来表示单向绑定或者@=&#123;&#125;来表示双向绑定。</span><br><span class="line"> *  Activity接受到视图层的登录点击事件后，调用ViewModel处理登录业务逻辑，ViewModel通过双向数据绑定拿到到视图层输入的账号密码数据，调用Model处理数据，Model处理数据后，</span><br><span class="line"> *  回传给ViewModel, ViewModel的数据改变，View感知后刷新页面。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class MVVMActivity : AppCompatActivity() &#123;</span><br><span class="line">  </span><br><span class="line">  // 持有 VM 层实例</span><br><span class="line">  private val vm by viewModels&lt;MVVMViewModel&gt;()</span><br><span class="line">  </span><br><span class="line">  private lateinit var binding: ActivityMvvmBinding</span><br><span class="line">  </span><br><span class="line">  override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">     binding =</span><br><span class="line">         DataBindingUtil.setContentView&lt;ActivityMvvmBinding?&gt;(this, </span><br><span class="line">         R.layout.activity_mvvm).apply &#123;</span><br><span class="line">         setVariable(BR.viewModel, vm)</span><br><span class="line">         lifecycleOwner = this@MVVMActivity</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    // 登录按钮事件，通过 VM 层发起业务</span><br><span class="line">     binding.btnLogin.setOnClickListener &#123; vm.login() &#125;</span><br><span class="line">  </span><br><span class="line">    // 观察数据</span><br><span class="line">    vm.account.observe(this) &#123;</span><br><span class="line">      ToastUtils.showShortToast(it)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    // 观察数据</span><br><span class="line">    vm.password.observe(this) &#123;</span><br><span class="line">      ToastUtils.showShortToast(it)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    // 观察数据</span><br><span class="line">    vm.loginResult.observe(this) &#123;</span><br><span class="line">      ToastUtils.showShortToast(it)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：模型层，用于数据获取、加工等</span><br><span class="line"> */</span><br><span class="line">class Model &#123;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 描述：这里模拟一下登录成功或失败</span><br><span class="line">   */</span><br><span class="line">  fun login(account: String, password: String) =</span><br><span class="line">    account.isNotEmpty() &amp;&amp; password.isNotEmpty() &amp;&amp; account == &quot;123&quot; &amp;&amp; password == &quot;123&quot;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：VM 层，相当于 P 层，但是不需要通过 V 层接口来指导页面来绘制了，而是通过 DataBinding 来跟页面进行绑定，进行双向通信，通过观察者模式，在数据更新时自动刷新界面。</span><br><span class="line"> *      这使得 VM 层不再需要持有 V 层，跟 V 层解耦， V 层持有 VM 层实例，对想要观察的数据进行监听即可。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class MVVMViewModel : ViewModel() &#123;</span><br><span class="line">  // 可观察数据</span><br><span class="line">  val account = MutableLiveData(&quot;&quot;)</span><br><span class="line">  val password = MutableLiveData(&quot;&quot;)</span><br><span class="line">  val loginResult = MutableLiveData(&quot;&quot;)</span><br><span class="line">  </span><br><span class="line">  // 持有 M 层 ，用于数据的处理</span><br><span class="line">  private val model = Model()</span><br><span class="line">  </span><br><span class="line">  // 登录业务方法</span><br><span class="line">  fun login() &#123;</span><br><span class="line">    val success = model.login(account.value.orEmpty(), password.value.orEmpty())</span><br><span class="line">    loginResult.value = if (success) &quot;登录成功！!&quot; else &quot;登录失败！！&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、MVI-架构"><a href="#五、MVI-架构" class="headerlink" title="五、MVI 架构"></a>五、MVI 架构</h2><ol><li>说明：不关心业务层形态，而是关心业务数据变换及流动的形态。是一个单向数据流。界面是数据流的起点（生产者）也是终点（消费者），界面发出的数据叫（业务）意图，意图会用函数式编程的方式被变换为状态，最终状态通过响应式编程的方式流向界面，界面消费状态完成刷新。在这个流动的过程中，若保证了唯一可信数据源，就能实现单向数据流。</li></ol><h3 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h3><ol><li>MVI 架构对意图和状态的管理非常重要，过分仔细地区别会显得太乱，全部集中管理状态，会显的太臃肿，可能对界面刷新有性能影响。我们应该尽量集中管理独立的业务和状态，互相不影响。</li><li>什么情况下应该定义为意图，意图的维度，还有状态的维度，状态的字段到底要集中管理多少个属性，怎么定义并区分独立于其他的状态。页面状态独立消费处理，粒度不能太大，因为不能频繁刷新而影响性能，也不能太小，会导致刷新位置过于分散。</li><li>意图的管理：是通过多个不同的意图来区别业务，还是通过不同的入参来区别业务，需要斟酌。如果通过入参来区分，那么出参可能也要增加字段。</li><li>状态的管理：是通过不同的 data class 来刷新页面，还是通过集中管理 data class 中包括的字段来刷新页面。最终的 State 会通过 Intent ，copy 一个无副作用的对象（保证线程安全、数据可信唯一）并设置到出参字段，然后流向终点（界面）进行消费。在界面中，会通过不同的业务意图进行分支处理。</li></ol><h3 id="以下为非传统的-MVI-实现方式分析-："><a href="#以下为非传统的-MVI-实现方式分析-：" class="headerlink" title="以下为非传统的 MVI 实现方式分析 ："></a>以下为非传统的 MVI 实现方式分析 ：</h3><ol><li>意图(Intent)： 当前框架中的 Intent 非传统意义上的 MVI intent， 而是简化 reduce 和 action 后，拍平的 intent， 它可以携带 param，input 至 mvi-Dispatcher， 也可以 copy 和携带 result，output 至表现层。当实现 MVI 功能时，首先要分析各业务意图，进行意图的划分管理，包括入参和出参。</li><li>状态的定义(UIState)： 意图通过响应式编程处理并加工各种数据，并将（最终的处理结果）界面需要的状态封装成 data class ， 这里的 data 称之为 State 状态，但是这个状态不是对应一个 LiveData ，而是通过状态管理划分出来的一个数据对象。</li><li>整体流程是这样的： 意图带入参进行业务发送，ViewModel 来处理业务（单纯的领域层，内部包括 M 层进行数据的获取等，根据不同的意图进行一定程度的业务处理，并不包括数据的存储和恢复）。本架构的 StateHolder 不在同一个 ViewModel 中，而是新建的ViewModel ，放在 UI 层，用于数据的保存和恢复。这样，业务层的 ViewModel 相当的单纯，很方便被复用。StateHolder 的属性都是 ObservableField 对象，通过 DataBinding 进行页面的刷新绑定。</li><li>对于一些全局的业务VM ，可以通过 applicationViewModels 扩展函数来获取 VM ，这样该 VM 生命周期就是 Application 生命周期的，可随时进行意图的加工和发送，比如一些页面的刷新处理，一定程度上可以替代 EventBus 。</li></ol><h3 id="一些疑问？"><a href="#一些疑问？" class="headerlink" title="一些疑问？"></a>一些疑问？</h3><ul><li><p>为什么不直接在 UI 层通过方法调用来处理逻辑呢？</p><p> 答： 不符合 MVI 架构的理念，并不是单向数据流且复用度低。比如 A、B、C 三个页面都有一些相同的意图业务，每个类都是直接通过类内函数来处理，则无法进行代码复用。将方法放在基类又有点违反原则了。放在 VM 中进行复用，相当的有效，跟 MVP 中放在 P 层共用是一样的道理。注意，是业务意图，如果是单纯的界面处理逻辑，完全可以通过方法进行调用。</p></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>Intent 就是在提示你，将原先命令式的函数调用转换成一个事件数据，用响应式编程的方式进行事件到状态的变换，并且还得保证界面状态有唯一可信数据源，这样界面的刷新就形成了一条单向数据流。</li><li>只要满足“响应式编程”、“单向数据流”、“唯一可信数据源”这三个原则的都可以称之为 MVI。不管使用的是 ViewModel 还是 Presenter。MVI 关心的不是具体的界面状态持有者，而是整个更新界面数据链路的流动方式和方向。</li><li>整个页面的刷新逻辑都是遵循： Intent(业务意图) - (VM 处理) - View (消费)。</li></ol><h3 id="本项目架构中的-MVI-使用："><a href="#本项目架构中的-MVI-使用：" class="headerlink" title="本项目架构中的 MVI 使用："></a>本项目架构中的 MVI 使用：</h3><ol><li>在 MVVM 中 ，原本界面发起的事件是通过 ViewModel 的一个方法调用传递的。MVI 中，是响应式编程，得把函数调用用 “数据” 的形式包装起来。本架构中，用 input 方法发送上游数据。</li><li>接着在 onHandle 方法中对流上的数据进行变换处理，这个阶段可以通过 flow 的各种操作进行处理，流出的是 State ，用于界面消费渲染。本架构中，最终的 State 通过 Intent copy 之后的出参来设置。</li><li>最终 State 的消费由 sendResult 方法发送到界面层，界面层通过 output 出口拿到对应的 Intent 中的 State 进行消费【其中， State 会被界面层专属的 StateHolder 进行保存，用于数据恢复和使用】，本架构不对领域层的 State 进行监听消费，而将 State（界面状态）和 Activity&#x2F;fragment（界面展示）放在一起，归为 UI 层 ，但是 State 是通过 StateHolder 来保存的，也是一个 ViewModel ，只是这个 ViewModel 的职责专属该 UI 层保存和恢复数据 ，而领域层 VM ，对流进行业务处理，可供同业务不同页面复用。至此，一个单向数据流消费完成。</li></ol><h3 id="实现代码说明：-3"><a href="#实现代码说明：-3" class="headerlink" title="实现代码说明："></a>实现代码说明：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line"> * 描述：MVI 架构功能实现，这里模拟一个 登录 功能，输入账号密码，点击登录按钮，底部显示登录状态文本</span><br><span class="line"> *</span><br><span class="line"> * 本架构中的 MVI 使用：</span><br><span class="line"> *   1. MVVM 中 ，原本界面发起的事件是通过 ViewModel 的一个方法调用传递的。MVI 中，是响应式编程，得把函数调用用 &quot;数据&quot; 的形式包装起来。本架构中，用 input 方法发送上游数据。</span><br><span class="line"> *   2. 接着在 onHandle 方法中对流上的数据进行变换处理，这个阶段可以通过 flow 的各种操作进行处理，流出的是 State ，用于界面消费渲染。本架构中，最终的 State 通过 Intent copy 之后的出参来设置。</span><br><span class="line"> *   3. 最终 State 的消费由 sendResult 方法发送到界面层，界面层通过 output 出口拿到对应的 Intent 中的 State 进行消费【其中， State 会被界面层专属的 StateHolder 进行保存，用于数据恢复和使用】，本架构不对</span><br><span class="line"> *      领域层的 State 进行监听消费，而将 State（界面状态）和 Activity/fragment（界面展示）放在一起，归为 UI 层 ，但是 State 是通过 StateHolder 来保存的，也是一个 ViewModel ，只是这个 ViewModel 的职责专属该 UI 层保存和</span><br><span class="line"> *      恢复数据 ，而领域层 VM ，对流进行业务处理，可供同业务不同页面复用。至此，一个单向数据流消费完成。</span><br><span class="line"> */</span><br><span class="line">class MVIActivity : AppCompatActivity() &#123;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 描述： State（界面状态）和 Activity/fragment（界面展示）放在一起，归为 UI 层，专属该 UI 层保存和恢复数据</span><br><span class="line">   */</span><br><span class="line">  class MVIStateHolder : StateHolder() &#123;</span><br><span class="line">    val account = State(&quot;&quot;)</span><br><span class="line">    val password = State(&quot;&quot;)</span><br><span class="line">    val loginResult = State(&quot;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 持有 VM 层实例</span><br><span class="line">  private val vm by viewModels&lt;MVIViewModel&gt;()</span><br><span class="line">  private val accountStates by viewModels&lt;MVIStateHolder&gt;()</span><br><span class="line">  </span><br><span class="line">  private lateinit var binding: ActivityMviBinding</span><br><span class="line">  </span><br><span class="line">  override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    binding =</span><br><span class="line">      DataBindingUtil.setContentView&lt;ActivityMviBinding&gt;(this, R.layout.activity_mvi).apply &#123;</span><br><span class="line">        // 注意：这里传进去的 states 不要跟外层定义的变量同名，不然根据就没传入，引用的还是内层的对象</span><br><span class="line">        setVariable(BR.states, accountStates)</span><br><span class="line">        lifecycleOwner = this@MVIActivity</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">    binding.btnLogin.setOnClickListener &#123;</span><br><span class="line">      // 发送登录意图</span><br><span class="line">      vm.input(</span><br><span class="line">        AccountManagerIntent.LoginAccount(</span><br><span class="line">          accountStates.account.get()!!,</span><br><span class="line">          accountStates.password.get()!!</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    // 唯一出口，消费 Intent 中的 State</span><br><span class="line">    vm.output(this) &#123; accountManagerIntent -&gt;</span><br><span class="line">      when (accountManagerIntent) &#123;</span><br><span class="line">        is AccountManagerIntent.LoginAccount -&gt; &#123;</span><br><span class="line">  </span><br><span class="line">          updateUIState(accountManagerIntent.state)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 描述： 更新页面，状态独立处理，粒度不能太大，因为不能频繁刷新而影响性能，也不能太小，会导致刷新位置过于分散</span><br><span class="line">   */</span><br><span class="line">  private fun updateUIState(state: AccountManagerState) &#123;</span><br><span class="line">    accountStates.loginResult.set(state.loginResult)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：模型层，用于数据获取、加工等</span><br><span class="line"> */</span><br><span class="line">class Model &#123;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 描述：这里模拟一下登录成功或失败</span><br><span class="line">   */</span><br><span class="line">  fun login(account: String, password: String) =</span><br><span class="line">    account.isNotEmpty() &amp;&amp; password.isNotEmpty() &amp;&amp; account == &quot;123&quot; &amp;&amp; password == &quot;123&quot;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：UI State</span><br><span class="line"> */</span><br><span class="line">data class AccountManagerState(val success: Boolean = false, val loginResult: String = &quot;没登录&quot;)</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述： 账号管理意图，可能包括账号注册、登录、找回密码、注销等等</span><br><span class="line"> */</span><br><span class="line">sealed class AccountManagerIntent &#123;</span><br><span class="line">  // 登录业务意图</span><br><span class="line">  data class LoginAccount(</span><br><span class="line">    val account: String,</span><br><span class="line">    val password: String,</span><br><span class="line">    val state: AccountManagerState = AccountManagerState()</span><br><span class="line">  ) : AccountManagerIntent()</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 描述：对流进行业务处理，可供同业务不同页面复用</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class MVIViewModel : MviDispatcherKTX&lt;AccountManagerIntent&gt;() &#123;</span><br><span class="line">  </span><br><span class="line">  // 持有 M 层 ，用于数据的处理</span><br><span class="line">  private val model = Model()</span><br><span class="line">  </span><br><span class="line">  override suspend fun onHandle(event: AccountManagerIntent) &#123;</span><br><span class="line">    when (event) &#123;</span><br><span class="line">      is AccountManagerIntent.LoginAccount -&gt; &#123;</span><br><span class="line">        // 业务处理，可以是复杂的 flow 处理，流出 State</span><br><span class="line">        val success = model.login(event.account, event.password)</span><br><span class="line">        // 发送 State 给 UI 层消费，通过同一个 Intent 流出</span><br><span class="line">        val state = AccountManagerState(success, if (success) &quot;登录成功！!&quot; else &quot;登录失败！！&quot;)</span><br><span class="line">        ToastUtils.showShortToast(state.loginResult)</span><br><span class="line">        sendResult(event.copy(state = state))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>布局文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;data&gt;</span><br><span class="line">    &lt;variable</span><br><span class="line">      name=&quot;states&quot;</span><br><span class="line">      type=&quot;com.kunminx.purenote.mvi.MVIActivity.MVIStateHolder&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">  &lt;androidx.constraintlayout.widget.ConstraintLayout</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;EditText</span><br><span class="line">      android:id=&quot;@+id/et_account&quot;</span><br><span class="line">      android:layout_width=&quot;match_parent&quot;</span><br><span class="line">      android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">      app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class="line">      android:layout_margin=&quot;40dp&quot;</span><br><span class="line">      android:text=&quot;@=&#123;states.account&#125;&quot;</span><br><span class="line">      android:hint=&quot;账号&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;EditText</span><br><span class="line">      android:id=&quot;@+id/et_password&quot;</span><br><span class="line">      android:layout_width=&quot;match_parent&quot;</span><br><span class="line">      android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">      app:layout_constraintTop_toBottomOf=&quot;@id/et_account&quot;</span><br><span class="line">      android:layout_margin=&quot;40dp&quot;</span><br><span class="line">      android:text=&quot;@=&#123;states.password&#125;&quot;</span><br><span class="line">      android:hint=&quot;密码&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">      android:id=&quot;@+id/btn_login&quot;</span><br><span class="line">      android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">      android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">      app:layout_constraintTop_toBottomOf=&quot;@id/et_password&quot;</span><br><span class="line">      app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">      app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">      android:layout_marginTop=&quot;20dp&quot;</span><br><span class="line">      android:text=&quot;登录&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">      android:id=&quot;@+id/tv_login_result&quot;</span><br><span class="line">      android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">      android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">      app:layout_constraintTop_toBottomOf=&quot;@id/btn_login&quot;</span><br><span class="line">      app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">      android:layout_marginTop=&quot;40dp&quot;</span><br><span class="line">      android:textSize=&quot;20sp&quot;</span><br><span class="line">      app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">      android:text=&quot;@&#123;states.loginResult&#125;&quot;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/layout&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;架构演进分析和代码演示&lt;/p&gt;</summary>
    
    
    
    
    <category term="android" scheme="https://liuhangya.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>livedata</title>
    <link href="https://liuhangya.github.io/2022/06/06/livedata/"/>
    <id>https://liuhangya.github.io/2022/06/06/livedata/</id>
    <published>2022-06-06T06:23:54.000Z</published>
    <updated>2022-06-06T06:23:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>LiveData (可观察的数据存储器类)，使用篇…</p><span id="more"></span><h2 id="LiveData-可观察的数据存储器类-，使用篇"><a href="#LiveData-可观察的数据存储器类-，使用篇" class="headerlink" title="LiveData (可观察的数据存储器类)，使用篇"></a><strong>LiveData (可观察的数据存储器类)，使用篇</strong></h2><!-- 本地图片引用 --><!-- <img src="/2022/06/06/livedata/juanjuan01.jpg" class=""> --><p><img src="/2022/06/06/livedata/juanjuan01.jpg"></p><h4 id="作用：不是普通的观察类，具有生命周期感知能力，能够在-Activity、Fragment、Service-中正确的处理生命周期。"><a href="#作用：不是普通的观察类，具有生命周期感知能力，能够在-Activity、Fragment、Service-中正确的处理生命周期。" class="headerlink" title="作用：不是普通的观察类，具有生命周期感知能力，能够在 Activity、Fragment、Service 中正确的处理生命周期。"></a>作用：不是普通的观察类，具有生命周期感知能力，能够在 <code>Activity、Fragment、Service</code> 中正确的处理生命周期。</h4><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><h5 id="1-LiveData-是一个数据持有者，是数据源的包装类。"><a href="#1-LiveData-是一个数据持有者，是数据源的包装类。" class="headerlink" title="1. LiveData 是一个数据持有者，是数据源的包装类。"></a>1. <code>LiveData</code> 是一个数据持有者，是数据源的包装类。</h5><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="2-源数据使用-LiveData-进行包装之后，可以被观察，当数据有更新时，观察者可感知。"><a href="#2-源数据使用-LiveData-进行包装之后，可以被观察，当数据有更新时，观察者可感知。" class="headerlink" title="2. 源数据使用 LiveData 进行包装之后，可以被观察，当数据有更新时，观察者可感知。"></a>2. 源数据使用 <code>LiveData</code> 进行包装之后，可以被观察，当数据有更新时，观察者可感知。</h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h5 id="3-观察者感知或被通知到的时机是跟生命周期相关的，只发生在-Activity-Fragment-活跃生命周期状态，如果一个观察者处于-Paused-或-Destroyed-状态，它将不会收到通知。"><a href="#3-观察者感知或被通知到的时机是跟生命周期相关的，只发生在-Activity-Fragment-活跃生命周期状态，如果一个观察者处于-Paused-或-Destroyed-状态，它将不会收到通知。" class="headerlink" title="3. 观察者感知或被通知到的时机是跟生命周期相关的，只发生在 Activity/Fragment 活跃生命周期状态，如果一个观察者处于 Paused 或 Destroyed 状态，它将不会收到通知。"></a>3. 观察者感知或被通知到的时机是跟生命周期相关的，只发生在 <code>Activity/Fragment</code> 活跃生命周期状态，如果一个观察者处于 <code>Paused</code> 或 <code>Destroyed</code> 状态，它将不会收到通知。</h5><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><h5 id="1-不会发生内存泄漏且无须手动解除观察，LiveData-会在相应生命周期自动移除。"><a href="#1-不会发生内存泄漏且无须手动解除观察，LiveData-会在相应生命周期自动移除。" class="headerlink" title="1. 不会发生内存泄漏且无须手动解除观察，LiveData 会在相应生命周期自动移除。"></a>1. 不会发生内存泄漏且无须手动解除观察，<code>LiveData</code> 会在相应生命周期自动移除。</h5><h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5><h5 id="2-不会因-Activity-停止而导致崩溃，当生命周期处于非活跃状态，不会接收任何-LiveData-事件。"><a href="#2-不会因-Activity-停止而导致崩溃，当生命周期处于非活跃状态，不会接收任何-LiveData-事件。" class="headerlink" title="2. 不会因 Activity 停止而导致崩溃，当生命周期处于非活跃状态，不会接收任何 LiveData 事件。"></a>2. 不会因 <code>Activity</code> 停止而导致崩溃，当生命周期处于非活跃状态，不会接收任何 <code>LiveData</code> 事件。</h5><h5 id="-3"><a href="#-3" class="headerlink" title=""></a></h5><h5 id="3-数据始终保持最新状态且避免重复刷新界面，数据更新时若-Activity-为非活跃状态，那么会在变为活跃时接收最新数据。例如，在后台的-Activity-会在返回前台时立即接收最新的数据，而不是在每次数据变化时刷新界面。"><a href="#3-数据始终保持最新状态且避免重复刷新界面，数据更新时若-Activity-为非活跃状态，那么会在变为活跃时接收最新数据。例如，在后台的-Activity-会在返回前台时立即接收最新的数据，而不是在每次数据变化时刷新界面。" class="headerlink" title="3. 数据始终保持最新状态且避免重复刷新界面，数据更新时若 Activity 为非活跃状态，那么会在变为活跃时接收最新数据。例如，在后台的 Activity 会在返回前台时立即接收最新的数据，而不是在每次数据变化时刷新界面。"></a>3. 数据始终保持最新状态且避免重复刷新界面，数据更新时若 <code>Activity</code> 为非活跃状态，那么会在变为活跃时接收最新数据。例如，在后台的 <code>Activity</code> 会在返回前台时立即接收最新的数据，而不是在每次数据变化时刷新界面。</h5><h3 id="LiveData-的基础使用"><a href="#LiveData-的基础使用" class="headerlink" title="LiveData 的基础使用"></a>LiveData 的基础使用</h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><h5 id="1-创建-LiveData-实例，通过泛型指定源数据类型。"><a href="#1-创建-LiveData-实例，通过泛型指定源数据类型。" class="headerlink" title="1. 创建 LiveData 实例，通过泛型指定源数据类型。"></a>1. 创建 <code>LiveData</code> 实例，通过泛型指定源数据类型。</h5><h5 id="-4"><a href="#-4" class="headerlink" title=""></a></h5><h5 id="2-创建-Observer-实例，实现-onChanged-方法，用于接收源数据变化并刷新-UI。"><a href="#2-创建-Observer-实例，实现-onChanged-方法，用于接收源数据变化并刷新-UI。" class="headerlink" title="2. 创建 Observer 实例，实现 onChanged() 方法，用于接收源数据变化并刷新 UI。"></a>2. 创建 <code>Observer</code> 实例，实现 <code>onChanged()</code> 方法，用于接收源数据变化并刷新 UI。</h5><h5 id="-5"><a href="#-5" class="headerlink" title=""></a></h5><h5 id="3-LiveData-实例使用-observe-方法添加观察者，并传入-LifecycleOwner，就是-Activity-本身。"><a href="#3-LiveData-实例使用-observe-方法添加观察者，并传入-LifecycleOwner，就是-Activity-本身。" class="headerlink" title="3. LiveData 实例使用 observe() 方法添加观察者，并传入 LifecycleOwner，就是 Activity 本身。"></a>3. <code>LiveData</code> 实例使用 <code>observe()</code> 方法添加观察者，并传入 <code>LifecycleOwner</code>，就是 <code>Activity</code> 本身。</h5><h5 id="-6"><a href="#-6" class="headerlink" title=""></a></h5><h5 id="4-LiveData-实例使用-setValue-postValue-更新源数据-（工作线程要使用-postValue-）"><a href="#4-LiveData-实例使用-setValue-postValue-更新源数据-（工作线程要使用-postValue-）" class="headerlink" title="4. LiveData 实例使用 setValue()/postValue() 更新源数据 （工作线程要使用 postValue()）"></a>4. <code>LiveData</code> 实例使用 <code>setValue()/postValue()</code> 更新源数据 （工作线程要使用 <code>postValue()</code>）</h5><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class LiveDataTestActivity extends AppCompatActivity&#123;</span><br><span class="line"></span><br><span class="line">   private MutableLiveData&lt;String&gt; mLiveData;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">       super.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_lifecycle_test);</span><br><span class="line"></span><br><span class="line">       //liveData基本使用</span><br><span class="line">       mLiveData = new MutableLiveData&lt;&gt;();</span><br><span class="line">       mLiveData.observe(this, new Observer&lt;String&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onChanged(String s) &#123;</span><br><span class="line">               Log.i(TAG, &quot;onChanged: &quot;+s);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       Log.i(TAG, &quot;onCreate: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onCreate&quot;);//activity是非活跃状态，不会回调onChanged。变为活跃时，value被onStart中的value覆盖</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   protected void onStart() &#123;</span><br><span class="line">       super.onStart();</span><br><span class="line">       Log.i(TAG, &quot;onStart: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onStart&quot;);//活跃状态，会回调onChanged。并且value会覆盖onCreate、onStop中设置的value</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   protected void onResume() &#123;</span><br><span class="line">       super.onResume();</span><br><span class="line">       Log.i(TAG, &quot;onResume: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onResume&quot;);//活跃状态，回调onChanged</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   protected void onPause() &#123;</span><br><span class="line">       super.onPause();</span><br><span class="line">       Log.i(TAG, &quot;onPause: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onPause&quot;);//活跃状态，回调onChanged</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   protected void onStop() &#123;</span><br><span class="line">       super.onStop();</span><br><span class="line">       Log.i(TAG, &quot;onStop: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onStop&quot;);//非活跃状态，不会回调onChanged。后面变为活跃时，value被onStart中的value覆盖</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   protected void onDestroy() &#123;</span><br><span class="line">       super.onDestroy();</span><br><span class="line">       Log.i(TAG, &quot;onDestroy: &quot;);</span><br><span class="line">       mLiveData.setValue(&quot;onDestroy&quot;);//非活跃状态，且此时Observer已被移除，不会回调onChanged</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="注意：除了使用-observe-方法添加观察者，也可以使用-observeForever-Observer-方法来注册未关联-LifecycleOwner-的观察者。在这种情况下，观察者会被视为始终处于活跃状态。"><a href="#注意：除了使用-observe-方法添加观察者，也可以使用-observeForever-Observer-方法来注册未关联-LifecycleOwner-的观察者。在这种情况下，观察者会被视为始终处于活跃状态。" class="headerlink" title="注意：除了使用 observe() 方法添加观察者，也可以使用 observeForever(Observer) 方法来注册未关联 LifecycleOwner 的观察者。在这种情况下，观察者会被视为始终处于活跃状态。"></a>注意：除了使用 <code>observe()</code> 方法添加观察者，也可以使用 <code>observeForever(Observer)</code> 方法来注册未关联 <code>LifecycleOwner</code> 的观察者。在这种情况下，观察者会被视为始终处于活跃状态。</h5><h3 id="LiveData-的进阶使用"><a href="#LiveData-的进阶使用" class="headerlink" title="LiveData 的进阶使用"></a>LiveData 的进阶使用</h3><h4 id="1-Transformations-map-，如果想要在-LiveData-对象分发给观察者之前对其中存储的值进行更改，可以使用该方法。"><a href="#1-Transformations-map-，如果想要在-LiveData-对象分发给观察者之前对其中存储的值进行更改，可以使用该方法。" class="headerlink" title="1. Transformations.map()，如果想要在 LiveData 对象分发给观察者之前对其中存储的值进行更改，可以使用该方法。"></a>1. <code>Transformations.map()</code>，如果想要在 <code>LiveData</code> 对象分发给观察者之前对其中存储的值进行更改，可以使用该方法。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  //Integer类型的liveData</span><br><span class="line">  MutableLiveData&lt;Integer&gt; liveData = new MutableLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  //转换成String类型的transformedLiveData</span><br><span class="line">  LiveData&lt;String&gt; transformedLiveData  = Transformations.map(liveData1, new Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public String apply(Integer input) &#123;</span><br><span class="line">          String s = input + &quot; + Transformations.map&quot;;</span><br><span class="line">          Log.i(TAG, &quot;apply: &quot; + s);</span><br><span class="line">          return s;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">transformedLiveData .observe(this, new Observer&lt;String&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onChanged(String s) &#123;</span><br><span class="line">          Log.i(TAG, &quot;onChanged1: &quot;+s);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  liveData.setValue(100);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-Transformations-switchMap-，如果想要手动控制监听其中一个的数据变化，并能根据需要随时切换监听，这时可以使用-Transformations-switchMap-，它和-Transformations-map-使用方式类似，只不过switchMap-必须返回一个-LiveData-对象。如果要返回-必须返回一个LiveData-对象-就用-switchMap-，不需要就用-map-，效果差不多。"><a href="#2-Transformations-switchMap-，如果想要手动控制监听其中一个的数据变化，并能根据需要随时切换监听，这时可以使用-Transformations-switchMap-，它和-Transformations-map-使用方式类似，只不过switchMap-必须返回一个-LiveData-对象。如果要返回-必须返回一个LiveData-对象-就用-switchMap-，不需要就用-map-，效果差不多。" class="headerlink" title="2. Transformations.switchMap() ，如果想要手动控制监听其中一个的数据变化，并能根据需要随时切换监听，这时可以使用 Transformations.switchMap() ，它和 Transformations.map() 使用方式类似，只不过switchMap() 必须返回一个 LiveData 对象。如果要返回 必须返回一个LiveData 对象 就用 switchMap ，不需要就用 map ，效果差不多。"></a>2. <code>Transformations.switchMap()</code> ，如果想要手动控制监听其中一个的数据变化，并能根据需要随时切换监听，这时可以使用 <code>Transformations.switchMap()</code> ，它和 <code>Transformations.map()</code> 使用方式类似，只不过<code>switchMap()</code> 必须返回一个 <code>LiveData</code> 对象。如果要返回 <code>必须返回一个LiveData</code> 对象 就用 <code>switchMap</code> ，不需要就用 <code>map</code> ，效果差不多。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    private static final String TAG = &quot;MainActivity&quot;;</span><br><span class="line">    MutableLiveData&lt;String&gt; mutableLiveData1;</span><br><span class="line">    MutableLiveData&lt;String&gt; mutableLiveData2;</span><br><span class="line">    MutableLiveData&lt;Boolean&gt; liveDataSwitch;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mutableLiveData1 = new MutableLiveData&lt;&gt;();</span><br><span class="line">        mutableLiveData2 = new MutableLiveData&lt;&gt;();</span><br><span class="line">        liveDataSwitch = new MutableLiveData&lt;Boolean&gt;();//1</span><br><span class="line"></span><br><span class="line">        LiveData transformedLiveData= Transformations.switchMap(liveDataSwitch, new Function&lt;Boolean, LiveData&lt;String&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public LiveData&lt;String&gt; apply(Boolean input) &#123;</span><br><span class="line">                if (input) &#123;</span><br><span class="line">                    return mutableLiveData1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return mutableLiveData2;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        transformedLiveData.observe(this, new Observer&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onChanged(@Nullable final String s) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onChanged:&quot; + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        liveDataSwitch.postValue(false);//2</span><br><span class="line">        mutableLiveData1.postValue(&quot;kotlin&quot;);</span><br><span class="line">        mutableLiveData2.postValue(&quot;java&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通过-liveDataSwitch-对象控制是监听-mutableLiveData1-的数据还是-mutableLiveData2-的数据。"><a href="#通过-liveDataSwitch-对象控制是监听-mutableLiveData1-的数据还是-mutableLiveData2-的数据。" class="headerlink" title="通过 liveDataSwitch 对象控制是监听 mutableLiveData1 的数据还是 mutableLiveData2 的数据。"></a>通过 <code>liveDataSwitch</code> 对象控制是监听 <code>mutableLiveData1</code> 的数据还是 <code>mutableLiveData2</code> 的数据。</h5><h4 id="3-合并多个-LiveData-数据源，MediatorLiveData-继承自-mutableLiveData-，它可以将多个-LiveData-数据源集合起来，可以达到一个组件监听多个-LiveData-数据变化的目的。"><a href="#3-合并多个-LiveData-数据源，MediatorLiveData-继承自-mutableLiveData-，它可以将多个-LiveData-数据源集合起来，可以达到一个组件监听多个-LiveData-数据变化的目的。" class="headerlink" title="3. 合并多个 LiveData 数据源，MediatorLiveData 继承自 mutableLiveData ，它可以将多个 LiveData 数据源集合起来，可以达到一个组件监听多个 LiveData 数据变化的目的。"></a>3. 合并多个 <code>LiveData</code> 数据源，<code>MediatorLiveData</code> 继承自 <code>mutableLiveData</code> ，它可以将多个 <code>LiveData</code> 数据源集合起来，可以达到一个组件监听多个 <code>LiveData</code> 数据变化的目的。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">val mutableLiveData1 = MutableLiveData&lt;String&gt;()</span><br><span class="line">val mutableLiveData2 = MutableLiveData&lt;String&gt;()</span><br><span class="line">val liveDataMerger = MediatorLiveData&lt;String&gt;()</span><br><span class="line">liveDataMerger.addSource(mutableLiveData1, object : Observer&lt;String&gt; &#123;</span><br><span class="line">    override fun onChanged( o: String) &#123;</span><br><span class="line">        LogUtils.d(TAG, &quot;onChanged1:$o&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">liveDataMerger.addSource(mutableLiveData2, object : Observer&lt;String&gt; &#123;</span><br><span class="line">    override fun onChanged( o: String) &#123;</span><br><span class="line">        LogUtils.d(TAG, &quot;onChanged2:$o&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">liveDataMerger.observe(this, object : Observer&lt;String&gt; &#123;</span><br><span class="line">    override fun onChanged( o: String) &#123;</span><br><span class="line">        // 这里的触发场景，通常是监听的 Livedata源达到某个条件，再更新 liveDataMerger 的值进行回调的</span><br><span class="line">        LogUtils.d(TAG, &quot;onChanged3:$o&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">mutableLiveData1.postValue(&quot;mutableLiveData1文本&quot;)</span><br><span class="line">mutableLiveData2.postValue(&quot;mutableLiveData2文本&quot;)</span><br></pre></td></tr></table></figure><h5 id="其他使用场景：比如有一个列表界面，每一个-item-都可以点赞，每个-item-的赞都是一个数据源，我们可以监听点赞的数量，在达到某个条件处理逻辑。"><a href="#其他使用场景：比如有一个列表界面，每一个-item-都可以点赞，每个-item-的赞都是一个数据源，我们可以监听点赞的数量，在达到某个条件处理逻辑。" class="headerlink" title="其他使用场景：比如有一个列表界面，每一个 item 都可以点赞，每个 item 的赞都是一个数据源，我们可以监听点赞的数量，在达到某个条件处理逻辑。"></a>其他使用场景：比如有一个列表界面，每一个 <code>item</code> 都可以点赞，每个 item 的赞都是一个数据源，我们可以监听点赞的数量，在达到某个条件处理逻辑。</h5><h4 id="4-使用全局-Livedata-在多个视图监听状态"><a href="#4-使用全局-Livedata-在多个视图监听状态" class="headerlink" title="4. 使用全局 Livedata 在多个视图监听状态"></a>4. 使用全局 <code>Livedata</code> 在多个视图监听状态</h4><h4 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h4><h5 id="1-自定义-LiveData，重写-onActive-、onInactive-方法。"><a href="#1-自定义-LiveData，重写-onActive-、onInactive-方法。" class="headerlink" title="1. 自定义 LiveData，重写 onActive()、onInactive() 方法。"></a>1. 自定义 <code>LiveData</code>，重写 <code>onActive()、onInactive()</code> 方法。</h5><h5 id="2-实现为单例模式，实现多个-Activity、Fragment-之间共享数据。"><a href="#2-实现为单例模式，实现多个-Activity、Fragment-之间共享数据。" class="headerlink" title="2. 实现为单例模式，实现多个 Activity、Fragment 之间共享数据。"></a>2. 实现为单例模式，实现多个 <code>Activity、Fragment</code> 之间共享数据。</h5><h5 id="官方示例如下："><a href="#官方示例如下：" class="headerlink" title="官方示例如下："></a>官方示例如下：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class StockLiveData extends LiveData&lt;BigDecimal&gt; &#123;</span><br><span class="line">        private static StockLiveData sInstance; //单实例</span><br><span class="line">        private StockManager stockManager;</span><br><span class="line"></span><br><span class="line">        private SimplePriceListener listener = new SimplePriceListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onPriceChanged(BigDecimal price) &#123;</span><br><span class="line">                setValue(price);//监听到股价变化 使用setValue(price) 告知所有活跃观察者</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">//获取单例</span><br><span class="line">        @MainThread</span><br><span class="line">        public static StockLiveData get(String symbol) &#123;</span><br><span class="line">            if (sInstance == null) &#123;</span><br><span class="line">                sInstance = new StockLiveData(symbol);</span><br><span class="line">            &#125;</span><br><span class="line">            return sInstance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private StockLiveData(String symbol) &#123;</span><br><span class="line">            stockManager = new StockManager(symbol);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     //活跃的观察者（LifecycleOwner）数量从 0 变为 1 时调用</span><br><span class="line">        @Override</span><br><span class="line">        protected void onActive() &#123;</span><br><span class="line">            stockManager.requestPriceUpdates(listener);//开始观察股价更新</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     //活跃的观察者（LifecycleOwner）数量从 1 变为 0 时调用。这不代表没有观察者了，可能是全都不活跃了。可以使用hasObservers()检查是否有观察者。</span><br><span class="line">        @Override</span><br><span class="line">        protected void onInactive() &#123;</span><br><span class="line">            stockManager.removeUpdates(listener);//移除股价更新的观察</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyFragment extends Fragment &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onViewCreated(view, savedInstanceState);</span><br><span class="line">        //获取StockLiveData单实例，添加观察者，更新UI</span><br><span class="line">        StockLiveData.get(symbol).observe(getViewLifecycleOwner(), price -&gt; &#123;</span><br><span class="line">            // Update the UI.</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="其他示例，比如有一个登录验证码倒计时界面，在倒计时，需要在其他的页面也要同步这个倒计时状态，可以这样写："><a href="#其他示例，比如有一个登录验证码倒计时界面，在倒计时，需要在其他的页面也要同步这个倒计时状态，可以这样写：" class="headerlink" title="其他示例，比如有一个登录验证码倒计时界面，在倒计时，需要在其他的页面也要同步这个倒计时状态，可以这样写："></a>其他示例，比如有一个登录验证码倒计时界面，在倒计时，需要在其他的页面也要同步这个倒计时状态，可以这样写：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class GlobalLivedata : LiveData&lt;String&gt;() &#123;</span><br><span class="line">    val coundManager = CountDownManager()</span><br><span class="line">    val listener = object : OnDataChangeListener &#123;</span><br><span class="line">        override fun change(data: String) &#123;</span><br><span class="line">           postValue(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onActive() &#123;</span><br><span class="line">        super.onActive()</span><br><span class="line">        coundManager.setListener(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onInactive() &#123;</span><br><span class="line">        super.onInactive()</span><br><span class="line">        coundManager.removeListener(listener)</span><br><span class="line">    &#125;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        private lateinit var globalData: GlobalLivedata</span><br><span class="line">        fun getInstance(): GlobalLivedata &#123;</span><br><span class="line">            globalData = if (::globalData.isInitialized) globalData else GlobalLivedata()</span><br><span class="line">            return globalData</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LiveData (可观察的数据存储器类)，使用篇…&lt;/p&gt;</summary>
    
    
    
    
    <category term="jetpack android" scheme="https://liuhangya.github.io/tags/jetpack-android/"/>
    
  </entry>
  
</feed>
